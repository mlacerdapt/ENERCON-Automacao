/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: AddRemove.js/main/2$"

// -------------------------------------------------------------------------
// --------------------------- Component Construction & Initialization
// -------------------------------------------------------------------------
/**
    Dynamic element properties, defined on the container element:
        - leftButtonElt
        - rightButtonElt
        - leftOptionListElt
        - rightOptionListElt                
*/
function AddRemove( id, elt )
{
    // Initialize the base component
    var element = null;
    if( !elt )
        element = document.getElementById( id );
    else
        element = elt;
    this.initializeBaseComponent( element, "AddRemove" );
}
AddRemove.prototype = new BaseComponent();
AddRemove.prototype.constructor = AddRemove;

AddRemove.bindToId = function( id )
{
    var ar = new AddRemove( id );
    if( !ar.htmlElement.activated )
        AddRemove.activateAddRemove( ar.htmlElement );
    return ar;
}

AddRemove.bindToElt = function( elt )
{
    var ar = new AddRemove( null, elt );
    if( !ar.htmlElement.activated )
        AddRemove.activateAddRemove( ar.htmlElement );    
    return ar;
}


/**
 * elt is either the left or right move button, or the add/remove container element
 * @private
 */
AddRemove.activateAddRemove = function( elt, e )
{       
    if( !elt.activated )
    {
        var addRemoveContainerElt = null;    
        if( BaseComponent.isSpan( elt ) )    
            addRemoveContainerElt = elt;            
        else if( BaseComponent.isButton( elt ) )
        {
            var buttonId = elt.id;
            var delimeterIndex = buttonId.indexOf( "$" );
            var parentEltId = buttonId.substring( 0, delimeterIndex );                
            addRemoveContainerElt = document.getElementById( parentEltId );
            if( addRemoveContainerElt == null )
                throw new Error( "Activation failed. Could not get container element with id=" + parentEltId );         
        }
        else
            throw new Error( "AddRemove activation failed. The activation element must be either a span or button.  Instead it was a " + elt.nodeName );
            
        AddRemove.setComponentElementProperties( addRemoveContainerElt );
        AddRemove.bindHTMLEvents( addRemoveContainerElt );    
        if( e != null ) // One of the buttons has been clicked
        {        
            var addRemove = AddRemove.bindToElt( addRemoveContainerElt );
            var baseEvent = new BaseEvent( e );
            var sourceElt = baseEvent.getSourceElement();
            if( addRemove.htmlElement.log )
            {
                PageHelper.log( addRemove, "Activating with element id=" + sourceElt.id, e, "activateAddRemove" );
                PageHelper.log( addRemove, "Left button id=" + addRemove.htmlElement.leftButtonElt.id, e, "activateAddRemove" );
                PageHelper.log( addRemove, "Right button id=" + addRemove.htmlElement.rightButtonElt.id, e, "activateAddRemove" );                                                
            }                        
            if( sourceElt.id == addRemoveContainerElt.leftButtonElt.id )
                addRemove.handleMoveToRight( e );
            else
                addRemove.handleMoveToLeft( e );        
        }            
        elt.activated = true;
    }
}

AddRemove.setComponentElementProperties = function( parentElt )
{
    AddRemove.setLeftButtonElt( parentElt );
    AddRemove.setRightButtonElt( parentElt );    
    AddRemove.setLeftOptionListElt( parentElt );
    AddRemove.setRightOptionListElt( parentElt );
    AddRemove.setLeftValueListElt( parentElt );
    AddRemove.setRightValueListElt( parentElt );
    AddRemove.setRightValuesName( parentElt );
    AddRemove.setLeftValuesName( parentElt );        
}

AddRemove.setLeftButtonElt = function( parentElt )
{
    parentElt.leftButtonElt = document.getElementById( parentElt.id + "$leftButton" );
}

AddRemove.setRightButtonElt = function( parentElt )
{
    parentElt.rightButtonElt = document.getElementById( parentElt.id + "$rightButton" );
}

AddRemove.setLeftOptionListElt = function( parentElt )
{
    parentElt.leftOptionListElt = document.getElementById( parentElt.id + "$leftOptionList" );
}

AddRemove.setRightOptionListElt = function( parentElt )
{
    parentElt.rightOptionListElt = document.getElementById( parentElt.id + "$rightOptionList" );
}

AddRemove.setLeftValueListElt = function( parentElt )
{
    parentElt.leftValueListElt = document.getElementById( parentElt.id + "$leftValueList" );
}

AddRemove.setRightValueListElt = function( parentElt )
{
    parentElt.rightValueListElt = document.getElementById( parentElt.id + "$rightValueList" );
}

AddRemove.setRightValuesName = function( parentElt )
{
    var propertySpan = document.getElementById( parentElt.id + "$rightValuesName" );    
    parentElt.rightValuesName = propertySpan.firstChild.innerHTML;
}

AddRemove.setLeftValuesName = function( parentElt )
{
    var propertySpan = document.getElementById( parentElt.id + "$leftValuesName" );
    parentElt.leftValuesName = propertySpan.firstChild.innerHTML;
}        


// -------------------------------------------------------------------------
// --------------------------- Intrinsic & Extended Events Binding
// -------------------------------------------------------------------------

AddRemove.bindHTMLEvents = function( elt )
{
    elt.leftButtonElt.onclick = new Function( "e", "if( !e ) e = window.event; AddRemove.bindToId(\"" + elt.id + "\").handleMoveToRight( e );" );
    elt.rightButtonElt.onclick = new Function( "e", "if( !e ) e = window.event; AddRemove.bindToId(\"" + elt.id + "\").handleMoveToLeft( e );" );
}

AddRemove.addExtEvents = function( extEventsProcessor )
{
    extEventsProcessor.addEvent( "onMoveToRight" );
    extEventsProcessor.addEvent( "onMoveToLeft" );
}

AddRemove.prototype.handleMoveToRight = function( browserEvent )
{        
    // NEED TO THINK ABOUT HANDLING ENABLE/DISABLE
    var movedOptionsAr = this.moveOptions( this.getLeftOptionList(), this.getRightOptionList() );
    if( movedOptionsAr.length > 0 )
      fieldChangeMonitor.registerNonKeyFieldChange( this.htmlElement.id  );    
}

AddRemove.prototype.handleMoveToLeft = function( browserEvent )
{        
    // NEED TO THINK ABOUT HANDLING ENABLE/DISABLE
    var movedOptionsAr = this.moveOptions( this.getRightOptionList(), this.getLeftOptionList() );
    if( movedOptionsAr.length > 0  && fieldChangeMonitor)
      fieldChangeMonitor.registerNonKeyFieldChange( this.htmlElement.id  );    
}

AddRemove.prototype.moveOptions = function( fromList, toList )
{    
    if( this.htmlElement.log )
        PageHelper.log( this, "Move from list id=" + fromList.id, null, "moveOptions" );    
    
    var movedOptionsAr = new Array();    
    var index = fromList.selectedIndex;         
    if( index != -1 )    
    {
        var fromOptions = fromList.options;
        var fromValues = null;
        var fromValuesParent = null;
        var toValuesParent = null;
        var toValues = null;
        var toValuesName = null;
        if( this.isLeftList( fromList ) )
        {
            fromValuesParent = this.htmlElement.leftValueListElt;
            toValuesParent = this.htmlElement.rightValueListElt
            fromValues = this.getLeftValueList();
            toValues = this.getRightValueList();
            toValuesName = this.htmlElement.rightValuesName;
        }
        else
        {
            fromValuesParent = this.htmlElement.rightValueListElt;
            toValuesParent = this.htmlElement.leftValueListElt
            fromValues = this.getRightValueList();
            toValues = this.getLeftValueList();
            toValuesName = this.htmlElement.leftValuesName;
        }        
        var valuesToMoveAr = new Array();
        var valuesIndex = index;        
        if( this.htmlElement.log )
        {
            PageHelper.log( this, "fromParent id=" + fromValuesParent.id + ", toParent id=" + toValuesParent.id, null, "moveOptions" );
            PageHelper.log( this, "to values list name=" + toValuesName, null, "moveOptions" );
            PageHelper.log( this, "fromValues.length=" + fromValues.length, null, "moveOptions" );                        
        }
        
        // Move the selected list options                        
        while ( index < fromList.length )
        {
            var option = fromOptions[ index ];
            var movedOption = null;
            if ( option.selected )
            {            
                option.selected = false;
                movedOption = option.cloneNode( true );
                toList.options.add( new Option(movedOption.innerHTML, movedOption.value), toList.options.length);
                movedOptionsAr[movedOptionsAr.length] = movedOption;
                fromOptions.remove( index );
                var fromValuesElt = fromValues.item( valuesIndex );
                valuesToMoveAr[valuesToMoveAr.length] = fromValuesElt;                                                 
            }
            else            
                index++;    
            valuesIndex++;                
        } 
        
        var valueToMoveElt = null;
        for( var j=0; j < valuesToMoveAr.length; j++ )
        {
            valueToMoveElt = fromValuesParent.removeChild( valuesToMoveAr[j] );
            valueToMoveElt = valueToMoveElt.cloneNode( true );             
            toValuesParent.appendChild( valueToMoveElt );     
            valueToMoveElt.name = toValuesName;
        }
    }
    return movedOptionsAr;
}

AddRemove.prototype.getMoveToLeftButton = function()
{
    return this.htmlElement.rightButtonElt;
}

AddRemove.prototype.getMoveToRightButton = function()
{
    return this.htmlElement.leftButtonElt;
}

AddRemove.prototype.getLeftOptionList = function()
{
    return this.htmlElement.leftOptionListElt;
}

AddRemove.prototype.getRightOptionList = function()
{
    return this.htmlElement.rightOptionListElt;
}

AddRemove.prototype.getLeftValueList = function()
{
    return this.htmlElement.leftValueListElt.getElementsByTagName( "input" );
}

AddRemove.prototype.getRightValueList = function()
{
    return this.htmlElement.rightValueListElt.getElementsByTagName( "input" );
}

/**
 * Enables/disables this component.  List values are still submitted.
 * @param {Boolean} bool true to disable
 */
AddRemove.prototype.setDisable = function( bool )
{    
    this.htmlElement.disabled = bool;
    this.getLeftOptionList().disabled = bool;
    this.getRightOptionList().disabled = bool;
    this.getMoveToLeftButton().disabled = bool;
    this.getMoveToRightButton().disabled = bool;
}

/**
 * @return {Boolean} true if disabled
 */
AddRemove.prototype.isDisabled = function()
{
    return this.htmlElement.disabled;
}

AddRemove.prototype.isLeftList = function( listElt )
{
    return (listElt.id == (this.htmlElement.id + "$leftOptionList") );
}
/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: BaseComponent.js/main/44$"
/*
 * BaseComponent
 * -------------
 * This object represents a visible component on the page, which can be
 * shown, hidden, resized, moved, enabled, disabled, and layered.
 *

 Redesign Notes:
 - Created new method initializeExtEvents.  This was done to separate event initialization from all other initialization.
 This allows components to be initialized without extended event support.
 */

/*
 * Constructor
 * -----------
 * Creates a new BaseComponent.
 *
 */
function BaseComponent()
{
}

/**
 * Adds event definitions for events published by this class of objects.
 * @private
 */
BaseComponent.prototype.initializeBaseComponent = function( elt, objectName )
{
    this.id = elt.id;
    this.objectName = objectName;

    // This property refers to the HTML element this component represents
    this.htmlElement = elt;

    this.formID = null;
    this.htmlElement.monitored = true;
}

BaseComponent.prototype.addToTableCell = function( tableCellElt, rowId )
{
    this.htmlElement.id = this.getIndexedId( rowId );
    tableCellElt.appendChild( this.htmlElement );
}

/**
 * Get the raw HTML id.  If this component is nested with a Coral table, then then id will be in index format.  Index
 * format is defined as follows:  &lt;id&gt;[index] where index is the zero based table row index 
 * 
 * @return {String} The component id
 * @example ex. Indexed value for id &quot;OPERATION&quot; in the fifth table row: OPERATION[4]
 * @private
 */
BaseComponent.prototype.getId = function()
{
    return this.htmlElement.id;
}

/**
 * Get the component name for component types that support the name attribute.
 * @return {String} The component name, or null if the name attribute is undefined for the component type
 */
BaseComponent.prototype.getName = function()
{
    if( this.htmlElement.name )
        return this.htmlElement.name;
    return null;
}

/**
 * Set the &quot;key field&quot; property. A key field is a field that the user must enter a value for and is typically Only input fields can be key fields.
 * @param {Boolean} bool
 */
BaseComponent.prototype.setKeyField = function( val )
{
    this.htmlElement.keyField = val;
}

BaseComponent.prototype.setParentClassName = function( className )
{
    this.htmlElement.parentClassName = className;
}

BaseComponent.prototype.setBorderStyle = function( borderStyle )
{
    this.htmlElement.style.border = borderStyle;
}

/**
 * Set the &quot;disabled&quot; HTML property for the component
 * @param {Boolean} bool
 */
BaseComponent.prototype.setDisable = function( bool )
{
    this.htmlElement.disabled = bool;
}

/**
 * Displays/hides the component.  If this component has a field label, then its label will also be hidden
 * as long as it was defined using the Coral label custom tag.
 * 
 * @param {HTMLElement} elt The component element
 * @param {Boolean} bool Display toggle
 * @param {String} displayType A valid CSS display type such as &quot;block&quot; or &quot;inline&quot;
 */
BaseComponent.setDisplay = function( elt, bool, displayType )
{
    var eltAr = new Array();
    eltAr.push( elt );

    // Hide this field's label
    var labelContainer = document.getElementById( elt.id + "_LABEL" );
    if( labelContainer )
        eltAr.push( labelContainer );

    for( var i=0; i < eltAr.length; i++ )
    {
        if( bool )
            eltAr[i].style.display = displayType;
        else
            eltAr[i].style.display = "none";
    }
}

BaseComponent.prototype.setDebug = function( val )
{
    PageHelper.setDebug( null, val, this.htmlElement )
}

/**
 * Gets the id for the component
 * @param {Boolean} retainIndex If true then remove the index portion of the id if this component is
 * nested within a Coral table
 * @return {String} The component id
 */
BaseComponent.prototype.getComponentId = function( retainIndex )
{
    if( retainIndex )
        return this.htmlElement.id;
    return BaseComponent.removeComponentIdIndex( this.htmlElement.id );
}

BaseComponent.prototype.getIndexedId = function( index, id )
{
    var tmpId = this.id;
    if( id )
        tmpId = id;
    return tmpId + "[" + index + "]";
}

BaseComponent.prototype.getExtendedProperty = function( name )
{
    if( this.htmlElement.extendedProperties )
        return this.htmlElement.extendedProperties[ name ];
    return null;
}

/**
 * Determines if this component is nested in a Coral table
 * @return {Boolean} true if nested within a Coral table
 */
BaseComponent.prototype.inTable = function()
{
    var inTable = false;
    if( this.htmlElement.parentNode )
    {
        // get parent of this element (could be a span in a cell)
        var oParent = this.htmlElement.parentNode;
        if( BaseComponent.isSpan( this.htmlElement.parentNode ) ) {
            oParent = this.htmlElement.parentNode.parentNode;
        }

        if( BaseComponent.isTableCell(oParent) )
        {
            if( oParent.className )
            {
                var className = oParent.className;
                if( className.length > 4 )
                {
                    var tablePrefix = className.slice( 0, 5 );
                    if( tablePrefix == "table" )
                        inTable = true;
                }
            }
        }
    }
    return inTable;
}

/**
 * Returns the Coral table row index of this component
 * @return {int} The index of the table row containing this component, or -1 if the component is not in a table.
 */
BaseComponent.prototype.getRowIndex = function()
{
    // this.htmlElement.row is a reference to the row object created within the createTemplateRow function.
    // Since newly created rows do not have a valid index until they are inserted.
    var index = -1;
    if( this.htmlElement.row )
    {
        var row = this.htmlElement.row;
        if( row.htmlElement.inserted )
            index = row.htmlElement.sectionRowIndex;
    }
    else if( this.inTable() ) // Not a newly created row, use the table row that is already in the DOM
    {
        // get parent of this element (could be a span in a cell)
        var oParent = this.htmlElement.parentNode;
        if( BaseComponent.isSpan( this.htmlElement.parentNode ) ) {
            oParent = this.htmlElement.parentNode.parentNode;
        }

        var rowElt = oParent.parentNode;
        if( BaseComponent.isTableRow( rowElt ) )
            index = rowElt.sectionRowIndex;
    }
    return index;
}

/**
 * Returns the Coral table row id of this component
 * @return {int} The row id of the table row containing this component, or -1 if the component is not in a table
 */
BaseComponent.prototype.getRowId = function()
{
    // this.htmlElement.row is a reference to the row object created within the createTemplateRow function.
    // Since newly created rows do not have a valid index until they are inserted, rowId is used instead.
    // "rowId" is set as a property of TableRow based on the current number of rows as reported by the table object.
    if( this.htmlElement.row )
    {
        var row = this.htmlElement.row;
        if( row.htmlElement.inserted )
            return row.htmlElement.sectionRowIndex;
        else
            return row.htmlElement.rowId;
    }
    else
    {
        var rowObj = this.getRow();
        if( rowObj )
        {
            return rowObj.getId();
        }
    }

    // No row object or table row found, so this component must not be in a table.
    return -1;
}

/**
 * Get the TableRow object that contains this component
 * @return {TableRow} The table row containing this component, or null if this component is not in a table
 */
BaseComponent.prototype.getRow = function()
{
    if( this.htmlElement.row ) // Dynamically inserted row.
        return this.htmlElement.row;
    else if( this.inTable() )
    {
        var rowElt = this.htmlElement.parentNode.parentNode;
        return TableRow.bindToElt( rowElt );
    }
}

BaseComponent.removeComponentIdIndex = function( val )
{
    var retId = val;
    var index = val.indexOf( "[" );
    if( (index > -1) && ((index+1) < val.length))
        retId = val.slice( 0, index );
    return retId;
}


// Event handling wrapper method.
BaseComponent.prototype.addEvent = function( eventName )
{
    if( this.htmlElement.extEventsProcessor != null )
        this.htmlElement.extEventsProcessor.addEvent( eventName );
}

// Event handling wrapper method.
BaseComponent.prototype.publishEvent = function( eventName, eventObject )
{
    if( this.htmlElement.log )
        PageHelper.log( this, "publishing event=" + eventName, eventObject.browserEvent, "publishEvent" );

    eventObject.srcObject = this;

    if( this.htmlElement.extEventsProcessor != null )
        this.htmlElement.extEventsProcessor.publishEvent( eventName, eventObject );
}

/**
 * Causes this component to receive keyboard focus
 */
BaseComponent.prototype.focus = function()
{
    // CAN WE TEMPORARILY SET THE TAB INDEX PROPERTY (IF IT IS NOT SET ALREADY) SO THAT FOCUS WILL
    // BE SET FOR ANY ELEMENT, AND THEN UNSET IT AFTER THE CALL TO FOCUS????
    focusedField = this.id;
    this.htmlElement.focus();
}

BaseComponent.prototype.registerFieldChange = function()
{
    if( !this.getIgnoreChange() )
    {
        if( this.htmlElement.keyField )
        {
            fieldChangeMonitor.registerKeyFieldChange( this.htmlElement.id );
            if( this.htmlElement.log )
                PageHelper.log( this, "Registered key field change.", null, "registerFieldChange" );
            var elt = document.getElementById( "_IS_RETRIEVED" );
            if( elt )
                elt.value = "false";
            else
            {
                elt = document.createElement( "input" );
                elt.id = "_IS_RETRIEVED";
                elt.name = "_IS_RETRIEVED";
                elt.type = "hidden";
                elt.value = "false";
                document.forms[0].appendChild( elt );
                if( this.htmlElement.log )
                    PageHelper.log( this, "Created input element and set record retrieved flag=" + elt.value, null, "registerFieldChange" );
            }
        }
        else
        {
            if(fieldChangeMonitor){
            	fieldChangeMonitor.registerNonKeyFieldChange( this.htmlElement.id  );
            }
            if( this.htmlElement.log )
                PageHelper.log( this, "Registered non-key field change.", null, "registerFieldChange" );
        }
    }
    else if( this.htmlElement.log )
        PageHelper.log( this, "Field change ignored, ignoreChange=" + this.getIgnoreChange(), null, "registerFieldChange" );
}

/**
 * @return {Boolean} true if this field is not monitored for value changes
 */
BaseComponent.prototype.getIgnoreChange = function()
{
    if( !this.htmlElement.ignoreChange )
        return false;
    return true;
}

/**
 * @param {Node}
 * @return {Boolean} true if specified HTML node is any input type
 */
BaseComponent.isInput = function( node )
{
    if( !node )
        return false;
    return( node.nodeName == "INPUT" || node.nodeName == "input" );
}

/**
 * @return {Boolean} true if specified HTML node is a text input type
 */
BaseComponent.isInputText = function( node )
{
    if( !node )
        return false;
    if( node.nodeName == "INPUT" || node.nodeName == "input" )
        return ( node.type == "text" );  // type is returned in lower case
    return false;
}

/**
 * @return {Boolean} true if specified HTML node is a check box type
 */
BaseComponent.isInputCheckBox = function( node )
{
    if( !node )
        return false;
    if( BaseComponent.isInput( node ) )
        return ( node.type == "checkbox" );  // type is returned in lower case
    return false;
}

/**
 * @return {Boolean} true if specified HTML node is a radio button input type
 */
BaseComponent.isInputRadio = function( node )
{
    if( !node )
        return false;
    if( BaseComponent.isInput( node ) )
        return ( node.type == "radio" );  // type is returned in lower case
    return false;
}

/**
 * @return {Boolean} true if specified HTML node is a hidden input type 
 */
BaseComponent.isInputHidden = function( node )
{
    if( !node )
        return false;
    if( BaseComponent.isInput( node ) )
        return ( node.type == "hidden" );  // type is returned in lower case
    return false;
}

/**
 * @return {Boolean} true if specified HTML node is a password input type 
 */
BaseComponent.isInputPassword = function( node )
{
    if( !node )
        return false;
    if( BaseComponent.isInput( node ) )
        return ( node.type == "password" );  // type is returned in lower case
    return false;
}

/**
 * @return {Boolean} true if specified HTML node is a select list input type 
 */
BaseComponent.isSelect = function( node )
{
    if( !node )
        return false;
    if( node.nodeName == "SELECT" || node.nodeName == "select" )
        return true;
    else if( BaseComponent.isSpan( node ) )
    {
        // See if this is a disabled select
        if( node.parentNode ) // may be null if row is newly created and not added to the document
        {
            var nodeList = node.getElementsByTagName( "input" );
            var sibling = null;
            for( var i=0; i < nodeList.length; i++ )
            {
                sibling = nodeList.item( i );
                if( BaseComponent.isInputHidden( sibling ) )
                    if( sibling.className == "option" )
                        return true;
            }
        }
        return false;
    }
}

/**
 * @return {Boolean} true if specified HTML node is a link 
 */
BaseComponent.isLink = function( node )
{
    if( !node )
        return false;
    return ( node.nodeName == "A" || node.nodeName == "a" );
}

/**
 * @return {Boolean} true if specified HTML node is a table cell 
 */
BaseComponent.isTableCell = function( node )
{
    if( !node )
        return false;
    return ( node.nodeName == "TD" || node.nodeName == "td" );
}

/**
 * @return {Boolean} true if specified HTML node is a table row 
 */
BaseComponent.isTableRow = function( node )
{
    if( !node )
        return false;
    return ( node.nodeName == "TR" || node.nodeName == "tr" );
}

/**
 * @return {Boolean} true if specified HTML node is a span 
 */
BaseComponent.isSpan = function( node )
{
    if( !node )
        return false;
    return ( node.nodeName == "SPAN" || node.nodeName == "span" );
}

/**
 * @return {Boolean} true if specified HTML node is a button 
 */
BaseComponent.isButton = function( node )
{
    if( !node )
        return false;
    return ( node.nodeName == "BUTTON" || node.nodeName == "button" );
}

/**
 * Create a hidden input field with the given field name, value, and id
 * 
 *  @param {String} fieldName The HTML name attribute value
 *  @param {String} fieldVal The HTML value attribute value
 *  @param {String} id The HTML id attribute value
 *  @return {HTMLInputElement} The hidden input element
 */
BaseComponent.createHiddenField = function( fieldName, fieldVal, id )
{
    var hidden = document.createElement( "INPUT" );
    if( id ) hidden.id = id;
    hidden.type = "hidden";
    hidden.name = fieldName;
    if( fieldVal != null )
        hidden.value = fieldVal;
    return hidden;
}

BaseComponent.getChildInput = function( containerElt, name )
{
    var nodeList = containerElt.getElementsByTagName( "input" );
    if( nodeList && nodeList.length > 0 )
    {
        // If a field name was specified, use it to choose. Otherwise, return the first input elt.
        if( name )
        {
            var elt = null;
            for( var i=0; i < nodeList.length; i++ )
            {
                elt = nodeList.item(i);
                if( elt.name == name )
                    return elt;
            }
        }
        else
            return nodeList.item(0);
    }
    return null;
}

/**
 * Find the hidden input having the specified name.  If more than one input exists with the name, then the first found is returned.
 * 
 * @param {HTMLElement} containerElt The parent element that contains the hidden input
 * @param {String} [name] The hidden input name attribute value. If not provided, the first hidden input element is returned.
 * @return {HTMLInputElement} The hidden input element, or null if no hidden inputs are found within the container element
 */
BaseComponent.getHiddenInputNode = function( containerElt, name )
{
    var nodeList = containerElt.getElementsByTagName( "input" );
    if( nodeList && nodeList.length > 0 )
    {
        // If a field name was specified, use it to choose. Otherwise, return the first input elt.
        if( name )
        {
            var elt = null;
            for( var i=0; i < nodeList.length; i++ )
            {
                elt = nodeList.item(i);
                if( elt.name == name )
                    return elt;
            }
        }
        else
            return nodeList.item(0);
    }
    return null;
}

BaseComponent.getFirstChildTextNode = function( containerElt )
{
    if( containerElt.hasChildNodes() )
    {
        var children = containerElt.childNodes;
        var child = null;
        for( var i=0; i < children.length; i++ )
        {
            child = children.item(i);
            if( child.nodeType == 3 )
                return child;
        }
    }
    return null;
}

BaseComponent.prototype.transferBaseProperties = function( toObj )
{
    // Transfer the row reference if we're in a table
    if( this.htmlElement.row )
        toObj.htmlElement.row = this.htmlElement.row;

    // Transfer extended event listeners
    if( this.htmlElement.extEventsProcessor )
        toObj.htmlElement.extEventsProcessor = this.htmlElement.extEventsProcessor;

    // Transfer extended properties
    if( this.htmlElement.extendedProperties )
        toObj.htmlElement.extendedProperties = this.htmlElement.extendedProperties;

    // Transfer logging flag and enable debug
    if( this.htmlElement.log )
        PageHelper.setDebug( null, true, toObj.htmlElement );
}

BaseComponent.prototype.isLoggingEnabled = function()
{
    return this.htmlElement.log || PageHelper.logBrowse;
}
/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: BaseEvent.js/main/7$"

/*
 * BaseEvent
 * ---------
 * This object encapsulates information about an event.  Typically, this object
 * will be instantiated by an event publisher, properties will be added to the
 * object by the publisher, and the event will be delivered to all listeners by
 * the framework (BaseObject).
 *
 */

/*
 * Constructor
 * -----------
 * Maps browser-specific event information into this object.  The browser
 * specific event should be passed into the constructor.  If it is not, then
 * no properties will be set on the event object automatically.
 *
 */
function BaseEvent( browserEvent )
{
    this.browserEvent = browserEvent;
    this.returnValue = true;
}

/**
 * Get the HTML element that originated this event.
 * @return {HTMLElement}
 */
BaseEvent.prototype.getSourceElement = function()
{
    var retElt = null;
    if( this.browserEvent == null )
        return null;
    if( this.browserEvent.srcElement )
        retElt = this.browserEvent.srcElement;
    else if( this.browserEvent.target )
        retElt = this.browserEvent.target;
    return retElt;
}

/**
 * Get the id of the HTML element that originated this event.
 * @return {String} The element id
 */
BaseEvent.prototype.getSourceElementId = function()
{
    var sourceElm = this.getSourceElement();
    if(sourceElm)
    {
        return this.getSourceElement().id;
    }
    else
    {
        return null;
    }
}

/**
 * Cancel the event, averting normal browser processing.
 */
BaseEvent.prototype.cancelEvent = function()
{
    if( this.browserEvent )
    {
        if( this.browserEvent.preventDefault )
            this.browserEvent.preventDefault();
        else
        {
            this.browserEvent.returnValue = false;
            this.returnValue = false;
        }

    }
}

/**
 * Prevent the event from bubbling up to container object event handlers. 
 */
BaseEvent.prototype.cancelBubble = function()
{
    if( this.browserEvent )
        this.browserEvent.cancelBubble = true;
}

/**
 * @returns true if the [Alt] key was pressed when this event was published.
 */
BaseEvent.prototype.altPressed = function()
{
    if ( this.browserEvent != null )
    {
        if ( this.browserEvent.altKey ) return true;
    }
    return false;
}

/**
 * @returns true if the [Ctrl] key was pressed when this event was published.
 */
BaseEvent.prototype.ctrlPressed = function()
{
    if ( this.browserEvent != null )
    {
        if ( this.browserEvent.ctrlKey ) return true;
    }
    return false;
}

/**
 * @returns true if the [Shift] key was pressed when this event was published.
 */
BaseEvent.prototype.shiftPressed = function()
{
    if ( this.browserEvent != null )
    {
        if ( this.browserEvent.shiftKey ) return true;
    }
    return false;
}

/**
 * @returns {String}the key code associated with this event.  This method will return
 * a meaningful value for keypress-related events (keyPressed, keyDown, and keyUp).
 */
BaseEvent.prototype.getKeyCode = function()
{
    if ( this.browserEvent )
    {
        var keyCode = ('which' in this.browserEvent) ? this.browserEvent.which : this.browserEvent.keyCode;
        return keyCode;
    }
}

/**
 * @returns {Coordinate} The (x,y) coordinate of the mouse pointer when this event was
 * published.
 * @private
 */
BaseEvent.prototype.getMouseCoords = function()
{
    return new Coordinate( this.browserEvent.clientX, this.browserEvent.clientY );
}
/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: /main/11$"

// -------------------------------------------------------------------------
// --------------------------- Component Construction & Initialization
// -------------------------------------------------------------------------

function CheckBox( id, elt )
{
    // Initialize the base component
    var element = null;
    if( !elt )
        element = document.getElementById( id );
    else
        element = elt;

    this.initializeBaseComponent( element, "CheckBox" );
}
CheckBox.prototype = new BaseComponent();
CheckBox.prototype.constructor = CheckBox;

/**
 * Static method for creating a new component instance within a TableRow.
 * @param {Boolean} val true if the checkbox should be selected, false otherwise
 * @returns {CheckBox}
 */
CheckBox.create = function( id, name, val )
{
    var elt = document.createElement( "input" );
    elt.type = "checkbox";

    if( id ) elt.id = id;
    if( val ) elt.checked = true;

    var retObj = new CheckBox( null, elt );    
    var hiddenId = "_CHECKVAL" + retObj.id;
    var hiddenVal = null;

    if( val ) hiddenVal = "true";
    else hiddenVal = "false";

    retObj.hiddenCheckVal = BaseComponent.createHiddenField( name, hiddenVal, hiddenId );
    return retObj;
}

CheckBox.bindToId = function( id )
{
    return new CheckBox( id );
}

CheckBox.bindToElt = function( elt )
{
    return new CheckBox( null, elt );
}

CheckBox.activateCheckBox = function( checkBoxElt, e )
{
    CheckBox.bindHTMLEvents( checkBoxElt );
    if( e != null )
    {
        // Handle activation initiated by putting focus in the text field.
        CheckBox.bindToElt( checkBoxElt ).handleClick( e );
    }
}

CheckBox.prototype.addToTableCell = function( tableCellElt, rowId )
{
    this.htmlElement.id = this.getIndexedId( rowId );
    tableCellElt.appendChild( this.htmlElement );    
    this.hiddenCheckVal.id = "_CHECKVAL" + this.htmlElement.id;
    tableCellElt.appendChild( this.hiddenCheckVal );
}

// -------------------------------------------------------------------------
// --------------------------- Intrinsic & Extended Events Binding
// -------------------------------------------------------------------------

CheckBox.bindHTMLEvents = function( elt )
{
    elt.onclick = new Function( "e", "if( !e ) e = window.event; CheckBox.bindToElt( this ).handleClick( e );" );
}

CheckBox.addExtEvents = function( extEventsProcessor )
{
    extEventsProcessor.addEvent( "onCheck" );
    extEventsProcessor.addEvent( "onUncheck" );
}

// Update the submit value according to the current value of the checked property.
// Publish "onCheck" or "onUncheck" respectively.
CheckBox.prototype.handleClick = function( browserEvent )
{
    var clickEvent = new BaseEvent( browserEvent );

    // If this field is disabled, always return false
    if ( this.htmlElement.disabled )
    {
        clickEvent.cancelEvent();
        return false;
    }
    else
    {        
        var valElt = document.getElementById(  "_CHECKVAL" + this.id );        
        if( this.htmlElement.checked )
        {
            this.publishEvent( "onCheck", clickEvent );
            valElt.value = "true";
        }
        else
        {
            this.publishEvent( "onUncheck", clickEvent );
            valElt.value = "false";
        }

        // Record field value change with the field monitor
        this.registerFieldChange();

        if( this.htmlElement.log ) PageHelper.log( this, "form submit value=" + valElt.value, browserEvent, "handleClick" );
    }
}

/**
 * Sets the checked state to true or false based on the given val.  This does not fire
 * an event.
 * 
 * @param {Boolean} val Checks the box if true, unchecks otherwise
 */
CheckBox.prototype.setChecked = function( val )
{
    this.htmlElement.checked = val;    
    var valElt = document.getElementById( "_CHECKVAL" + this.id );
    if( valElt )
    {
        if( val )
            valElt.value = "true";
        else
            valElt.value = "false";
    }
}

/**
 * Returns the checked state
 * 
 * @return {Boolean} true if the CheckBox is checked, false otherwise
 */
CheckBox.prototype.isChecked = function()
{
    return this.htmlElement.checked;
}

/**
 * Enables/disables this checkbox.  The checked state is still submitted when disabled.
 * 
 * @param {Boolean} bool true to disable, false to enable
 */
CheckBox.prototype.setDisable = function( bool )
{
    this.htmlElement.disabled = bool;
}

/**
 * @return {Boolean} true if the CheckBox is disabled, false otherwise
 */
CheckBox.prototype.isDisabled = function()
{
    return this.htmlElement.disabled;
}
/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: ChildParameterList.js/main/1$"
/*
    This object represents a list of embedded child parameters, used to pass several request parameters as a single
    string value (much like the standard URL query string).  There is a server side objec CommandClientHelper defines an
    API for parsing the resulting parameter string into name/value pairs.
    Ex.
    
    var paramList = new ChildParameterList();
    paramList.addParameter( "NAME1", "VALUE1" );
    paramList.addParameter( "NAME2", "VALUE2" );
    var listVal = paramList.toString(); // Renders the string NAME1;VALUE1|NAME2;VALUE2
    var listVal = paramList.toString(true); // Renders the string |NAME1;VALUE1|NAME2;VALUE2
*/

/*
    Object constructor.
*/
function ChildParameterList()
{
    this.list = new Array();
}

/**
 * Add a name/value pair to the list
 * @param {String} name The parameter name
 * @param {String} [value=""] The parameter value
 */
ChildParameterList.prototype.addParameter = function( name, value )
{
    var obj = new Object();
    obj.name = name;
    if( value != null )
        obj.value = value;
    else
        obj.value = "";
    this.list[this.list.length] = obj;
}

/**
 * Stringifies this parameter list using the parameter delimiter constants.  If the
 * isSublist flag is set, then the parameter delimiter will be prepended to the result, allowing
 * this list to be appended to an existing list value.
 * 
 * @return {String} A delimited list of name/value pairs, or empty string if there are no parameters
 */
ChildParameterList.prototype.toString = function( isSublist )
{
    var retVal = null;
    if( isSublist && this.list.length > 0 )
        retVal = ChildParameterList.parameterDelimiter;
    else
        retVal = "";
    for( var i=0; i < this.list.length; i++ )    
    {
        retVal += this.list[i].name + ChildParameterList.nameValueDelimiter + this.list[i].value;
        if( this.list.length > (i + 1) )
            retVal += ChildParameterList.parameterDelimiter;
    }
    return retVal;
}

ChildParameterList.parameterDelimiter = "|";
ChildParameterList.nameValueDelimiter = ";";function showFormulaEditDialog() {
	sap.ui.require(
					[ "sap/m/Dialog", "sap/m/Button", "sap/m/TextArea", "sap/m/Label" ],
					function(Dialog, Button, TextArea, Label) {
						var script = PageHelper.getTextArea("SCRIPT");
						var sText = script.getValue().replace(/&quot;/g, "\"");

						var oLabel = new Label ({
							text : DC500ScriptLabel
						});
						var oTextArea = new TextArea ({
								rows : 24,
								cols : 63,
								maxLength : 4000,
								growing : false,
								growingMaxLines : 24,
								value : sText,
								height : "100%",
								width : "100%"
						});
						var oSaveButton = new Button({
							text : okDefaultButton,
							tooltip : tooltipApplyText,
							press : function() {
								script.setValue(oTextArea.getValue());
								oDialog.destroy();
							}
						});
						var oCancelButton = new Button({
							text : cancelDefaultButton,
							tooltip : tooltipCancelText,
							press : function() {
								oDialog.destroy();
							}
						});
						var oDialog = new Dialog({
							title : DC500FormulaScriptTitle,
							contentWidth : "550px",
							contentHeight : "450px",
							resizable : false,
							draggable : false,
							verticalScrolling : false,
							horizontalScrolling : false
						}).addStyleClass("sapUiContentPadding");

						oDialog.addContent(oLabel);
						oDialog.addContent(oTextArea);
						oDialog.addButton(oSaveButton);
						oDialog.addButton(oCancelButton);
						oDialog.placeAt("modalPreview");
						oTextArea.setValue(sText);
						oDialog.open();
					})
}
/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: DataTree.js/main/12$"

DataTree.TREE_NODE_FOLDER_IMAGE_CLASS = "fd";
DataTree.TREE_MINUS_ICON_SCR    = contextPath + "/com/sap/me/system/common/client/images/tree_minus.gif";
DataTree.TREE_PLUS_ICON_SCR     = contextPath + "/com/sap/me/system/common/client/images/tree_plus.gif";
DataTree.TREE_FOLDER_OPEN_SCR   = contextPath + "/com/sap/me/system/common/client/images/folder_open.gif";
DataTree.TREE_FOLDER_CLOSED_SCR = contextPath + "/com/sap/me/system/common/client/images/folder_closed.gif";
DataTree.SELECTED_ROW_BG_COLOR  = "#ffec99";
DataTree.NODE_ID_SEPARATOR = ".";

function DataTree()
{
}

DataTree.selectNode = function( id, elt )
{
    var dataTreeElt = document.getElementById( id );
    if( dataTreeElt.selectedNode )
    {
        dataTreeElt.selectedNode.style.backgroundColor = dataTreeElt.selectedNode.prevBackgroundColor;
        if( dataTreeElt.selectedNode != elt )
        {
            var bgClr = elt.style.backgroundColor;
            elt.prevBackgroundColor = elt.style.backgroundColor;
            elt.style.backgroundColor = DataTree.SELECTED_ROW_BG_COLOR;
            dataTreeElt.selectedNode = elt;
        }
        else
            dataTreeElt.selectedNode = null;
    }
    else
    {
        var bgClr = elt.style.backgroundColor;
        elt.prevBackgroundColor = elt.style.backgroundColor;
        elt.style.backgroundColor = DataTree.SELECTED_ROW_BG_COLOR;
        dataTreeElt.selectedNode = elt;
    }

    var selectedNodeId = DataTree.computeNodeId( elt, id );
    var hiddenFieldId  = id + "_SELECTED_NODE";

    // put selected NodeID to the appropriate hidden field
    if( document.getElementById( hiddenFieldId ) == null )
    {
        var hiddenFieldElt = document.createElement( "INPUT" );
        hiddenFieldElt.setAttribute("type","hidden");
        hiddenFieldElt.setAttribute("id",hiddenFieldId);
        hiddenFieldElt.setAttribute("name",hiddenFieldId);

        // if there are forms in document defined not using <app:form> tag
        // then append hidden field to the first form
        if( document.forms != null && document.forms.length > 0 )
            document.forms[0].appendChild( hiddenFieldElt );
        else
            document.appendChild( hiddenFieldElt );
    }
    document.getElementById( hiddenFieldId ).value = selectedNodeId;
}

DataTree.toggleBranch =  function( id, control, branchId, folderId, nodeId)
{
    var branch = document.getElementById( branchId );
    var folder = document.getElementById( folderId );
    var branchStateFieldId = nodeId + "_BRANCH_STATE";
    var branchState = "";
    if( branch.style.display == "inline" )
    {
        branch.style.display = "none";
        control.src = DataTree.TREE_PLUS_ICON_SCR;
        folder.src  = DataTree.TREE_FOLDER_CLOSED_SCR;

        var dataTreeElt = document.getElementById( id );
        if( dataTreeElt.selectedNode && ( dataTreeElt.selectedNode != folder.nextSibling ) )
            DataTree.selectNode( id, folder.nextSibling );

		branchState = "COLLAPSED";
    }
    else
    {
        branch.style.display = "inline";
        control.src = DataTree.TREE_MINUS_ICON_SCR;
        folder.src  = DataTree.TREE_FOLDER_OPEN_SCR;
        branchState = "EXPANDED";
    }

    // Put the branch state in the appropriate hidden field
    if( document.getElementById( branchStateFieldId ) == null )
    {
        var hiddenFieldElt = document.createElement( "INPUT" );
        hiddenFieldElt.setAttribute("type","hidden");
        hiddenFieldElt.setAttribute("id",branchStateFieldId);
        hiddenFieldElt.setAttribute("name",branchStateFieldId);

        // if there are forms in document defined not using <app:form> tag
        // then append hidden field to the first form
        if( document.forms != null && document.forms.length > 0 )
            document.forms[0].appendChild( hiddenFieldElt );
        else
            document.body.appendChild( hiddenFieldElt );
    }
    document.getElementById(branchStateFieldId).value = branchState;
}

DataTree.computeNodeId = function( elt, treeId )
{
    if( elt != null && elt.id == treeId ) // this is the root span and the end of recursion
        return "";
    var parentDiv  = DataTree.findParentElement( elt, "DIV" );  // first <DIV> that contains elt
    var parentSpan = DataTree.findParentElement( elt, "SPAN" ); // first <SPAN> that contains elt
    var curNodeId  = DataTree.findChildEltNo( parentDiv, parentSpan );
    var parentNodeId = DataTree.computeNodeId( parentSpan, treeId );
    if( parentNodeId != "" )
        return parentNodeId + DataTree.NODE_ID_SEPARATOR + curNodeId;
    else
        return curNodeId;
}

// Finds the first parent element with the given Tag Name
// For example we have:
// <SPAN id="Span1">
//      <DIV id="Div1"><H1 id="Header"></H1></DIV>
// </SPAN>
// If we're looking for a parent <SPAN> element for element with id == "Header"
// element with id=="Span1" will be returned
DataTree.findParentElement = function( elt, parentTagName )
{
    var curElt;
    var curEltTagName;

    curElt = elt;
    do
    {
        curElt = curElt.parentNode;
        if( curElt == null )
            return null;
        curEltTagName = curElt.tagName;
    }
    while( curEltTagName != parentTagName )

    return curElt;
}

// Finds child element with the given Tag Name and number
// For example we have:
// <SPAN id="Span1">
//      <DIV id="Div1"></DIV>
//      <H1></H1>
//      <DIV id="Div2"></DIV>
// </SPAN>
// If we're looking for a child <DIV> element number 2 for element with id == "Span1"
// element with id=="Div2" will be returned
DataTree.findChildElement = function( elt, childEltTagName, childEltNo )
{
    var counter = 0;
    var allChildren = elt.childNodes;
    for( var i = 0; i < allChildren.length; ++i )
    {
        var curChild = allChildren.item( i );
        if( curChild.tagName == childEltTagName )
        {
            ++counter
            if( counter == childEltNo )
                return curChild;
        }
    }
    return null;
}

// Finds child element number among elements with the same Tag Name in a parent element
// For example we have:
// <SPAN>
//      <DIV id="First_Elt_ID">1st Div</DIV>
//      <H1 id="Header_ID">A HEADER</H1>
//      <DIV id="Second_Elt_ID"><2nd Div</DIV>
// </SPAN>
// If an element with id=="Second_Elt_ID" is send to this function, the result will be 2
DataTree.findChildEltNo = function( childElt, parentElt )
{
    if( childElt != null && parentElt != null )
    {
        var childEltNo = 0;
        var allChildren = parentElt.childNodes;
        for( var i = 0; i < allChildren.length; ++i )
        {
            var curChild = allChildren.item( i );
            if( curChild.tagName == childElt.tagName )
            {
                ++childEltNo;
                if( curChild == childElt )
                    return childEltNo;
            }
        }
    }
    return 0;
}

// Selects node by its ID (for example ID == 1.2.1.5)
DataTree.selectNodeById = function( nodeId, treeId )
{
    var nodeNumbers = nodeId.split( DataTree.NODE_ID_SEPARATOR );
    var nodeNumbersLength = nodeNumbers.length;
    var rootSpanElt = document.getElementById( treeId );
    var curSpanElt  = rootSpanElt;

    for( var i = 0; i < nodeNumbersLength - 1; ++i )
    {
        var nodeElt = DataTree.getBranchNodeRootElt( nodeNumbers[i], curSpanElt );
        DataTree.expandBranch( nodeElt, treeId );
        curSpanElt = nodeElt;
    }

    // Highlight last node
    var lastNodeElt = DataTree.getBranchNodeRootElt( nodeNumbers[nodeNumbersLength - 1], curSpanElt );
    if( lastNodeElt.id != null && lastNodeElt.id != "" )
    {
        var parentDiv = DataTree.findParentElement( lastNodeElt, "DIV" );
        lastNodeElt = DataTree.findChildElement( parentDiv, "SPAN", 1 );
    }
    DataTree.selectNode( treeId, lastNodeElt );
}

// If there is a currently selected element, scroll it into view.
DataTree.scrollSelectedIntoView = function( treeId )
{
      var dataTreeElt = document.getElementById( treeId );
      if( dataTreeElt )
      {
          if( dataTreeElt.selectedNode )
              dataTreeElt.selectedNode.scrollIntoView(false);
      }
}

DataTree.getBranchNodeRootElt = function( nodeNumber, nodeRootSpan )
{
    var divElt = DataTree.findChildElement( nodeRootSpan, "DIV", nodeNumber );
    if( divElt == null )
        return null;

    var divChildren = divElt.childNodes;
    var firstSpan   = DataTree.findChildElement( divElt, "SPAN", 1 );
    var spanWithId  = null;

    for( var i = 0; i < divChildren.length; ++i )
    {
        var curElt = divChildren.item(i);
        if( curElt.tagName == "SPAN" && curElt.id != null && curElt.id != "" )
            spanWithId = curElt;
    }

    if( spanWithId != null )
        return spanWithId;
    else
        return firstSpan;
}

DataTree.expandBranch = function( branchSpan, treeId )
{
    if( branchSpan.id == null )
        return null; // branch can not be expanded

    var divElt  = this.findParentElement( branchSpan, "DIV" );  // first <DIV> that contains elt
    if( divElt == null )
        return null; // Trying to expand a leaf;

    var divChildren = divElt.childNodes;
    for( var i = 0; i < divChildren.length; ++i )
    {
        var curChild = divChildren.item(i);
        if( curChild.tagName == "IMG" && curChild.className == DataTree.TREE_NODE_FOLDER_IMAGE_CLASS )
        {
            var folder  = curChild;
            var control = curChild.previousSibling;
            branchSpan.style.display = "inline";
            control.src = DataTree.TREE_MINUS_ICON_SCR;
            folder.src  = DataTree.TREE_FOLDER_OPEN_SCR;
        }
    }
}

DataTree.getSelectedNodeId = function( treeId )
{
    var hiddenField = document.getElementById( treeId + "_SELECTED_NODE" );
    return hiddenField.value;
}

DataTree.initialize = function( treeId )
{
    var selectedNodeId = DataTree.getSelectedNodeId( treeId );
    if( selectedNodeId && ( selectedNodeId.length > 0 ) )
        DataTree.selectNodeById( selectedNodeId, treeId );
}

DataTree.handleKeyDown = function(evt, id) {
    var dataTreeElt;
    var nodeElt;

    if (evt.keyCode == 13) {
        if (BaseComponent.isLink(evt.srcElement)) {
            return true;
        }

        dataTreeElt = document.getElementById(id);
        if (dataTreeElt.selectedNode) {
            nodeElt = dataTreeElt.selectedNode.previousSibling;
            nodeElt = nodeElt.previousSibling;
            if (nodeElt && nodeElt.tagName == 'IMG') {
                nodeElt.click();
                evt.returnValue = false;
            }
        }
    } else if (evt.keyCode == 38 || evt.keyCode == 40) {
        var newId;
        dataTreeElt = document.getElementById(id);

        if (dataTreeElt.selectedNode) {
            var curId = dataTreeElt.selectedNode.id;
            var index1 = curId.lastIndexOf("[");
            var index2 = curId.lastIndexOf("]");

            if (index1 >= 0 && index2 >= 0) {
                var pos = parseInt(curId.substring(index1 + 1, index2));
                var parentId = curId.substring(0, index1);

                if (evt.keyCode == 38) {
                    newId = parentId + "[" + (pos - 1) + "]";
                    nodeElt = document.getElementById(newId);
                    if (nodeElt) {
                        newId = DataTree.getLastChildNodeId(newId);
                    } else {
                        newId = parentId;
                    }
                } else if (evt.keyCode == 40) {
                    newId = curId + "[0]";
                    nodeElt = document.getElementById(newId);

                    if (!nodeElt || DataTree.isCollapsed(nodeElt)) {
                        newId = parentId + "[" + (pos + 1) + "]";
                        nodeElt = document.getElementById(newId);
                        if (!nodeElt) {
                            newId = DataTree.getNextParentNodeId(parentId);
                        }
                    }
                }
            }
        } else {
            newId = id + "[0]";
        }

        nodeElt = document.getElementById(newId);
        if (nodeElt) {
            nodeElt.click();
            DataTree.scrollSelectedIntoView(id);
            evt.returnValue = false;
        }
    }
}

DataTree.getNextParentNodeId = function(nodeId) {
    var index1 = nodeId.lastIndexOf("[");
    var index2 = nodeId.lastIndexOf("]");

    if (index1 >= 0 && index2 >= 0) {
        var pos = parseInt(nodeId.substring(index1 + 1, index2));
        var parentId = nodeId.substring(0, index1);
        var newId = parentId + "[" + (pos + 1) + "]";
        var nodeElt = document.getElementById(newId);

        if (nodeElt) {
            return newId;
        } else {
           return DataTree.getNextParentNodeId(parentId);
        }
    }
    return null;
}

DataTree.getLastChildNodeId = function(nodeId) {
    var newId = nodeId + "[0]";
    var nodeElt = document.getElementById(newId);
    if (!nodeElt || DataTree.isCollapsed(nodeElt)) {
        return nodeId;
    }

    var nextId = newId;
    var pos = 1;
    while (nodeElt) {
        newId = nextId;
        nextId = nodeId + "[" + pos + "]";
        nodeElt = document.getElementById(nextId);
        pos++;
    }

    return DataTree.getLastChildNodeId(newId);
}

DataTree.isCollapsed = function(nodeElt) {
    var parentElement = DataTree.findParentElement(nodeElt, "SPAN");
    return ("none" == parentElement.style.display);
}
/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: DateChooser.js/main/4$"

/*
 * DateChooser
 * -----------
 * This object displays a small calendar which can be used to select a date.
 * This object manages the format of the date, according to a locale format
 * specified.
 * @since Globaliztion requires DateChooser.import.jsp
 * @since Globaliztion 5.2 this file is not used for DateField component
 */

function DateChooser()
{
    this.today = new Date();
    this.month = this.today.getMonth() + 1;
    this.day = this.today.getDate();
    this.year = this.today.getFullYear();

    this.windowName = null;

    var eep = new ExtEventsProcessor();
    this.extEventsProcessor = eep;
    this.addExtEvents( eep );
}
DateChooser.prototype.constructor = DateChooser;

// Default localized day names
DateChooser.Weekday = new Array(7);

// Indexes of Days of week depends on locale
DateChooser.WeekdayIndex = new Array(7);

// Default localized month names
DateChooser.Month = new Array(12);

/*
 * displayCalendar( windowName )
 * -----------------------------
 * Displays a calendar in the specified window.
 *
 */
DateChooser.prototype.displayCalendar = function( windowName, date )
{
    var index = 0;
    var month = null;
    var year = null;
    var colIndex = 0;
    var rowIndex = 0;
    var dayIndex = 0;
    var currentDay = 0;
    var todayDate = -1;
    var maxDays = 27;

    // Get a reference to the window this calendar will be rendered into
    this.windowName = windowName;
    var win = windowManager.getWindow( windowName );
    win.document.title = DateChooser.windowTitle;

    // Store the month and year for the date passed in
    this.displayedMonth = date.getMonth();
    this.displayedYear = date.getFullYear();

    // Figure out if today is in the month being displayed
    var tempDate = new Date();
    if ( date.getMonth() == tempDate.getMonth() )
    {
        if ( date.getFullYear() == tempDate.getFullYear() )
        {
            todayDate = tempDate.getDate();
        }
    }

    // Get the day of the week that the first of the given month starts on
    var tempDate = new Date();
    tempDate.setTime( date.getTime() );
    tempDate.setDate( 1 );
    var dayFirst = DateChooser.WeekdayIndex[tempDate.getDay()];

    maxDays = this.getNumDaysInMonth( date );

    // Compute the number of rows we will need
    var numDaysInFirstRow = 7 - dayFirst;
    var numDaysLeft = maxDays - numDaysInFirstRow;
    var numRows = Math.ceil( numDaysLeft / 7 ) + 1;
    var maxCells = numRows * 7;

    // Build the date table
    var table = win.document.createElement( "TABLE" );
    table.id = "_internal_calendar";
    table.width = "420";
    table.border = "1";
    table.borderColor = "#C0C0C0";
    table.cellPadding = "3";
    table.cellSpacing = "0";

    // Add the month, year, and weekday headers
    var headers = win.document.createElement( "TBODY" );
    var monthYearRow = win.document.createElement( "TR" );
    headers.appendChild( monthYearRow );

    // Create the "flip to the left" cell
    var pageLeft = win.document.createElement( "TD" );
    pageLeft.width = "60";
    pageLeft.className = "weekday_heading";
    pageLeft.onclick = function() { this.jsObject.flipLeft(); };
    pageLeft.jsObject = this;
    pageLeft.innerHTML = "&lt;&lt;";
    pageLeft.style.cursor = "hand";
    monthYearRow.appendChild( pageLeft );

    // Create the month/year cell
    var monthYear = win.document.createElement( "TD" );
    monthYear.colSpan = "5";
    monthYear.className = "year_heading";
    monthYear.innerHTML = DateChooser.Month[ this.displayedMonth ] + " " + this.displayedYear;
    monthYearRow.appendChild( monthYear );

    // Create the "flip to the right" cell
    var pageRight = win.document.createElement( "TD" );
    pageRight.width = "60";
    pageRight.className = "weekday_heading";
    pageRight.onclick = function() { this.jsObject.flipRight(); };
    pageRight.jsObject = this;
    pageRight.innerHTML = "&gt;&gt;";
    pageRight.style.cursor = "hand";
    monthYearRow.appendChild( pageRight );

    // Create the weekday headers
    var headerRow = win.document.createElement( "TR" );
    headers.appendChild( headerRow );
    for ( index = 0; index < 7; index++ )
    {
        var td = win.document.createElement( "TD" );
        td.width = "60";
        td.className = "weekday_heading";
                                            //Get week day index for user locale
        td.innerHTML = DateChooser.Weekday[ (7 + 2 * index - DateChooser.WeekdayIndex[index])%7 ];
        headerRow.appendChild( td );
    }
    table.appendChild( headers );

    // Create the days
    var tableBody = win.document.createElement( "TBODY" );
    for ( rowIndex = 0; rowIndex < numRows; rowIndex++ )
    {
        var tableRow = win.document.createElement( "TR" );
        for ( colIndex = 0; colIndex < 7; colIndex++ )
        {
            var td = win.document.createElement( "TD" );
            td.width = "60";
            td.height = "45";
            if ( ( dayIndex < dayFirst ) || ( currentDay >= maxDays ) )
            {
                td.className = "no_day";
            }
            else
            {
                currentDay++;
                td.className = "weekday";
                if ( currentDay == todayDate )
                {
                    td.className += " today";
                }

                td.innerHTML = currentDay;
                td.date = currentDay;
                td.jsObject = this;
                td.onmouseover = function() { this.oldClass = this.className; this.className = "weekday selected"; };
                td.onmouseout = function() { this.className = this.oldClass; };
                td.onclick = function() { this.jsObject.dateClicked( this.date ); };
            }
            tableRow.appendChild( td );
            dayIndex++;
        }
        tableBody.appendChild( tableRow );
    }
    table.appendChild( tableBody );

    // Render the table
    var win = windowManager.getWindow( windowName );
    win.setContentElement( table );
}

DateChooser.prototype.getNumDaysInMonth = function( date )
{
    var maxDays = 27;
    var month = date.getMonth();
    var tempDate = new Date( date );
    tempDate.setDate( maxDays );
    while ( month == tempDate.getMonth() )
    {
        maxDays = tempDate.getDate();
        tempDate.setDate( maxDays + 1 );
    }
    return maxDays;
}

DateChooser.prototype.flipLeft = function()
{
    var date;
    if ( this.displayedMonth > 0 )
    {
        date = PageHelper.createDate(1, this.displayedMonth - 1, this.displayedYear);
    }
    else
    {
        date = PageHelper.createDate(1, 11, this.displayedYear - 1);
    }
    this.displayCalendar( this.windowName, date );
}

DateChooser.prototype.flipRight = function()
{
    var date;
    if ( this.displayedMonth < 11 )
    {
        date = PageHelper.createDate(1, this.displayedMonth + 1, this.displayedYear);
    }
    else
    {
        date = PageHelper.createDate(1, 0, this.displayedYear + 1);
    }
    this.displayCalendar( this.windowName, date );
}

DateChooser.prototype.dateClicked = function( day )
{
    var date = PageHelper.createDate(day, this.displayedMonth, this.displayedYear);

    // Publish the date selected event
    var dateEvent = new BaseEvent();
    dateEvent.date = date;
    this.extEventsProcessor.publishEvent( "onDateSelected", dateEvent );

    // Close the calendar dialog
    windowManager.closeWindow( this.windowName );
}

DateChooser.prototype.addExtEvents = function( extEventsProcessor )
{
    extEventsProcessor.addEvent( "onDateSelected" );
    extEventsProcessor.addEvent( "windowCreated" );
}
/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: DateField.js/main/30$"

// -------------------------------------------------------------------------
// --------------------------- Component Construction & Initialization
// -------------------------------------------------------------------------

function DateField( id, elt )
{
    // Initialize the base component
    if( !elt )
        elt = document.getElementById( id );
    this.initializeBaseComponent( elt, "DateField" );
    try { // set up size only once!
        elt.elementSize = elt.elementSize == null ? document.getElementById( DateField.getInputFieldId( id ) ).size : elt.elementSize;
    } catch ( e ) {
    }
}
DateField.prototype = new BaseComponent();
DateField.prototype.constructor = DateField;

/**
 * Static method for creating a new component instance within a TableRow.  The component does not process the argument passed
 * to create row.  It's value is solely determined by the DateFieldTag model value.
 * @returns {DateField}
 */
DateField.create = function( id, name, dateTimeString, disabled, showTimeFields, endOfDay, localeContext, size, tooltip )
{
    var dateFieldSpan = document.createElement( "span" );
    dateFieldSpan.id = id;
    dateFieldSpan.elementSize = size;

    DateField.appendContentToParentSpan( dateFieldSpan, id, name, dateTimeString, disabled, showTimeFields, endOfDay, localeContext, size, tooltip );
    if ( disabled ) {
        dateFieldSpan.className = "text";
    }
    return new DateField( id, dateFieldSpan );
}

DateField.appendContentToParentSpan = function( spanElt, id, name, dateTimeString, disabled, showTimeFields, endOfDay, localeContext, size, tooltip ) {
    var spanContent;
    if ( disabled ) {
        spanContent = DateField.createDisabledSpanContent( id, name, dateTimeString, showTimeFields, endOfDay, localeContext, tooltip );
    } else {
        spanContent = DateField.createEnabledSpanContent( id, name, dateTimeString, showTimeFields, endOfDay, localeContext, size, tooltip );
    }

    for ( var i = 0; i < spanContent.length; ++i ) {
        spanElt.appendChild( spanContent[ i ] );
        var tag = spanContent[ i ].tagName;
        if ( tag && ( tag == "IMG" || tag == "img" ) ) {
            spanElt.browseElt = spanContent[ i ];
        }
    }
}

DateField.createDisabledSpanContent = function( id, name, dateTimeString, showTimeFields, endOfDay, localeContext, tooltip ) {
    var inputFieldId = DateField.getInputFieldId( id );
    var showTimeFieldId = DateField.getShowTimeFieldId( id );
    var endOfDayFieldId = DateField.getEndOfDayFieldId( id );
    var localeContextFieldId = DateField.getLocaleContextFieldId( id );
    var tooltipId = DateField.getCalendarIconId( id );

    var inputFieldElt = BaseComponent.createHiddenField( name, dateTimeString, inputFieldId );
    var displayText = document.createTextNode( dateTimeString );

    var dateTextSpanElt = document.createElement( "span" );
    dateTextSpanElt.id = DateField.getDisabledDateFieldTextId( id );
    dateTextSpanElt.appendChild( displayText );

    var showTimeElt = BaseComponent.createHiddenField( showTimeFieldId, showTimeFields ? "true" : "false", showTimeFieldId );
    var endOfDayElt = BaseComponent.createHiddenField( endOfDayFieldId, endOfDay ? "true" : "false", endOfDayFieldId );
    var localeContextElt = BaseComponent.createHiddenField( localeContextFieldId, localeContext == null ? "" : localeContext, localeContextFieldId );
    var tooltipElt = BaseComponent.createHiddenField( tooltipId, tooltip, tooltipId );

    return new Array( inputFieldElt, dateTextSpanElt, showTimeElt, endOfDayElt, localeContextElt, tooltipElt );
}

DateField.createEnabledSpanContent = function( id, name, dateTimeString, showTimeFields, endOfDay, localeContext, size, tooltip ) {
    var inputFieldId = DateField.getInputFieldId( id );
    var showTimeFieldId = DateField.getShowTimeFieldId( id );
    var endOfDayFieldId = DateField.getEndOfDayFieldId( id );
    var localeContextFieldId = DateField.getLocaleContextFieldId( id );

    var inputFieldElt = document.createElement( "input" );
    inputFieldElt.id = inputFieldId;
    inputFieldElt.name = name;
    inputFieldElt.type = "text";
    inputFieldElt.size = size;
    inputFieldElt.value = dateTimeString;
    inputFieldElt.onchange = new Function( "DateField.onChange( \"" + id + "\" );" );

    var calendarIcon = document.createElement( "IMG" );
    calendarIcon.id = DateField.getCalendarIconId( id );
    calendarIcon.src = DateField.getCalendarIconURL();
    calendarIcon.className = "browse_icon";
    calendarIcon.style.marginLeft = "3px";
    calendarIcon.onclick = new Function( "DateField.bindToId( \"" + id + "\" ).openCalendar();" );
    calendarIcon.title = tooltip;

    var showTimeElt = BaseComponent.createHiddenField( showTimeFieldId, showTimeFields ? "true" : "false", showTimeFieldId );
    var endOfDayElt = BaseComponent.createHiddenField( endOfDayFieldId, endOfDay ? "true" : "false", endOfDayFieldId );
    var localeContextElt = BaseComponent.createHiddenField( localeContextFieldId, localeContext == null ? "" : localeContext, localeContextFieldId );

    return new Array( inputFieldElt, calendarIcon, showTimeElt, endOfDayElt, localeContextElt );
}

DateField.bindToId = function( id )
{
    return new DateField( id );
}

DateField.bindToElt = function( elt )
{
    return new DateField(null, elt);
}

DateField.getInputFieldId = function( id ) {
    return id + "_INPUT";
}

DateField.getShowTimeFieldId = function( id ) {
    return id + "_SHOW_TIME";
}

DateField.getEndOfDayFieldId = function( id ) {
    return id + "_END_OF_DAY";
}

DateField.getLocaleContextFieldId = function( id ) {
    return id + "_LOCALE_CONTEXT";
}

DateField.getDisabledDateFieldTextId = function( id ) {
    return id + "_DATE_TIME_TEXT";
}

DateField.getCalendarIconId = function( id ) {
    return id + "_CALENDAR_ICON";
}

DateField.findById = function( parentElt, id ) {
    var children = parentElt.childNodes;
    if ( children == null || children.length == 0 ) {
        return null;
    }
    for ( var i = 0; i < children.length; ++i ) {
        if ( id == children[ i ].id ) {
            return children[ i ];
        }
    }
    return null;
}

DateField.onChange = function( id ) {
    DateField.bindToId( id ).registerFieldChange();
    try { // this function is presented on the screens with Date Range control
        DateRange.dateFieldChanged(id);
    } catch ( e ) {
    }
}

DateField.prototype.setSize = function( size ) {
    document.getElementById( this.htmlElement.id ).elementSize = size;
}

DateField.prototype.getSize = function() {
    return document.getElementById( this.htmlElement.id ).elementSize;
}

DateField.prototype.getInputFieldElement = function() {
    var id = DateField.getInputFieldId( this.htmlElement.id );
    return DateField.findById( this.htmlElement, id );
}

DateField.prototype.getShowTimeFieldElement = function() {
    var id = DateField.getShowTimeFieldId( this.htmlElement.id );
    return DateField.findById( this.htmlElement, id );
}

DateField.prototype.getEndOfDayElement = function() {
    var id = DateField.getEndOfDayFieldId( this.htmlElement.id );
    return DateField.findById( this.htmlElement, id );
}

DateField.prototype.getLocaleContextElement = function() {
    var id = DateField.getLocaleContextFieldId( this.htmlElement.id );
    return DateField.findById( this.htmlElement, id );
}

DateField.prototype.getDisabledDateFieldTextElement = function() {
    var id = DateField.getDisabledDateFieldTextId( this.htmlElement.id );
    return DateField.findById( this.htmlElement, id );
}

DateField.prototype.getCalendarIconElement = function() {
    var id = DateField.getCalendarIconId( this.htmlElement.id );
    return DateField.findById( this.htmlElement, id );
}

DateField.prototype.getCalendarIconTooltip = function() {
    var elt = this.getCalendarIconElement();
    if( this.isDisabled() ) {
        return elt.value;
    } else {
        return elt.title;
    }
}

/**
 * @returns {Boolean} true if the time part of the date is shown.
 */
DateField.prototype.showTime = function() {
    return this.getShowTimeFieldElement().value == "true";
}

DateField.prototype.isEndOfDayField = function() {
    return this.getEndOfDayElement().value == "true";
}

DateField.prototype.getLocaleContext = function() {
    if(this.getLocaleContextElement()) {
        return this.getLocaleContextElement().value.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }else{
        return;
    }
}

// elt must be the enclosing span
DateField.activateDateField = function( elt, e, iconElt )
{
    // Make sure we activate only once
    if ( elt.activated ) {
        return;
    }

    if ( iconElt != null ) {
        // Handle activation initiated by a click on the browse icon
        iconElt.onclick = new Function( "DateField.bindToId( \"" + elt.id + "\" ).openCalendar();" );
        DateField.bindHTMLEvents( elt );
        var dateFieldComp = DateField.bindToElt( elt );
        if( e != null )
            dateFieldComp.openCalendar();
    } else {
        // Handle activation initiated by putting focus in a date component field.
        DateField.bindHTMLEvents( elt );
        var dateFieldComp = DateField.bindToElt( elt );
        iconElt = document.getElementById( elt.id + "_CALENDAR_ICON" );

        // If the calendar icon is present, initialize its click event handler
        if( iconElt != null ) {
            iconElt.onclick = new Function( "DateField.bindToId( \"" + elt.id + "\" ).openCalendar();" );
            elt.browseElt = iconElt;
        }
    }
    elt.activated = true;
}

DateField.prototype.addToTableCell = function( tableCellElt, rowId )
{
    tableCellElt.appendChild( this.htmlElement );
    var indexedId = this.getIndexedId( rowId );

    this.getInputFieldElement().id = DateField.getInputFieldId( indexedId );
    this.getShowTimeFieldElement().id = DateField.getShowTimeFieldId( indexedId );
    this.getEndOfDayElement().id = DateField.getEndOfDayFieldId( indexedId );
    this.getLocaleContextElement().id = DateField.getLocaleContextFieldId( indexedId );

    var disabledFieldTextElement = this.getDisabledDateFieldTextElement();
    if ( disabledFieldTextElement ) {
        disabledFieldTextElement.id = DateField.getDisabledDateFieldTextId( indexedId );
    }

    var calendarIconElement = this.getCalendarIconElement();
    calendarIconElement.id = DateField.getCalendarIconId( indexedId );
    if ( calendarIconElement.type != "hidden" ) {
        calendarIconElement.onclick = new Function( "DateField.bindToId( \"" + indexedId + "\" ).openCalendar();" );
    }

    this.htmlElement.id = indexedId;
}

// -------------------------------------------------------------------------
// --------------------------- Accessors & Mutators
// -------------------------------------------------------------------------

/**
 * Returns the disabled state
 * 
 * @return {Boolean} true if the component is disabled
 */
DateField.prototype.isDisabled = function()
{
    return this.getInputFieldElement().type == "hidden";
}

/**
 * Enable/disable the date field
 * 
 * @param {Boolean} val true to disable, false otherwise
 */
DateField.prototype.setDisable = function( val )
{
    if ( val && this.isDisabled() ) {
        return;
    }
    if ( !val && !this.isDisabled() ) {
        return;
    }

    var id = this.htmlElement.id;
    var name = this.getInputFieldElement().name;
    var dateTimeString = this.getDateObject();
    var showTimeFields = this.showTime();
    var endOfDay = this.isEndOfDayField();
    var localeContext = this.getLocaleContext();
    var tooltip = this.getCalendarIconTooltip();

    while ( this.htmlElement.childNodes.length > 0 ) {
        var elt = this.htmlElement.childNodes[0];
        this.htmlElement.removeChild( elt );
    }
    DateField.appendContentToParentSpan( this.htmlElement, id, name, dateTimeString, val, showTimeFields, endOfDay, localeContext, this.getSize(), tooltip );
    this.htmlElement.className = val ? "text" : "";
}

DateField.prototype.getDateObject = function()
{
    if(this.getInputFieldElement()) {
        return this.getInputFieldElement().value.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    } else {
        return ;
    }
}

// -------------------------------------------------------------------------
// --------------------------- Intrinsic & Extended Events Binding
// -------------------------------------------------------------------------

DateField.bindHTMLEvents = function( elt )
{
    elt.onkeydown = new Function( "e", "if( !e ) e= window.event; DateField.bindToElt( this ).handleKeyDown( e );" );

}

DateField.addExtEvents = function( extEventsProcessor )
{
    extEventsProcessor.addEvent( "onFocus" );
}

DateField.calendarIconURL = contextPath + "/com/sap/me/system/common/client/images/icon_calendar.gif"
DateField.getCalendarIconURL = function()
{
        return DateField.calendarIconURL;
}

DateField.prototype.setCalendarIconURL = function( url )
{
    this.htmlElement.calendarIconURL = url;
}

//Fires when the user presses a keyboard key.  The event contains information about the key (not the character) pressed.
DateField.prototype.handleKeyDown = function( browserEvent )
{
    var keybdEvent = new BaseEvent( browserEvent );
    keybdEvent.value = this.htmlElement.value;
    keybdEvent.character = String.fromCharCode( keybdEvent.getKeyCode() );

        if ( keybdEvent.getKeyCode() == 13 || keybdEvent.getKeyCode() == 120)
        {
            if( this.isLoggingEnabled() )
                PageHelper.log( this, "Enter key pressed, calendar opened", browserEvent, "handleKeyDown" );
            this.getCalendarIconElement().click();
            keybdEvent.cancelBubble();
            keybdEvent.cancelEvent();
        }
        else {
            this.publishEvent( "onKeyDown", keybdEvent );
        }
}

/*
*  Opens the Calendar window for choosing a date.
*/
DateField.prototype.openCalendar = function()
{
    var sx = 420;
    var sy = 200;
    var browseWindowX = ( window.screen.availWidth - sx ) / 2;
    var browseWindowY = ( window.screen.availHeight - sy ) / 2;
    window.open( "about:blank", "_calendar", "height=" + sy + ",width=" + sx + ",left=" + browseWindowX + ",top=" + browseWindowY + ",status=no,help=no,toolbar=no,menubar=no,location=no,resizable=no,dependent=yes" );
    try {
            var request = new PostRequest();
            request.addParam( "DATE", this.getInputFieldElement().value );
            request.addParam( "SHOW_TIME", this.showTime().toString() );
            request.addParam( "END_OF_DAY", this.isEndOfDayField().toString() );
            request.addParam( "INPUT_FIELD", this.htmlElement.id + "_INPUT" );
            request.addParam( "LOCALE_CONTEXT", this.getLocaleContext() );
            request.setURL(contextPath + "/com/sap/me/system/common/client/Calendar.jsp" );

            request.submitToWindowOrFrame( "_calendar" );
    }
    catch ( e )
    {
        alert( "Exception: " + e.message + "\n" + e.stack );
    }
}


/*
* Sets the selected date on this date field.
*/
DateField.prototype.setDateObject = function (date)
{
    if(this.htmlElement && this.htmlElement.log)
        PageHelper.logMsg( "Setting date object=" + date );
    var dateTimeField = document.getElementById( this.htmlElement.id + "_INPUT" );
    dateTimeField.value = date;
    var disabled = dateTimeField.isDisabled;
    if ( disabled ) {
        var textSpan = document.getElementById( this.htmlElement.id + "_DATE_TIME_TEXT" );
        textSpan.innerHTML = date;
    }

    this.registerFieldChange();
}
/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: DefaultForm.js/main/10$"

function DefaultForm( id )
{
    this.htmlElement = PageHelper.getElementByIdOrName( id );
    if (this.htmlElement) {
        this.htmlElement.commandElt = PageHelper.getElementByIdOrName( "USER_CMD" );
    }

    this.selectedTabField = null;
}
DefaultForm.prototype = new BaseComponent();
DefaultForm.prototype.constructor = DefaultForm;

DefaultForm.bindToId = function( id )
{
    return new DefaultForm( id );
}

/*
 * handleSubmit( browserEvent)
 * ---------------------------
 * This handler is called when the form is being submitted.  It published the
 * event 'onSubmit'.
 *
 */
DefaultForm.prototype.handleSubmit = function( browserEvent )
{
    var event = new BaseEvent( browserEvent );
    if( this.htmlElement.commandElt )
        event.userCommand = this.htmlElement.commandElt.value;

    this.publishEvent( "onSubmit", event );
}

/*
 * setCommand( id )
 * ----------------
 * Sets the user command on the form.
 *
 */
DefaultForm.prototype.setCommand = function( commandName )
{
    this.htmlElement.commandElt.value = commandName;
}

DefaultForm.prototype.setAction = function( action )
{
    this.htmlElement.action = action;
}

DefaultForm.prototype.getAction = function()
{
    return this.htmlElement.action;
}

DefaultForm.prototype.setTarget = function( target )
{
    this.htmlElement.target = target;
}

DefaultForm.prototype.getTarget = function()
{
    return this.htmlElement.target;
}

DefaultForm.prototype.setKeyModified = function()
{
    var elt = document.getElementById( "_FORM_KEY_MODIFIED" );
    if( !elt )
    {
        this.addHiddenField( "_FORM_KEY_MODIFIED", "true", "_FORM_KEY_MODIFIED" );
    }
}

DefaultForm.prototype.setNonKeyModified = function()
{
    var elt = document.getElementById( "_FORM_NON_KEY_MODIFIED" );
    if( !elt )
    {
        this.addHiddenField( "_FORM_NON_KEY_MODIFIED", "true", "_FORM_NON_KEY_MODIFIED" );
    }
}

DefaultForm.prototype.isKeyModified = function()
{
    var elt = document.getElementById( "_FORM_KEY_MODIFIED" );
    if( elt )
        return true;
    return false;
}

DefaultForm.prototype.isNonKeyModified = function()
{
    var elt = document.getElementById( "_FORM_NON_KEY_MODIFIED" );
    if( elt )
        return true;
    return false;
}

/*
 * getLastCommand()
 * ----------------
 * Returns the name of the most recently executed command.
 *
 */
DefaultForm.prototype.getLastCommand = function()
{
    return this.htmlElement.commandElt.value;
}

/*
 * submit()
 * --------
 * Submits the form and publishes the submit event
 *
 */
DefaultForm.prototype.submit = function()
{
    if( !DefaultForm.submitting )
    {
        DefaultForm.submitting = true;
        var event = new BaseEvent();
        this.publishEvent( "onSubmit", event ) ;
        this.htmlElement.submit();
    }
}

DefaultForm.prototype.addHiddenField = function( name, value, id )
{
    var hiddenElt = BaseComponent.createHiddenField( name, value, id );
    this.htmlElement.appendChild( hiddenElt );
}

DefaultForm.addExtEvents = function( extEventsProcessor )
{
    extEventsProcessor.addEvent( "onSubmit" );
}
/* (c) Copyright 2008 SAP AG. All rights reserved. */

function DomainRelax()
{
}

/*
 * SAP UR Domain Relaxation (Copy of ur_relax from Lightspeed domainrelax.js)
 *
 * Usage: DomainRelax.relax([integrated[, standalone[, maxrelax]]])
 *
 * Parameters:
 *   integrated: domain relaxation used, when application is started inside of
 *               an iframe, a frameset or a popup window
 *   standalone: domain relaxation used, when application runs standalone
 *   maxrelax:   maximal relaxation, for "auto" and "maximal"
 *
 * Returns: true, if relaxation was successful
 *          false, if an error occured, while doing relaxation
 *
 * Possible values for integrated/standalone:
 *   "none"    : No domain relaxation will be done
 *   "auto"    : Domain relaxation will automatically adapt to the parent window.
 *               If no matching relaxation can be found, domain relaxation is
 *               "maximal". When running standalone this defaults to "minimal".
 *   "minimal" : Only the first part (hostname) of the domain will be removed
 *   "maximal" : Remove as much as possible, without relaxing to TLD
 *
 * Possible value for maxrelax:
 *   Integer, that determines the number of domain parts, that have to be kept.
 *   E.g. 2 means "sap.com", 3 means "sub.sap.com"
 *
 * Browser support:
 *   - Win 2000/XP IE6
 *   - Win/Mac/Linux Firefox 1.0.x and 1.5
 *
 * There is a bug in Internet Explorer, that causes domain relaxation
 * to fail intermittently, when the domain, where content is loaded from is
 * the same as the relaxed domain of the parent
 * (e.g. relaxed to wdf.sap.corp, iframe url http://wdf.sap.corp/....)
 */

DomainRelax.relax = function(integrated, standalone, maxrelax) {
  var hostname = location.hostname,
      nameparts = hostname.split("."),
      partslength = nameparts.length,
      reference = "parent",
      method;

  // if hostname is an ip address don't try to relax
  if (/^(\d|\.)+$/.test(hostname)) return true;

  // if hostname has no domain part don't relax
  if (partslength == 1) return true;

  // check and set defaults for parameters
  if (standalone == null) standalone = "minimal";
  if (integrated == null) integrated = "auto";
  if (maxrelax == null) maxrelax = 2;

  // enhance maxrelax in case hostname ends with dot
  if (nameparts[partslength - 1] == "") maxrelax += 1;

  // check if already reached maxrelax
  if (partslength <= maxrelax) return true;

  // determine method
  if (standalone == "auto") standalone = "minimal";
  if (window[reference] == window) reference = "opener";
  if (window[reference] == null) method = standalone;
  else method = integrated;

  // apply method
  switch (method) {

    case "none": // no domain relaxing
      return true;
      break;

    case "auto": // try until correct one is found or maximal relaxation reached
      try {
        if (window[reference].location.href) return true;
      }
      catch (e) {};
      var testdomain;
      for (var i = 0; i <= partslength - maxrelax; i++) {
        testdomain = nameparts.slice(i).join(".");
        try {
          document.domain = testdomain;
          if (window[reference].location.href) return true;
        }
        catch (e) {};
      }
      return false;
      break;

    case "minimal": // only remove first (hostname) part of the domain
      try {
        document.domain = nameparts.slice(1).join(".");
        return true;
      }
      catch (e) {
        return false;
      }
      break;

    case "maximal": // relax as maximal possible/allowed
      try {
        document.domain = nameparts.slice(partslength - maxrelax).join(".");
        return true;
      }
      catch (e) {
        return false;
      }
      break;

    default:
      alert("Unknown relaxation method: " + method);
  }

  return false;
}
/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: /main/3$"


function ExtEventsProcessor()
{
    this.eventListeners = new Object();
}
ExtEventsProcessor.prototype.constructor = ExtEventsProcessor;

/*
 */
ExtEventsProcessor.prototype.addEvent = function( eventName )
{
    this.eventListeners[ eventName ] = new Array();
}

/*
 * publishEvent( eventName, eventObject )
 * --------------------------------------
 * Subclasses of ExtEventsProcessor should call publishEvent() whenever a supported
 * event occurs on the object.  This could be a JavaScript event, such as
 * 'onmouseover', or a user-defined event, such as 'SFC_Changed'.  This method
 * will notify all listeners of the event.
 *
 * The parameter 'eventObject' specifies an event object to be propagated to
 * the listener.  This object should contain any object-specific information
 * that needs to be propagated to the listener.
 *
 * The event object can be any user-defined type, but it is recommended in most
 * cases that it be a subclass of BaseEvent.  The framework will only add
 * information about the client's state (mouse position, keys pressed, etc.)
 * to subclasses of the BaseEvent object.
 *
 */
ExtEventsProcessor.prototype.publishEvent = function( eventName, eventObject )
{
    listeners = this.eventListeners[ eventName ];
    if ( listeners != null )
    {
        for ( var listener in listeners )
        {
            var listenerObject = listeners[ listener ];
            listenerObject.notify( eventObject );
        }
    }
}

/*
 * addEventListener( eventName, objectOrFunction, methodName )
 * -----------------------------------------------------------
 * Adds a listener to this object.  'eventName' specifies the name of the event
 * the caller wants to listen for.  'objectOrFunction' can specify either a
 * subclass of BaseComponent, or a JavaScript function.  If 'objectOrFunction'
 * is a subclass of BaseComponent, then 'methodName' specifies the name of the
 * method to call on the object.  If ommitted, 'methodName' defaults to 'notify'.
 *
 */
ExtEventsProcessor.prototype.addEventListener = function( eventName, objectOrFunction, methodName )
{
    var listeners = this.eventListeners[ eventName ];
    var listener = null;

    if ( objectOrFunction instanceof BaseComponent )
    {
        if ( methodName == null )
        {
            listener = new Listener( objectOrFunction, "notify" );
        }
        else
        {
            listener = new Listener( objectOrFunction, methodName );
        }

        listeners[ objectOrFunction.id ] = listener;
    }
    else
    {
        listener = new Listener( objectOrFunction );
        listeners[ PageHelper.getFunctionName( objectOrFunction ) ] = listener;
    }
}
/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: FieldMonitor.js/main/6$"

function FieldMonitor()
{
    this.changedKeyFields = new Object();
    this.changedNonKeyFields = new Object();
    this.keyFieldChanged = false;
    this.nonKeyFieldChanged = false;
}
FieldMonitor.prototype.constructor = FieldMonitor;

FieldMonitor.prototype.registerKeyFieldChange = function( id )
{
    this.changedKeyFields[id] = id;
    this.keyFieldChanged = true;

    var form = DefaultForm.bindToId( document.forms[0].id );
    form.setKeyModified();        
}

FieldMonitor.prototype.registerNonKeyFieldChange = function( id )
{
    this.changedNonKeyFields[id] = id;
    this.nonKeyFieldChanged = true;

    var form = DefaultForm.bindToId( document.forms[0].id );
    form.setNonKeyModified();    
}

FieldMonitor.prototype.isKeyFieldChanged = function()
{
    var form = DefaultForm.bindToId( document.forms[0].id );
    if( form.isKeyModified() )
        this.keyFieldChanged = true;
    return this.keyFieldChanged;
}

FieldMonitor.prototype.isNonKeyFieldChanged = function()
{
    var form = DefaultForm.bindToId( document.forms[0].id );
    if( form.isNonKeyModified() )
        this.nonKeyFieldChanged = true;    
    return this.nonKeyFieldChanged;
}

// If id is specified, return true if that field has changed.  Otherwise, return
// true if any field has changed.
FieldMonitor.prototype.fieldChanged = function( id )
{
    if( id )
        return ( this.changedKeyFields[id] || this.changedNonKeyFields[id] );
    else
        return (this.isKeyFieldChanged() || this.isNonKeyFieldChanged() );
}
/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: /main/1$"

function Image( elt )
{
    // Initialize the base component
	if(!elt){
		elt = document.createElement("img");
	}
    this.initializeBaseComponent( elt, "Image" );
}
Image.prototype = new BaseComponent();
Image.prototype.constructor = Image;

Image.create = function( id, src )
{
    var elt = document.createElement( "img" );
    if( id ) elt.id = id;
    if( src ) elt.src = src;
    return new Image( elt );
}

Image.prototype.getSource = function()
{
    return this.htmlElement.src;
}

Image.bindHTMLEvents = function( elt )
{
    // Nothing to handle for now
}
/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: Link.js/main/6$"

function Link( id, elt )
{
    if( elt )
        this.htmlElement = elt;
    else
        this.htmlElement = document.getElementById( id );

    this.initializeBaseComponent( this.htmlElement, "Link" );
}
Link.prototype = new BaseComponent();
Link.prototype.constructor = Link;

Link.create = function( id, href, clickHandler )
{
    var elt = document.createElement( "a" );
    if( id ) elt.id = id;
    if( href ) elt.href = href;
    if( clickHandler )
    {
        if( ')' != clickHandler.charAt( clickHandler.length-1 ) )                    
            clickHandler += "(this)";                
        elt.onclick = new Function( "e", "if(!e)e=window.event;var be=new BaseEvent(e);be.cancelEvent();" + clickHandler + ";");
    }
    return new Link( null, elt );
}

Link.bindToElt = function( elt )
{
    return new Link( null, elt );
}

Link.bindToId = function( id )
{
    return new Link( id );
}

Link.prototype.setImage = function( imageElt )
{
    this.htmlElement.appendChild( imageElt );
    this.htmlElement.imageElt = imageElt;
}

Link.prototype.addToTableCell = function( tableCellElt, rowId )
{
    this.htmlElement.id = this.getIndexedId( rowId );
    if( this.htmlElement.imageElt )
        this.htmlElement.imageElt.id = this.getIndexedId( rowId, this.htmlElement.imageElt.id );
    tableCellElt.appendChild( this.htmlElement );
}
/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: /main/2$"

/*
 * List
 * ----
 * This object is a simple collection object that holds lists of items.  It
 * offers several convenience methods that make dealing with lists easier than
 * the JavaScript Array object.
 *
 */

/*
 * Constructor
 * -----------
 * The constructor can optionally take an array (Array object) to initialize
 * itself with.
 *
 */

function List( array )
{
    if( array )
        this.array = array;
    else
        this.array = new Array();
}

/*
 * add( object, index )
 * --------------------
 * Adds an element to this list
 *
 * object - Required.  The object to add
 * index  - Optional.  The index at which this object should be added
 *
 */
List.prototype.add = function( object, index )
{
    if( ( index == null ) || ( index >= this.array.length ) )
        this.array[ this.array.length ] = object;
    else if( index > 0 )
    {
        var sliceFront = this.array.slice( 0, index );
        var sliceEnd = this.array.slice( index );
        sliceFront.push( object );
        this.array = sliceFront.concat( sliceEnd );
    }
    else // add to front
        this.array.unshift( object );
}

/*
 * clear()
 * -------
 * Removes all elements from this list.
 *
 */
List.prototype.clear = function()
{
    this.array = null;
    this.array = new Array();
}

/*
 * contains( object )
 * ------------------
 * Returns true if this list contains the specified object.  Otherwise, returns
 * false.
 *
 */
List.prototype.contains = function( object )
{
    for ( var i = 0; i < this.array.length; i++ )
        if ( this.array[ i ] == object ) return true;
    return false;
}

/*
 * get( index )
 * ------------
 * Returns the value in this list at the specified index
 *
 */
List.prototype.get = function( index )
{
    if ( index >= 0 && index < this.array.length )
        return this.array[ index ];
    else
        return null;
}

/*
 * getSize()
 * ---------
 * Returns the size (length) of this list
 *
 */
List.prototype.getSize = function()
{
    return this.array.length;
}

/*
 * remove( object )
 * ----------------
 * Removes 'object' from this list
 *
 */
List.prototype.remove = function( object )
{
    var newArray = new Array();

    for ( var i = 0; i < this.array.length; i++ )
    {
        if ( this.array[ i ] != object )
        {
            newArray.push( this.array[ i ] );
        }
    }
    this.array = newArray;
}

List.prototype.removeFront = function()
{
    return this.array.shift();
}

/*
 * replaceAt( index, object )
 * --------------------------
 * Replaces the object at index 'index' with the object specified by 'object'.
 *
 */
List.prototype.replaceAt = function( index, object )
{
    if ( index >= 0 && index < this.array.length )
        this.array[ index ] = object;
}

List.prototype.sort = function()
{
    var compFun = function( a, b )
    {
        if( isNaN( a ) || isNaN( b ) )
            return 0;
        return a - b;
    }

    this.array = this.array.sort( compFun );
}

List.prototype.toString = function()
{
    if (!this.array) {
        return "";
    }
    return this.array.toString();
}

/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: /main/3$"

/*
 * Listener
 * --------
 * This object keeps track of an event listener and provides methods to notify the
 * listener of an event.
 *
 */

/*
 * Constructor( objectOrFunction, methodName )
 * -------------------------------------------
 * Initializes a reference to the object or function specified in the
 * 'objectOrFunction' parameter.  If 'objectOrFunction' specifies an object,
 * it must be a subclass of BaseObject.  For object references, the parameter
 * 'methodName' specifies the name of the method to call on the object.  If
 * 'methodName' is ommitted, it defaults to 'notify'.
 *
 */
function Listener( objectOrFunction, methodName )
{
    if ( objectOrFunction instanceof BaseComponent )
    {
        this.reference = objectOrFunction;
        this.type = "object";

        if ( methodName != null )
        {
            this.methodName = methodName;
        }
        else
        {
            this.methodName = "notify";
        }
    }
    else
    {
        this.reference = objectOrFunction;
        this.referenceType = "function";
        this.methodName = null;
    }
}

/*
 * notify( eventObject )
 * ---------------------
 * Notifies the listener this object is associated with of an event.
 *
 */
Listener.prototype.notify = function( eventObject )
{
    if ( this.referenceType == "function" )
    {
        this.reference( eventObject );
    }
    else
    {
        var method = this.reference[ this.methodName ];
        method.apply( this.reference, new Array( eventObject ) );
    }
}
/* (c) Copyright 2008 SAP AG. All rights reserved. */

/*
 * Map
 * ---
 * This object implements a simple map, similar to Java's HashCustomMap.
 *
 */

function CustomMap()
{
    this.mapKeys = new Array();
    this.mapValues = new Array();
    this.numKeys = 0;
}

CustomMap.prototype.clear = function()
{
    this.mapKeys = new Array();
    this.mapValues = new Array();
    this.numKeys = 0;
}

CustomMap.prototype.containsKey = function( key )
{
    for ( var index = 0; index < this.numKeys; index++ )
    {
        if ( this.mapKeys[ index ] == key ) return true;
    }
    return false;
}

CustomMap.prototype.containsValue = function( value )
{
    for ( var index = 0; index < this.numKeys; index++ )
    {
        if ( this.mapValues[ index ] == value ) return true;
    }
    return false;
}

CustomMap.prototype.entrySet = function()
{
    var retSet = new Array();

    for ( var index = 0; index < this.numKeys; index++ )
    {
        retSet[ this.mapKeys[ index ] ] = this.mapValues[ index ];
    }
    return retSet;
}

CustomMap.prototype.equals = function( other )
{
    if ( this.numKeys == other.numKeys )
    {
        var otherSet = other.entrySet();

        for ( var index = 0; index < this.numKeys; index++ )
        {
            if ( otherSet[ this.mapKeys[ index ] ] != this.mapValues[ index ] ) return false;
        }
        return true;
    }
    else
    {
        return false;
    }
}

CustomMap.prototype.get = function( key )
{
    for ( var index = 0; index < this.numKeys; index++ )
    {
        if ( this.mapKeys[ index ] == key ) return this.mapValues[ index ];
    }
    return null;
}

CustomMap.prototype.isEmpty = function()
{
    return ( this.numKeys == 0 );
}

CustomMap.prototype.keySet = function()
{
    var keys = new Array();
    for ( var index = 0; index < this.numKeys; index++ )
    {
        keys[ index ] = this.mapKeys[ index ];
    }
    return keys;
}

CustomMap.prototype.put = function( key, value )
{
    // First, see if the key is already in this map.  If so, then we need to
    // simply replace the value
    var index = 0;
    while ( ( index < this.numKeys ) && ( this.mapKeys[ index ] != key ) )
    {
        index++;
    }
    this.mapKeys[ index ] = key;
    this.mapValues[ index ] = value;
    if ( index == this.numKeys )
    {
        this.numKeys++;
    }
}

CustomMap.prototype.putAll = function( other )
{
    for ( var index = 0; index < other.numKeys; index++ )
    {
        this.put( other.keys[ index ], other.values[ index ] );
    }
}

CustomMap.prototype.remove = function( key )
{
    // First, find the key
    var indexToRemove = -1;
    var removedObj = null;
    for ( var index = 0; ( index < this.numKeys ) && ( indexToRemove == -1 ); index++ )
    {
        if ( this.mapKeys[ index ] == key ) indexToRemove = index;
    }

    if ( indexToRemove > -1 )
    {
        removedObj = this.mapValues[ index ];
        for ( var index = indexToRemove; index < ( this.numKeys - 1 ); index++ )
        {
            this.mapKeys[ index ] = this.mapKeys[ index + 1 ];
            this.mapValues[ index ] = this.mapValues[ index + 1 ];
        }
        this.numKeys--;
    }
    return removedObj;
}

CustomMap.prototype.size = function()
{
    return this.numKeys;
}

CustomMap.prototype.values = function()
{
    var valueSet = new Array();
    for ( var index = 0; index < this.numKeys; index++ )
    {
        valueSet[ index ] = this.mapValues[ index ];
    }
    return valueSet;
}
/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: PageHelper.js/main/73$"

PageHelper.logBrowse = false;
PageHelper.messages = new Object();
PageHelper.clientSideWindowClose = true;

function PageHelper()
{
}

PageHelper.checkBrowserVersion = function()
{
    // support for IE > 6 and chrome, safari and firefox
    var oBrowserInfo = XBrowserHelper.getBrowserInformation();
    if (oBrowserInfo && oBrowserInfo.name) {
        var sBrowserName = oBrowserInfo.name.toLowerCase();
        if (sBrowserName === 'msie') {
            if (oBrowserInfo.version >= 6.0 && oBrowserInfo.version <= 11.0) {
                return;
            }
        } else if (sBrowserName === 'chrome' || sBrowserName === 'safari' || sBrowserName === 'firefox' || sBrowserName === 'edge') {
           return;
        }
    }
    location.href = contextPath + "/unsupported";
}

PageHelper.getEventSourceElement = function( e )
{
    if( !e )
        e = window.event;
    var be = new BaseEvent( e );
    return be.getSourceElement();
}

/**
 * Get the Text component for the given Id and table index.
 * @param {String} id The component id attribute value
 * @param [index] The table row index
 * @return {Text} The Text component, or null if no component was found
 */
PageHelper.getText = function( id, index )
{
    if ( index != null )
        id = id + "[" + index + "]";
    var elt = document.getElementById(id);
    if(elt)
    {
        return Text.bindToId( id );
    }
    else
    {
        return null;
    }
}

/**
 * Get the TextField component for the given Id and table index.
 * @param {String} id The component id attribute value
 * @param [index] The table row index
 * @return {TextField} The Text component, or null if no component was found
 */
PageHelper.getTextField = function( id, index )
{
    if ( index != null )
        id = id + "[" + index + "]";
    var elt = document.getElementById(id);
    if(elt)
    {
        return TextField.bindToId( id );
    }
    else
    {
        return null;
    }
}

/**
 * Get the TextArea component for the given Id and table index.
 * @param {String} id The component id attribute value
 * @param [index] The table row index
 * @return {TextArea} The TextArea component, or null if no component was found
 */
PageHelper.getTextArea = function( id, index )
{
    if ( index != null )
        id = id + "[" + index + "]";
    var elt = document.getElementById(id);
    if(elt)
    {
        return TextArea.bindToId( id );
    }
    else
    {
        return null;
    }
}

/**
 * Get the DateField component for the given Id and table index.
 * @param {String} id The component id attribute value
 * @param [index] The table row index
 * @return {DateField} The DateField component, or null if no component was found
 */
PageHelper.getDateField = function( id, index )
{
    if ( index != null )
        id = id + "[" + index + "]";
    var elt = document.getElementById(id);
    if(elt)
    {
        var dateField = DateField.bindToId( id );
        var htmlTextElt = document.getElementById(id);
        var iconElt = document.getElementById( id + "_CALENDAR_ICON" );
        DateField.activateDateField(htmlTextElt, null, iconElt );
        return dateField;
    }
    else
    {
        return null;
    }
}

/**
 * Get the Select component for the given Id and table index.
 * @param {String} id The component id attribute value
 * @param [index] The table row index
 * @return {Select} The Select component, or null if no component was found
 */
PageHelper.getSelect = function( id, index )
{
    if ( index != null )
        id = id + "[" + index + "]";
    var elt = document.getElementById(id);
    if(elt)
    {
        return Select.bindToId( id );
    }
    else
    {
        return null;
    }
}

/**
 * Get the CheckBox component for the given Id and table index.
 * @param {String} id The component id attribute value
 * @param [index] The table row index
 * @return {CheckBox} The CheckBox component, or null if no component was found
 */
PageHelper.getCheckBox = function( id, index )
{
    if ( index != null )
        id = id + "[" + index + "]";
    var elt = document.getElementById(id);
    if(elt)
    {
        return CheckBox.bindToId( id );
    }
    else
    {
        return null;
    }
}

/**
 * Get the Table component for the given Id.
 * @param {String} id The component id attribute value
 * @return {Table} The Table component
 */
PageHelper.getTable = function( id )
{
    return Table.bindToId( id );
}

/**
 * Gets the TableRow component for the given HTML table row element.  This is typically used in event handlers that respond to table
 * events, like a table row click.  The event contains a reference to the HTML row element, and so that can be used to access
 * the TableRow component.
 * @param {HTMLElement} The HTML table row element
 * @return {TableRow} The TableRow component
 */
PageHelper.getTableRow = function( elt )
{
    return TableRow.bindToElt( elt );
}

/**
 * Get the Form component for the given Id.
 * @param {String} id The component id attribute value
 * @return {DefaultForm} The Form component
 */
PageHelper.getForm = function( id )
{
    return DefaultForm.bindToId( id );
}

/**
 * Get the AddRemove component for the given Id.
 * @param {String} id The component id attribute value
 * @return {AddRemove} The AddRemove component
 */
PageHelper.getAddRemove = function( id )
{
    return AddRemove.bindToId( id );
}

/**
 * Get the Link component for the given Id and table index.
 * @param {String} id The component id attribute value
 * @param [index] The table row index
 * @return {Link} The Link component, or null if no component was found
 */
PageHelper.getLink = function( id, index )
{
    if ( index != null )
        id = id + "[" + index + "]";
    var elt = document.getElementById(id);
    if(elt)
    {
        return Link.bindToId( id );
    }
    else
    {
        return null;
    }
}


/**
 * Bind an event listener to a TextField component having the given fieldId.
 * <h4>Events</h4>
 * All TextField events support the browserEvent property for referencing the raw browser event.
 * <table border="1" cellpadding="1" cellspacing="0">
 * <thead>
 * <tr><th>Event</th><th>Description</th><th>Extra Properties</th></tr>
 * </thead>
 * <tbody>
 * <tr><td>onFocus</td><td>Fired when the text field receives focus</td><td>None</td></tr>
 * <tr><td>onFocusLost</td><td>Fired when the text field looses focus</td><td>None</td></tr>
 * <tr><td>onKeyDown</td><td>Fired when a keyboard key is pressed down (but before it is released)</td><td>{String} e.value<br>{String} e.character</td></tr>
 * <tr><td>onValueChange</td><td>Fired when the text field value is changed</td><td>{String} e.value<br>{TableRow} e.row (only when in a table)</td></tr>
 * <tr><td>onTabOut</td><td>Fired when the user tabs out of the field using the Tab key</td><td>{String} e.value<br>{String} e.character</td></tr>
 * <tr><td>onKeyPress</td><td>Fired when a keyboard key is pressed down and released</td><td>{String} e.value<br>{String} e.character</td></tr>
 * </tbody>
 * </table>
 * @param {String} fieldId The UI component id attribute value
 * @param {String} eventName The name of the event to listen for
 * @param {Function} objectOrFunction A reference to a JSP JavaScript function that will handle the event
 * @param methodName NOT USED
 * @see TextField for a list of supported events
 */
PageHelper.addTextFieldEventListener = function( fieldId, eventName, objectOrFunction, methodName )
{
    PageHelper.addEventListenerImpl( TextField, fieldId, eventName, objectOrFunction, methodName );
}

/**
 * Bind an event listener to a Select component having the given fieldId.
 * <h4>Events</h4>
 * All Select events support the browserEvent property for referencing the raw browser event.
 * <table border="1" cellpadding="1" cellspacing="0">
 * <thead>
 * <tr><th>Event</th><th>Description</th><th>Extra Properties</th></tr>
 * </thead>
 * <tbody>
 * <tr><td>onFocus</td><td>Fired when the list receives focus</td><td>None</td></tr>
 * <tr><td>onFocusLost</td><td>Fired when the list looses focus</td><td>None</td></tr>
 * <tr><td>onSelectionChange</td><td>Fired when a new option is selected</td><td>{String} e.selectedValue<br>{TableRow} e.row (only when in a table)</td></tr>
 * </tbody>
 * </table>
 * @param {String} fieldId The UI component id attribute value
 * @param {String} eventName The name of the event to listen for (see Select for a list of supported events)
 * @param {Function} objectOrFunction A reference to a JSP JavaScript function that will handle the event
 * @param methodName NOT USED
 */
PageHelper.addSelectEventListener = function( fieldId, eventName, objectOrFunction, methodName )
{
    PageHelper.addEventListenerImpl( Select, fieldId, eventName, objectOrFunction, methodName );
}

/**
 * Bind an event listener to a CheckBox component having the given fieldId.
 * <h4>Events</h4>
 * All CheckBox events support the browserEvent property for referencing the raw browser event.
 * <table border="1" cellpadding="1" cellspacing="0">
 * <thead>
 * <tr><th>Event</th><th>Description</th><th>Extra Properties</th></tr>
 * </thead>
 * <tbody>
 * <tr><td>onCheck</td><td>Fired when the check box is checked</td><td>None</td></tr>
 * <tr><td>onUncheck</td><td>Fired when the check box is unchecked</td><td>None</td></tr>
 * </tbody>
 * </table>
 * @param {String} fieldId The UI component id attribute value
 * @param {String} eventName The name of the event to listen for (see CheckBox for a list of supported events)
 * @param {Function} objectOrFunction A reference to a JSP JavaScript function that will handle the event
 * @param methodName NOT USED
 */
PageHelper.addCheckBoxEventListener = function( fieldId, eventName, objectOrFunction, methodName )
{
    PageHelper.addEventListenerImpl( CheckBox, fieldId, eventName, objectOrFunction, methodName );
}

/**
 * Bind an event listener to all RadioButton components associated with the specified radio button group.
 * Radio buttons sharing the same name are automatically associated with the same group.
 * <h4>Events</h4>
 * All RadioButton events support the browserEvent property for referencing the raw browser event.
 * <table border="1" cellpadding="1" cellspacing="0">
 * <thead>
 * <tr><th>Event</th><th>Description</th><th>Extra Properties</th></tr>
 * </thead>
 * <tbody>
 * <tr><td>onSelect</td><td>Fired when any button in the group is selected</td><td>None</td></tr>
 * <tr><td>onDeselect</td><td>Fired when any button in the group is deselected</td><td>None</td></tr>
 * </tbody>
 * </table>
 * @param {String} groupName The shared name of each radio button in the group
 * @param {String} eventName The name of the event to listen for (see RadioButton for a list of supported events)
 * @param {Function} objectOrFunction A reference to a JSP JavaScript function that will handle the event
 * @param methodName NOT USED
 */
PageHelper.addRadioGroupEventListener = function( groupName, eventName, objectOrFunction, methodName )
{
    var groupElts = document.getElementsByName( groupName );
    var radioElt = null;
    for( var i=0; i < groupElts.length; i++ )
    {
        radioElt = groupElts.item( i );
        PageHelper.addRadioButtonEventListener( radioElt.id, eventName, objectOrFunction, methodName );
    }
}

/**
 * Bind an event listener to a RadioButton component having the given fieldId.
 * <h4>Events</h4>
 * All RadioButton events support the browserEvent property for referencing the raw browser event.
 * <table border="1" cellpadding="1" cellspacing="0">
 * <thead>
 * <tr><th>Event</th><th>Description</th><th>Extra Properties</th></tr>
 * </thead>
 * <tbody>
 * <tr><td>onSelect</td><td>Fired when the button is selected</td><td>None</td></tr>
 * <tr><td>onDeselect</td><td>Fired when the button is deselected</td><td>None</td></tr>
 * </tbody>
 * </table>
 * @param {String} fieldId The UI component id attribute value
 * @param {String} eventName The name of the event to listen for (see RadioButton for a list of supported events)
 * @param {Function} objectOrFunction A reference to a JSP JavaScript function that will handle the event
 * @param methodName NOT USED
 */
PageHelper.addRadioButtonEventListener = function( fieldId, eventName, objectOrFunction, methodName )
{
    PageHelper.addEventListenerImpl( RadioButton, fieldId, eventName, objectOrFunction, methodName );
}

/**
 * Bind an event listener to a Table component having the given fieldId.
 * <h4>Events</h4>
 * All Table events support the browserEvent property for referencing the raw browser event.
 * <table border="1" cellpadding="1" cellspacing="0">
 * <thead>
 * <tr><th>Event</th><th>Description</th><th>Extra Properties</th></tr>
 * </thead>
 * <tbody>
 * <tr><td>onRowClick</td><td>Fired when a row is selected</td><td>{TableRow} e.tableRow</td></tr>
 * <tr><td>onRadioClick</td><td>Fired when a radio button is selected</td><td>{RadioButton} e.srcObject</td></tr>
 * </tbody>
 * </table>
 * @param {String} fieldId The UI component id attribute value
 * @param {String} eventName The name of the event to listen for (see Table for a list of supported events)
 * @param {Function} objectOrFunction A reference to a JSP JavaScript function that will handle the event
 * @param methodName NOT USED
 */
PageHelper.addTableEventListener = function( fieldId, eventName, objectOrFunction, methodName )
{
    PageHelper.addEventListenerImpl( Table, fieldId, eventName, objectOrFunction, methodName );
}

/**
 * Bind an event listener to a TextArea component having the given fieldId.
 * <h4>Events</h4>
 * All TextArea events support the browserEvent property for referencing the raw browser event.
 * <table border="1" cellpadding="1" cellspacing="0">
 * <thead>
 * <tr><th>Event</th><th>Description</th><th>Extra Properties</th></tr>
 * </thead>
 * <tbody>
 * <tr><td>onFocus</td><td>Fired when the text area receives focus</td><td>None</td></tr>
 * <tr><td>onFocusLost</td><td>Fired when the text area looses focus</td><td>None</td></tr>
 * <tr><td>onKeyDown</td><td>Fired when a keyboard key is pressed down (but before it is released)</td><td>None</td></tr>
 * <tr><td>onValueChange</td><td>Fired when the text area value is changed</td><td>{String} e.value<br>{TableRow} e.row (only when in a table)</td></tr>
 * <tr><td>onTabOut</td><td>Fired when the user tabs out of the field using the Tab key</td><td>None</td></tr>
 * <tr><td>onKeyPress</td><td>Fired when a keyboard key is pressed down and released</td><td>{String} e.value<br>{String} e.character</td></tr>
 * </tbody>
 * </table>
 * @param {String} fieldId The UI component id attribute value
 * @param {String} eventName The name of the event to listen for (see TextArea for a list of supported events)
 * @param {Function} objectOrFunction A reference to a JSP JavaScript function that will handle the event
 * @param methodName NOT USED
 */
PageHelper.addTextAreaEventListener = function( fieldId, eventName, objectOrFunction, methodName )
{
    PageHelper.addEventListenerImpl( TextArea, fieldId, eventName, objectOrFunction, methodName );
}

/**
 * Bind an event listener to a Form component having the given fieldId.
 * <h4>Events</h4>
 * All DefaultForm events support the browserEvent property for referencing the raw browser event.
 * <table border="1" cellpadding="1" cellspacing="0">
 * <thead>
 * <tr><th>Event</th><th>Description</th><th>Extra Properties</th></tr>
 * </thead>
 * <tbody>
 * <tr><td>onSubmit</td><td>Fired when the form is submitted</td><td>{String} e.userCommand</td></tr>
 * </tbody>
 * </table>
 * @param {String} fieldId The UI component id attribute value
 * @param {String} eventName The name of the event to listen for (see Form for a list of supported events)
 * @param {Function} objectOrFunction A reference to a JSP JavaScript function that will handle the event
 * @param methodName NOT USED
 */
PageHelper.addFormEventListener = function( fieldId, eventName, objectOrFunction, methodName )
{
    PageHelper.addEventListenerImpl( DefaultForm, fieldId, eventName, objectOrFunction, methodName );
}

/**
 * @private
 */
PageHelper.addEventListenerImpl = function( staticObj, fieldId, eventName, objectOrFunction, methodName )
{
    //PageHelper.logMsg( "PageHelper.addEventListenerImpl for id=" + fieldId + " to add event=" + eventName );
    var fieldElt = document.getElementById( fieldId );
    if( fieldElt )
    {
        var eep = null;
        if( fieldElt.extEventsProcessor == null )
        {
            eep = new ExtEventsProcessor();
            fieldElt.extEventsProcessor = eep;
            staticObj.addExtEvents( eep );
        }
        eep = fieldElt.extEventsProcessor;
        eep.addEventListener( eventName, objectOrFunction, methodName );
    }
}

/**
 * @private
 */
PageHelper.doActionMenu = function( menuId, url )
{
    if( !DefaultForm.submitting )
    {
        var menuElt = document.getElementById( menuId );
        var left = menuElt.offsetLeft + menuElt.offsetWidth + 30;
        return window.open( url, "_actionMenu", "resizable,top=300,left=" + left + ",height=250,width=200" );
    }
}

/**
 * @private
 */
PageHelper.doBrowse = function( formId, fieldId, revisionId, browseId, command, selectionModel, custom, tableRowIndex, browseClassName, browseServiceName )
{
	try {
		beforeBrowseOpen(browseId);
	} catch(e){}

    // Validate parameters
    if( !formId || !fieldId )
        return;
    if( !custom )
        custom = false;
    if( !command )
        command = "Browse";
    if( isNaN(tableRowIndex) && !tableRowIndex )
        tableRowIndex = -1;
    PageHelper.addHiddenFormField( formId, "_BROWSE_VALUE", PageHelper.getTextField( fieldId ).getValue() , "_BROWSE_VALUE" );

    //Parse the Browse Id for the browse scenario.
    var browseScenario = null;
    if (browseId != null) {
    var dotIndex = browseId.indexOf(".");
    if(dotIndex > -1)
    {
       var tempBrowseId = browseId;
       browseId = tempBrowseId.substring(0, dotIndex);
       browseScenario = tempBrowseId.substring(dotIndex+1);
    }
    }
    if( !selectionModel )
        selectionModel = "single";

    var childParamList = new ChildParameterList();

    childParamList.addParameter( "_PRIMARY_NAME", PageHelper.getTextField( fieldId ).getName() );
    childParamList.addParameter( "_CUSTOM", (custom + "") );
    childParamList.addParameter( "_TABLE_SELECT_MODEL", selectionModel );
    childParamList.addParameter( "_TABLE_ROW_INDEX", tableRowIndex );
    if( revisionId )
        childParamList.addParameter( "_REVISION_ID", revisionId );
    if( browseId )
        childParamList.addParameter( "_BROWSE_ID", browseId );
    if( browseScenario )
        childParamList.addParameter( "_BROWSE_SCENARIO", browseScenario );
    if( browseClassName )
        childParamList.addParameter( "_BROWSE_CLASSNAME", browseClassName );
    if( browseServiceName )
        childParamList.addParameter( "_BROWSE_SERVICENAME", browseServiceName );

    //If the popupWinName is different from the previous one, we will pop up a new browse, such as when you click the 'browse' button;
    //otherwise it will keep the previous browse, such as when you click the 'search' button. So if the current active element is not 'search' button,
    //we will pop up a new browser.
    var popupWinName = window.name;
    if ((document.activeElement != null) && (document.activeElement.id != 'search_button')) {
        if (((window.event != null) && (window.event.srcElement != null) && (window.event.srcElement.id != 'search_button'))
            || (window.event == null)){
            popupWinName = window.name + "_browse";
        }
    }

    if (window.name != popupWinName) {
        childParamList.addParameter( "_PRIMARY_ID", fieldId );
    } else {
        childParamList.addParameter( "_PRIMARY_ID", window.primaryId );
    }

    PageHelper.doCommand( formId, command, true, true, childParamList.toString(), popupWinName, "BROWSE", "width=800,height=600" );
    PageHelper.removeElement( "_BROWSE_VALUE" );
}

/**
 * Launches the SFC browse screen.  You should use this method for any SFC input text field.  Typically this method
 * is called from a function defined within the JSP.
 *
 * @param {String} formId The component id attribute value for the form
 * @param {String} fieldId The UI component id attribute value of the SFC TextField
 * @param {String} activityURL The relative URL of the calling activity (not including the web context path)
 * @param {Boolean} [singleSelect=false] Flag indicating whether the user will be able to select only a single SFC from the SFC browse screen
 * @param {String} [childParams] Parameters to be included with the SFC browse request
 *
 * @example
 * <div>Custom tag: &lt;coral:textField id="SFC" name="SFC" uppercase="true" browseable="true" browseFunc="doSFCBrowse"/&gt;</div>
 * <div>
 * JavaScript JSP function:<br>
 *        function doSFCBrowse() {
 *             PageHelper.doSFCBrowse( "MAIN", "SFC", "<app:url>/application/setup/PlaceHold</app:url>", false);
 *        }
 * </div>
 *
 * @see ChildParameterList
 */
PageHelper.doSFCBrowse = function( formId, fieldId, activityURL, singleSelect, childParams )
{
    if( !formId || !fieldId || ! activityURL )
        return;
    if( !singleSelect )
        singleSelect = false;
    var fieldValue = PageHelper.getTextField( fieldId ).getValue();
    if ( PageHelper.isMultipleEntitiesIndicator( fieldValue ) )
        fieldValue = "";

    var childParamList = new ChildParameterList();
    childParamList.addParameter( "SFC_FILTER", fieldValue );
    childParamList.addParameter( "SINGLE_SELECT", (singleSelect + "") );
    childParamList.addParameter( "_REQUEST_URI", activityURL );
    var childParamsValue = childParamList.toString();
    if( childParams )
        childParamsValue += childParams.toString( true );
    PageHelper.doCommand( formId, "StartSFCBrowseApp", true, true, childParamsValue, "_sfcbrowse", "SFCBROWSE" );
}

PageHelper.doInventoryBrowse = function( formId, fieldId, activityURL, singleSelect, childParams )
{
    if( !formId || !fieldId || ! activityURL )
        return;
    if( !singleSelect )
        singleSelect = false;
    var fieldValue = PageHelper.getTextField( fieldId ).getValue();
    if ( PageHelper.isMultipleEntitiesIndicator( fieldValue ) )
        fieldValue = "";

    var childParamList = new ChildParameterList();
    childParamList.addParameter( "INVENTORY_FILTER", fieldValue );
    childParamList.addParameter( "SINGLE_SELECT", (singleSelect + "") );
    childParamList.addParameter( "_REQUEST_URI", activityURL );
    var childParamsValue = childParamList.toString();
    if( childParams )
        childParamsValue += childParams.toString( true );
    console.log(formId);
    PageHelper.doCommand( formId, "StartInventoryBrowseApp", true, true, childParamsValue, "_inventorybrowse", "INVENTORYBROWSE" );
}

/**
 * Generic method to execute a server side command in response to some user action.
 *
 * @param {String} formId The component id attribute value for the form
 * @param {String} commandName The name of the command to execute.  This must match the name of a command specified in the Coral configuration
 * for the application.
 * @param {Boolean} [newWindow=false] True if the command should be run in a new browser window
 * @param {Boolean} [branch=false] If true the command will force the creation of a new application state
 * @param {String} [childParams] Additional parameters to be included with the command request
 * @param {String} [windowName] The browser window name used if opening in a new window
 * @param {String} [forcedId] If branching, then the value of forcedId will be used for the application Id.
 * Otherwise an Id is automatically generated.  <b>This parameter should only be used in very limited cases.</b>
 * @param {String} [extWindowParams] Browser window parameters passed to the window.open function. Any parameters you specify here are added the default set.
 * The default set is scrollbars=yes,status=yes,toolbar=no,menubar=no,location=no,resizable=yes,dependent=yes
 */
PageHelper.doCommand = function( formId, commandName, newWindow, branch, childParams, windowName, forcedId, extWindowParams )
{
    // Disable the client side window close handler by default.  All cleanup should be done on the server side if necessary.
    // Setting this flag here is really meant to short circuit the default case, where the window close handler will fire when
    // the application exits outside the framework, such as when the browser window is closed by the user, or window.close() is called.
    PageHelper.clientSideWindowClose = false; // DO NOT REMOVE OR CHANGE

    if( commandName && commandName.length > 0 )
    {
        var form = DefaultForm.bindToId( formId );
        var currentTarget = form.htmlElement.target;
        form.setCommand( commandName );
        if( newWindow )
        {
            var winName = null;
            if( !windowName )
                winName = "_childWindow";
            else
                winName = windowName;

            form.htmlElement.target = winName;
            if( branch )
            {
                PageHelper.addHiddenFormField( formId, "_BRANCH", "", "_BRANCH" );
                if( forcedId )
                    PageHelper.addHiddenFormField( formId, "_FORCED_ID", forcedId, "_FORCED_ID" );
            }

            // Tell the HtmlTag to not write the window.onunload handler.  All windows opened from a
            // parent application are assumed to be in the context of that application, and therefore
            // should not remove potentially stateful services that are in use by the parent.  The only
            // case that this does not handle is if the parent is launching another application that is also
            // a POD plugin and uses a stateful service.
            var omitWinCloseParam = new ChildParameterList();
            omitWinCloseParam.addParameter( "_OMIT_WIN_CLOSE_SCRIPT", "true" );
            if( childParams )
                childParams += omitWinCloseParam.toString( true );
            else
                childParams = omitWinCloseParam.toString();

            //Return the child param 'is browseable'
            //Make the browse button invisible if equals to or above three browse levels
            var isBrowseableParam = new ChildParameterList();
            if(winName && winName.indexOf('_browse') > -1){
                var winNameArray = winName.split('_browse');
                isBrowseableParam.addParameter( "_IS_BROWSEABLE", winNameArray.length <= 3 );
                if( childParams )
                    childParams += isBrowseableParam.toString( true );
                else
                    childParams = isBrowseableParam.toString();

              //Return the child param 'isNewWindowPopup'
                var isNewWindowPopupParam = new ChildParameterList();
                isNewWindowPopupParam.addParameter( "_IS_NEW_WINDOW_POPUP", winName != window.name );
                if( childParams )
                    childParams += isNewWindowPopupParam.toString( true );
                else
                    childParams = isNewWindowPopupParam.toString();
            }
            var windowParams = "scrollbars=yes,status=yes,toolbar=no,menubar=no,location=no,resizable=yes,dependent=yes";
            if( extWindowParams )
                windowParams += "," + extWindowParams;

          //only popup new window via browse in browse situation
            if (winName != window.name) {
                var currentWindow = window.open( "about:blank", winName, windowParams );
                window.onbeforeunload = PageHelper.onLoadHandler;
                PageHelper.linkToParentWindow(currentWindow);
                currentWindow.focus();
            }
        }

        if( childParams )
            PageHelper.addHiddenFormField( formId, "_CHILD_PARAMETERS", childParams, "_CHILD_PARAMETERS" );

        form.submit();

        // Show wait indicator if graphic exists in document and command is being executed in current window
        if (!newWindow && document!=null && document.getElementById("_LOADING_ANIMATION")!=null&&commandName!="BrowseExport") {
            setTimeout(PageHelper.showWaitIndicator, 2000);
        }

        if( newWindow || commandName=="BrowseExport" )
        {
            DefaultForm.submitting = false;

            // Clean up some parameters.  This needs to be done when the form is targeted to open
            // in a new window since the parent window does not refresh, leaving these around.
            if( childParams )
                PageHelper.removeElement( "_CHILD_PARAMETERS" );
            if( branch )
            {
                PageHelper.removeElement( "_BRANCH" );
                PageHelper.removeElement( "_FORCED_ID" );
            }
            form.htmlElement.target = currentTarget;
        }
    }
}

PageHelper.onLoadHandler = function ()
{
    PageHelper.closeSubWindows(window);
}

PageHelper.linkToParentWindow = function (currentWindow)
{
    if (currentWindow.opener && (currentWindow.opener != undefined)) {
        currentWindow.opener.subwindow = currentWindow;
    }
}

PageHelper.closeSubWindows = function (parentWindow)
{
    if (parentWindow.subwindow) {
        var childWindow = parentWindow.subwindow;
        while (childWindow && (childWindow != undefined)) {
            try {
                childWindow.close();
                childWindow = childWindow.subwindow;
            } catch (err) {
                // this catches IE11 error when running debugger
                break;
            }
        }
    }
}

/**
 * Shows the loading animation as a wait indicator during form submission.
 */
PageHelper.showWaitIndicator = function()
{
    // Look for image DIV tag in document
    var divTag = document.getElementById("_LOADING_ANIMATION")

    // Compute the position so that it is centered
    var xPos = ( document.body.offsetWidth / 2 );
    var yPos = ( document.body.offsetHeight / 2 );

    // Make it visible and move it to the specified location
    divTag.style.position = "absolute";
    divTag.style.left = (xPos-20) + "px";
    divTag.style.top = (yPos-20) + "px";
    divTag.style.display = "block";
}

/**
 * @private
 */
PageHelper.removeElement = function( id )
{
    if( id )
    {
        var elt = document.getElementById( id );
        if( elt )
            return elt.parentNode.removeChild( elt );
    }
}

/**
 * Execute the server side "Save" command for the given form.  All input elements contained within the form
 * will be submitted with the request. If request is currently pending for the form, then no action is taken.
 * @param {String} formId The component id attribute value for the form
 * @param {String} commandName The name of the save command to be executed.  This must match a command name declared
 * for the application in the Coral configuration file.
 */
PageHelper.doSave = function( formId, commandName )
{
    if( !DefaultForm.submitting )
    {
        PageHelper.doCommand( formId, commandName );
    }
}

/**
 * Execute the server side "Delete" command for the given form.  All input elements contained within the form
 * will be submitted with the request. If request is currently pending for the form, then no action is taken.
 *
 * <h3>Client-side Validations</h3>
 * A confirmation popup will be shown to the user to confirm the delete if the user has retrieved the current record and
 * the user has not changed any key fields after retrieval.  A standard error message popup will be displayed if the record
 * has not been retrieved.  The standard message and title are localized.
 *
 * @param {String} formId The component id attribute value for the form
 * @param {String} commandName The name of the delete command to be executed.  This must match a command name declared
 * for the application in the Coral configuration file.
 * @param {String} confMsg The message to be displayed to the user to confirm the delete.  A standard message will be
 * used if this argument is not supplied
 * @param {String} confTitle The title of the confirmation popup.  A standard title will be used if this argument is not supplied
 */
PageHelper.doDelete = function( formId, commandName, confMsg, confTitle )
{
    if( !DefaultForm.submitting )
    {
        if( PageHelper.isRecordRetrieved() && !fieldChangeMonitor.isKeyFieldChanged() )
        {
            // We always prompt for confirmation to do a delete
            if( !confMsg )
                confMsg = PageHelper.messages.deleteConfirm;
            if( !confTitle )
                confTitle = PageHelper.messages.deleteConfirmTitle;
            if ( PageHelper.confirm( confTitle, confMsg ) )
                PageHelper.doCommand( formId, commandName );
        }
        else
            PageHelper.alert( null, PageHelper.messages.deleteNoRetrieve );
    }
}

/**
 * Execute the server side "Retrieve" command for the given form.  All input elements contained within the form
 * will be submitted with the request. If request is currently pending for the form, then no action is taken.
 *
 * <h3>Client-side Validations</h3>
 * A confirmation popup will be shown to the user to confirm the retrieve if the user has modified the value of any non-required
 * input field.  The standard message and title are localized.
 *
 * @param {String} formId The component id attribute value for the form
 * @param {String} commandName The name of the retrieve command to be executed.  This must match a command name declared
 * for the application in the Coral configuration file.
 * @param {String} confMsg The message to be displayed to the user to confirm the retrieve.  A standard message will be
 * used if this argument is not supplied
 * @param {String} confTitle The title of the confirmation popup.  A standard title will be used if this argument is not supplied
 */
PageHelper.doRetrieve = function( formId, commandName, confMsg, confTitle )
{
    if( !DefaultForm.submitting )
    {
        var continueWithRetrieve = true;

        // If a non-key field has changed, prompt to make sure we should
        // continue
        if ( fieldChangeMonitor.isNonKeyFieldChanged() )
        {
            if( !confMsg )
                confMsg = PageHelper.messages.savePrompt;
            if( !confTitle)
                confTitle = PageHelper.messages.savePromptTitle;
            continueWithRetrieve = PageHelper.confirm( confTitle, confMsg );
        }

        // Now do the retrieve if it is still okay
        if ( continueWithRetrieve )
            PageHelper.doCommand( formId, commandName );
    }
}

/**
 * Execute the server side "Clear" command for the given form.  All input elements contained within the form
 * will be submitted with the request. If request is currently pending for the form, then no action is taken.
 *
 * <h3>Client-side Validations</h3>
 * A confirmation popup will be shown to the user to confirm the clear if the user has modified the value of any
 * input field.  The standard message and title are localized.
 *
 * @param {String} formId The component id attribute value for the form
 * @param {String} commandName The name of the clear command to be executed.  This must match a command name declared
 * for the application in the Coral configuration file.
 * @param {String} confMsg A string message to be displayed to the user to confirm the retrieve.  A standard message will be
 * used if this argument is not supplied
 * @param {String} confTitle A string title of the confirmation popup.  A standard title will be used if this argument is not supplied
 */
PageHelper.doClear = function( formId, commandName, confMsg, confTitle )
{
    if( !DefaultForm.submitting )
    {
        var continueWithClear = true;

        // If any field has changed. prompt to make sure we should
        // continue
        if ( fieldChangeMonitor.fieldChanged() )
        {
            if( !confMsg )
                confMsg = PageHelper.messages.savePrompt;
            if( !confTitle )
                confTitle = PageHelper.messages.savePromptTitle;
            continueWithClear = PageHelper.confirm( confTitle, confMsg );
        }

        // Now do the clear if it is still okay
        if ( continueWithClear )
            PageHelper.doCommand( formId, commandName );
    }
}

/**
 * Determines if the current record has been retrieved from the database.  This can only be used by applications that use
 * the default retrieve command.
 * @return {Boolean} true if the record has been read from the database
 */
PageHelper.isRecordRetrieved = function()
{
    var elt = document.getElementById( "_IS_RETRIEVED" );
    if( !elt )
        return false;
    return( "true" == elt.value )
}

/**
 * Determines if the given string matches the multiple entries indicator.  Text fields that support multiple browse results contain
 * a special field value when more than one object returned as the result of the browse (i.e. the user has selected more than one object).
 * @return {Boolean} true if the field value is the multiple browse result special value
 */
PageHelper.isMultipleEntitiesIndicator = function( str )
{
    var MULTIPLE_ENTRIES_INDICATOR_START = "[";
    return str != null && str.length > 0 && str.charAt( 0 ) == MULTIPLE_ENTRIES_INDICATOR_START;
}

/**
 * Add a hidden input field to the form.
 * @param {String} formId The id of the form to add the field to
 * @param {String} fieldName The name of the hidden field
 * @param {String} fieldVal The value of the hidden field
 * @param {String} fieldId The id of the hidden field
 */
PageHelper.addHiddenFormField = function( formId, fieldName, fieldVal, fieldId )
{
    var formObj = DefaultForm.bindToId( formId );
    formObj.addHiddenField( fieldName, fieldVal, fieldId );
    return formObj.htmlElement;
}

/**
 * Get the value of the hidden field that has the given id and table row index
 * @param {String} fieldId The hidden field id
 * @param [index] Table row index if the hidden field is contained within a Coral table
 * @return {String} The hidden field value, or null if no field can be found
 */
PageHelper.getHiddenFieldValueById = function( fieldId, index )
{
    var retVal = null;
    var fieldElt = PageHelper.getHiddenFieldById( fieldId, index );
    if( fieldElt != null )
        retVal = fieldElt.value;  // Assume the value property is supported.
    return retVal;
}

/**
 * Get the value of the hidden field that has the given id and table row index
 * @param {String} fieldId The hidden field id
 * @param [index] Table row index if the hidden field is contained within a Coral table
 * @return {HTMLElement} The hidden field, or null if no field can be found
 */
PageHelper.getHiddenFieldById = function( fieldId, index )
{
    var retVal = null;
    if( index == null )
    {
        retVal = PageHelper.getElementByIdOrName( fieldId );
    }
    else
    {
        var fieldIndex = "[" + index + "]";
        var newId = fieldId + fieldIndex;
        retVal = PageHelper.getElementByIdOrName( newId );
    }
    return retVal;
}

/**
 * Get the DOM element having the given id or name. The lookup happens in order of id and then name.
 * @param fieldId The element id.
 * @returns The element with the given id or name, or null if not found.
 */
PageHelper.getElementByIdOrName = function(fieldId)
{
    var retVal = document.getElementById(fieldId);
    if (!retVal) {
        var tempElt = document.getElementsByName(fieldId);
        if (tempElt && tempElt.length == 1) {
            retVal = tempElt[0];
        }
    }
    return retVal;
}

/**
 * @private
 */
PageHelper.disableControlFields = function( containerElt, bool, mask )
{
    PageHelper.disableInputFields( containerElt, bool, mask );
    PageHelper.disableSelectFields( containerElt, bool, mask );
    PageHelper.disableTextAreaFields( containerElt, bool, mask );
}

/**
 * @private
 */
PageHelper.disableInputFields = function( containerElt, bool, mask )
{
    var nodeList = containerElt.getElementsByTagName( "input" );
    var node = null;
    for( var i=0; i < nodeList.length; i++ )
    {
        node = nodeList.item( i );
        if (mask)
        {
            if (!node.id.match(mask))
            {
                continue;
            }
        }
        if( BaseComponent.isInputText( node ) )
            TextField.bindToElt( node ).setDisable( bool );
        else if( BaseComponent.isInputCheckBox( node ) )
            CheckBox.bindToElt( node ).setDisable( bool );
        else if( BaseComponent.isInputRadio( node ) )
            RadioButton.bindToElt( node ).setDisable( bool );
        else if( BaseComponent.isInputPassword( node ) )
            RadioButton.bindToElt( node ).setDisable( bool );

    }
}

/**
 * @private
 */
PageHelper.mouseOverToolbarButton = function( elt )
{
    elt.className = "menubaritem_mouseover filemenutext";
}

/**
 * @private
 */
PageHelper.mouseOutToolbarButton = function( elt )
{
    elt.className = "menubaritem_mouseout filemenutext";
}

/**
 * @private
 */
PageHelper.doHelpWindow = function( url )
{
    var helpPopup = window.open( url, "_helpWindow", "height=720,width=1280,scrollbars=yes,top=5,left=200,status=yes,toolbar=yes,menubar=no,location=no,resizable=yes,dependent=yes" );
    if (helpPopup) {
        helpPopup.focus();
    }
}

/**
 * @private
 */
PageHelper.disableSelectFields = function( containerElt, bool, mask )
{
    var nodeList = null;
    if( bool )
        nodeList = containerElt.getElementsByTagName( "select" );
    else
        nodeList = containerElt.getElementsByTagName( "span" );
    var node = null;
    var maxIterations = nodeList.length;
    var iteration = 0;
    var index = 0;
    while( (nodeList.length > 0) && (iteration < maxIterations) )
    {
        // The call to Select.setDisable has the side effect of removing the node, so the
        // lenght of the nodeList decreases by one with each iteration where the node is a select..
        node = nodeList.item( index );
        if (mask)
        {
            if (!node.id.match(mask))
            {
                index++;
                iteration++;
                continue;
            }
        }
        if( BaseComponent.isSelect( node ) )
            Select.bindToElt( node ).setDisable( bool );
        else
            index++;
        iteration++;
    }
}

/**
 * @private
 */
PageHelper.disableTextAreaFields = function( containerElt, bool, mask )
{
    var nodeList = containerElt.getElementsByTagName( "textarea" );
    var node = null;
    for( var i=0; i < nodeList.length; i++ )
    {
        node = nodeList.item( i );
        if (mask)
        {
            if (!node.id.match(mask))
            {
                continue;
            }
        }
        TextArea.bindToElt( node ).setDisable( bool );
    }
}

/**
 * This method returns the name of the function pointed to by 'func'.  The
 * parameter 'func' should be a reference to a function object; if not, this
 * method returns null.
 * @private
 *
 */
PageHelper.getFunctionName = function( func )
{
    if ( typeof func == "function" )
    {
        var funcString = func.toString();
        var index1 = "function ".length;
        var index2 = funcString.indexOf( "(" );
        var funcName = funcString.substring( index1, index2 );

        // Strip off any trailing spaces.
        index1 = funcName.indexOf( " " );
        if ( index1 > 0 )
        {
            funcName = funcName.substring( 0, index1 );
        }
        return funcName;
    }

    return null;
}

/**
 * @private
 */
PageHelper.removeComponentIdSuffix = function( val )
{
    var retId = val;
    var index = val.indexOf( "$" );
    if( (index > -1) && ((index+1) < val.length))
        retId = val.slice( 0, index );
    return retId;
}

/**
 * @private
 */
PageHelper.setDebug = function( id, val, elt )
{
    if( id )
        elt = document.getElementById(id);
    if(elt)
    {
        elt.log = val;
        if( val )
        {
            if( BaseComponent.isSelect( elt ) )
                elt.style.backgroundColor = '#ff7070';
            else
                elt.style.border = '2px dotted #ff0000';
        }
    }
}

/**
 * Turn on Coral JavaScript logging for the Coral component having the specified id
 * @param {String} id The component id
 */
PageHelper.enableLogging = function( id )
{
    var elt = document.getElementById( id );
    if( elt )
        elt.log = true;
}

/**
 * @private
 */
PageHelper.enableLoggingByTag = function( val, tag, type )
{
    var fieldElts = document.getElementsByTagName( tag );
    var elt;
    for( var i=0; i < fieldElts.length; i++ )
    {
        elt = fieldElts.item( i );
        if( type && elt.type )
            if( elt.type == type )
                elt.log = val;
        else
            elt.log = val;
    }
}

/**
 * Logs a message for the given object.  Logging only occurs if obj has the "log" property defined.
 * @private
 */
PageHelper.log = function log( obj, msg, e, funcName )
{
    if( obj != null )
    {
        if( obj.htmlElement.log )
        {
            // Create the logging area at the bottom of the page if it doesn't already exist.
            if( PageHelper.logArea == null )
            {
                var title = document.createElement( "span" );
                title.style.fontWeight = "bold";
                title.style.marginTop = "10px";
                title.appendChild( document.createTextNode( "Component Log" ) );
                document.getElementsByTagName( "BODY" ).item(0).appendChild( title );

                PageHelper.logArea = document.createElement("DIV");
                PageHelper.logArea.setAttribute("class","log_area");
                PageHelper.logArea.setAttribute("style","width:100%;overflow:scroll;height:350px;border:3px solid #e0e0e0;background-color:#e0e0e0;");

                var clearButton = document.createElement( "INPUT" );
                clearButton.type = "button";
                clearButton.value = "Clear";
                clearButton.onclick = PageHelper.clearLog;
                PageHelper.logArea.appendChild( clearButton );

                var spanElt = document.createElement( "SPAN" );
                spanElt.id = "_msg_container";
                PageHelper.logArea.appendChild( spanElt );
                document.getElementsByTagName( "BODY" ).item(0).appendChild( PageHelper.logArea );
            }

            // Build the message prefix.
            var prefix = "[" + PageHelper.logArea.getElementsByTagName( "SPAN" ).item(0).getElementsByTagName( "H6" ).length + "]";
            prefix = prefix + "[" + obj.objectName + "][" + obj.htmlElement.id + "]";
            if( e != null )
                prefix = prefix + "[" + e.type + "]";
            else
                prefix = prefix + "[(event=null)]";

            if( funcName )
                prefix = prefix + "[" + funcName + "]";
            else
                prefix = prefix + "[(func)]";

            prefix = prefix + " ";

            var bgColor = "Thistle";
            if ( PageHelper.logArea.getElementsByTagName( "H6" ).length % 2 )
                bgColor = "#a0a0a0";

            // Add the message to the document
            var msgFormatElt = document.createElement("H6");
            msgFormatElt.setAttribute("class","log_message");
            msgFormatElt.setAttribute("style","background-color: " + bgColor + ";");

            var textElt = document.createTextNode( prefix + msg );
            msgFormatElt.appendChild( textElt );
            PageHelper.logArea.getElementsByTagName( "SPAN" ).item( 0 ).appendChild( msgFormatElt );
        }
    }
}

/**
 * Write a message to the Coral JavaScript log console.
 * @param {String} msg The log message
 */
PageHelper.logMsg = function( msg )
{
    // Create the logging area at the bottom of the page if it doesn't already exist.
    if( PageHelper.logArea == null )
    {
        var title = document.createElement( "span" );
        title.style.fontWeight = "bold";
        title.style.marginTop = "10px";
        title.appendChild( document.createTextNode( "Component Log" ) );
        document.getElementsByTagName( "BODY" ).item(0).appendChild( title );

        PageHelper.logArea = document.createElement("DIV");
        PageHelper.logArea.setAttribute("class","log_area");
        PageHelper.logArea.setAttribute("style","width:100%;overflow:scroll;height:350px;border:3px solid #e0e0e0;background-color:#e0e0e0;");

        var clearButton = document.createElement( "INPUT" );
        clearButton.type = "button";
        clearButton.value = "Clear";
        clearButton.onclick = PageHelper.clearLog;
        PageHelper.logArea.appendChild( clearButton );

        var spanElt = document.createElement( "SPAN" );
        spanElt.id = "_msg_container";
        PageHelper.logArea.appendChild( spanElt );
        document.getElementsByTagName( "BODY" ).item(0).appendChild( PageHelper.logArea );
    }

    // Build the message prefix.
    var prefix = "[" + PageHelper.logArea.getElementsByTagName( "SPAN" ).item(0).getElementsByTagName( "H6" ).length + "]";
    var bgColor = "Thistle";
    if ( PageHelper.logArea.getElementsByTagName( "H6" ).length % 2 )
        bgColor = "#a0a0a0";

    // Add the message to the document
    var msgFormatElt = document.createElement("H6");
    msgFormatElt.setAttribute("class","log_message");
    msgFormatElt.setAttribute("style","background-color: " + bgColor + ";");
    var textElt = document.createTextNode( prefix + msg );
    msgFormatElt.appendChild( textElt );
    PageHelper.logArea.getElementsByTagName( "SPAN" ).item( 0 ).appendChild( msgFormatElt );
}

PageHelper.logArea = null;

/**
 * Clear all log messages from the Coral JavaScript log
 */
PageHelper.clearLog = function()
{
    var js = "log_area.removeChild( document.getElementById( \"_msg_container\" ) );"
    var msgContainer = document.getElementById( "_msg_container" );
    if( PageHelper.logArea != null )
    {
        var msgContainer = PageHelper.logArea.getElementsByTagName( "SPAN" ).item( 0 );
        PageHelper.logArea.removeChild( msgContainer );
        var spanElt = document.createElement( "SPAN" );
        spanElt.id = "_msg_container";
        PageHelper.logArea.appendChild( spanElt );
    }
}

//TODO: Investigate removal
PageHelper.moveToLeft = function(leftSelectId,  rightSelectId)
{
  leftSelect = document.getElementById(leftSelectId);
  rightSelect = document.getElementById(rightSelectId);
  var index = 0;
  var rightOptions = rightSelect.options;
  var optionsLength = rightOptions.length;
  var optionMoved = false;
  while ( index < optionsLength )
  {
    var option = rightOptions[ index ];
    if ( option.selected )
    {
      optionMoved = true;
      option.selected = false;
      leftSelect.appendChild( option.cloneNode( true ) );
      rightSelect.removeChild( option );
      optionsLength--;
    }
    else
    {
      index++;
    }
  }
  if( optionMoved && fieldChangeMonitor)
      fieldChangeMonitor.registerNonKeyFieldChange( rightSelectId  );
}


//TODO: Investigate removal
PageHelper.moveToRight = function( leftSelectId,  rightSelectId)
{
  leftSelect = document.getElementById(leftSelectId);
  rightSelect = document.getElementById(rightSelectId);
  var index = 0;
  var leftOptions = leftSelect.options;
  var optionsLength = leftOptions.length;
  var optionMoved = false;
  while ( index < optionsLength )
  {
    var option = leftOptions[ index ];
    if ( option.selected )
    {
      optionMoved = true;
      option.selected = false;
      rightSelect.appendChild( option.cloneNode( true ) );
      leftSelect.removeChild( option );
      optionsLength--;
    }
    else
    {
      index++;
    }
  }
  if( optionMoved )
      fieldChangeMonitor.registerNonKeyFieldChange( rightSelectId  );
}

//TODO: Investigate removal
PageHelper.prepareForSave = function(leftSelectId,  rightSelectId )
{
  var form = document.getElementById("MAIN");
  var leftSelect = document.getElementById(leftSelectId);
  var rightSelect = document.getElementById(rightSelectId);
  var index = 0;

  var leftOptions = leftSelect.options;
  for ( index = 0; index < leftOptions.length; index++ )
  {
    var hiddenNode = document.createElement( "INPUT" );
    hiddenNode.type = "hidden";
    hiddenNode.name = leftSelect.id;
    hiddenNode.value = leftOptions[ index ].value;
    form.appendChild( hiddenNode );
  }

 var rightOptions = rightSelect.options;
  for ( index = 0; index < rightOptions.length; index++ )
  {
    var hiddenNode = document.createElement( "INPUT" );
    hiddenNode.type = "hidden";
    hiddenNode.name = rightSelect.id;
    hiddenNode.value = rightOptions[ index ].value;
    form.appendChild( hiddenNode );
  }
}


/**
 *
 * @param confTitle
 * @param confMsg
 * @returns
 */
PageHelper.confirm = function( confTitle, confMsg )
{
  return confirm( confTitle + "\n\n\n" + confMsg );
}


PageHelper.alert = function( alertTitle, alertMsg )
{
  if( !alertTitle || alertTitle.length == 0 )
      return alert( alertMsg );
  else
      return alert( alertTitle + "\n\n\n" + alertMsg );
}

PageHelper.getSite = function( id, index )
{
    var retVal = null;
    var elt = document.getElementById( id );
    if( !elt )
    {
        elt = document.getElementById( "SITE" );
        if ( elt )
            retVal = elt.value;
    }
    else
    {
        retVal = elt.value;
    }
    return retVal;
}

PageHelper.createDate = function( date, month, year )
{
    var returnDate = new Date();
    returnDate.setYear( year );
    returnDate.setMonth( month );
    returnDate.setDate(date );
    return returnDate;
}

PageHelper.getXMLHttpRequest = function()
{
    return XBrowserHelper.getXMLHttpRequest();
}
/* (c) Copyright 2014 SAP AG. All rights reserved. */
// "$Revision: Pagination.js/$"

function Pagination(tableName, itemsPerPage, realCounts, totalRecordsText) {
    this.tableName = tableName;
    this.itemsPerPage = itemsPerPage;
    this.totalRecordsText = totalRecordsText;
    this.currentPage = 1;
    this.pages = 0;
    this.inited = false;
    this.realCounts = realCounts;

this.showRecords = function(from, to) {
    var rows = document.getElementById(tableName).rows;
    // i starts from 1 to skip table header row
    for (var i = 1; i < rows.length; i++) {
        if (i < from || i > to)
            rows[i].style.display = 'none';
        else
            rows[i].style.display = '';
    }
};

this.showPage = function(pageNumber, ofStr) {

    var pnp = document.getElementById("pageNavPosition");
    if(document.getElementById("omit1"))
    pnp.removeChild(document.getElementById("omit1"));
    if(document.getElementById("omit1vb"))
    pnp.removeChild(document.getElementById("omit1vb"));
    if(document.getElementById("omit2"))
    pnp.removeChild(document.getElementById("omit2"));
    if(document.getElementById("omit2vb"))
    pnp.removeChild(document.getElementById("omit2vb"));

    if (! this.inited) {
        alert("not inited");
        return;
        }

    if(this.pages-pageNumber>5){
        for(var i = 1; i<pageNumber; i++){
            var hiddenPageAnchor = document.getElementById('pg'+i);
            hiddenPageAnchor.className = 'hidden';
            var hiddenVb = document.getElementById('vb'+i);
            hiddenVb.className = 'hidden';
        }
        this.currentPage = pageNumber;
        var newPageAnchor = document.getElementById('pg'+this.currentPage);
        newPageAnchor.className = 'pg-selected';
        var curVb = document.getElementById('vb'+this.currentPage);
        curVb.className = 'pg-normal';

        for(var j = pageNumber+1; j<= pageNumber+2; j++){
            var normalPageAnchor = document.getElementById('pg'+j);
            normalPageAnchor.className = 'pg-normal';
            var norVb = document.getElementById('vb'+j);
            norVb.className = 'pg-normal';
        }


        for(var x = pageNumber+3; x<this.pages-2; x++ ){
            var hiddenPageAnchor = document.getElementById('pg'+x);
            hiddenPageAnchor.className = 'hidden';
            var hiddenVb = document.getElementById('vb'+x);
            hiddenVb.className = 'hidden';

            if(x == pageNumber+3){
            var omit1 = document.createElement("span");
                omit1.id = "omit1";
                // compatibility of IE/FF/Chrome, should not use innerHtml to avoid XSS
                if(document.all){
                    omit1.innerText = "... ";
                }else{
                    omit1.textContent = "... ";
                }

            var omit1vb = document.createElement("span");
                omit1vb.id = "omit1vb";
                if(document.all){
                    omit1vb.innerText = "|";
                }else{
                    omit1vb.textContent = "|";
                }
                omit1vb.className = "pg-normal";

            pnp.insertBefore(omit1vb,hiddenPageAnchor);
            pnp.insertBefore(omit1,omit1vb);
            }
        }

        for(var k = this.pages-2; k<=this.pages; k++){
        var normalPageAnchor = document.getElementById('pg'+k);
            normalPageAnchor.className = 'pg-normal';
        var norVb = document.getElementById('vb'+k);
            norVb.className = 'pg-normal';
        }
    }

    if(this.pages>6 && this.pages-pageNumber<=5){

        for(var i = 1; i<this.pages-5; i++){
            var hiddenPageAnchor = document.getElementById('pg'+i);
            hiddenPageAnchor.className = 'hidden';
            var hiddenVb = document.getElementById('vb'+i);
            hiddenVb.className = 'hidden';
        }

        for(var j = this.pages-5; j<= this.pages; j++){
            var normalPageAnchor = document.getElementById('pg'+j);
            normalPageAnchor.className = 'pg-normal';
            var norVb = document.getElementById('vb'+j);
            norVb.className = 'pg-normal';

            if(j==this.pages-5){
                var omit2 = document.createElement("span");
                omit2.id = "omit2";
                if(document.all){
                    omit2.innerText = "... ";
                }else{
                    omit2.textContent = "... ";
                }

            var omit2vb = document.createElement("span");
                omit2vb.id = "omit2vb";
                if(document.all){
                    omit2vb.innerText = "|";
                }else{
                    omit2vb.textContent = "|";
                }
                omit2vb.className = "pg-normal";


            pnp.insertBefore(omit2vb,normalPageAnchor);
            pnp.insertBefore(omit2,omit2vb);
            }
        }

        this.currentPage = pageNumber;
        var newPageAnchor = document.getElementById('pg'+this.currentPage);
        if (newPageAnchor) {
            newPageAnchor.className = 'pg-selected';
        }
    }
    if(this.pages<=6){
        var oldPageAnchor = document.getElementById('pg'+this.currentPage);
        if (oldPageAnchor) {
            oldPageAnchor.className = 'pg-normal';
        }

        this.currentPage = pageNumber;
        var newPageAnchor = document.getElementById('pg'+this.currentPage);
        if (newPageAnchor) {
            newPageAnchor.className = 'pg-selected';
        }
    }

    var from = (pageNumber - 1) * itemsPerPage + 1;
    var to = from + itemsPerPage - 1;
    this.showRecords(from, to);
    
    var navElement = document.getElementById("pageNavigationStatus");
    if (navElement) {
		var statusText='';
	    var to2 = Math.min(from + itemsPerPage - 1, realCounts);
	    if(!ofStr){
	    	ofStr = 'of';
	    }
	    if(realCounts > itemsPerPage) {
	    	statusText = totalRecordsText + ": " + from + "-" + to2 + " "+ofStr+" " + realCounts;
	    }
	    else {
	    	var rowsCount = document.getElementById(tableName).rows.length-1;
	    	statusText = totalRecordsText + ": " + rowsCount;
	    }
	    navElement.innerHTML = statusText;
    }
 };

this.prev = function() {
    if (this.currentPage > 1)
        this.showPage(this.currentPage - 1);
};

this.next = function() {
    if (this.currentPage < this.pages) {
        this.showPage(this.currentPage + 1);
    }
};

this.first = function() {
    this.showPage(1);
};

this.init = function() {
    var rows = document.getElementById(tableName).rows;
    var records = (rows.length - 1);
    this.pages = Math.ceil(records / itemsPerPage);
    this.inited = true;
};

this.showPageNav = function(pagerName, positionId, showCount, prevStr, nextStr) {
    if (! this.inited) {
        return;
    }
    var rowsCount = document.getElementById(tableName).rows.length-1;
    var pagerHtml='';

    if(!prevStr){
    	prevStr = 'Prev';
    }
    if(!nextStr){
    	nextStr = 'Next';
    }
    if (rowsCount > 0 ){
        var element = document.getElementById(positionId);
        if (showCount){
        	pagerHtml +='<span class="pg-text" id="pageNavigationStatus"></span>';
        }
        if(rowsCount > itemsPerPage) {
            pagerHtml+='<span onclick="' + pagerName + '.first();" class="pg-normal"> &#171   </span>';
            pagerHtml+='<span onclick="' + pagerName + '.prev();" class="pg-normal">'+prevStr+' </span> <span class = "pg-normal">|</span> ';
            for (var page = 1; page <= this.pages; page++)
                pagerHtml += '<span id="pg' + page + '" class="pg-normal" onclick="' + pagerName + '.showPage(' + page + ');">' + page + '</span> <span id="vb'+page+'" class="pg-normal">|</span> ';
            pagerHtml += '<span onclick="'+pagerName+'.next();" class="pg-normal"> '+nextStr+'   &#187;</span>';
        }

    }
    element.innerHTML = pagerHtml;
};
}/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: /main/3$"

// -------------------------------------------------------------------------
// --------------------------- Component Construction & Initialization
// -------------------------------------------------------------------------

function RadioButton( id, elt )
{
    // Initialize the base component
    var element = null;
    if( !elt )
        element = document.getElementById( id );
    else
        element = elt;

    this.initializeBaseComponent( element, "RadioButton" );
}
RadioButton.prototype = new BaseComponent();
RadioButton.prototype.constructor = RadioButton;

/**
 * Static method for creating a new component instance within a TableRow.
 * @param {String} value The value submitted for this button if it is selected.
 * @returns {RadioButton}
 */
RadioButton.create = function( id, name, value )
{
    var elt = null;

    // Default attribute values
    if( !id ) id = "";
    if( !name ) name = "";
    if( !value ) value = "";

    if( document.all ) {
        // ie radio buttons do not function properly if not created this way
        elt = document.createElement("INPUT");
        elt.setAttribute("name",name);
        elt.setAttribute("id",id);
        elt.setAttribute("type","radio");
        elt.setAttribute("value",value);
    } else {
        elt = document.createElement( "INPUT" );
        elt.id = id;
        elt.type = "radio";
        elt.name = name;
        elt.value = value;
    }
    return new RadioButton( null, elt );
}

RadioButton.bindToId = function( id )
{
    return new RadioButton( id );
}

RadioButton.bindToElt = function( elt )
{
    return new RadioButton( null, elt );
}

RadioButton.activateRadioButton = function( radioElt, e )
{
    RadioButton.bindHTMLEvents( radioElt );
    var propertyName = radioElt.name + "radio_selected";

    // Set a reference to the radio button container.  This object will be used
    // to define a property for tracking the id of the currently selected button.
    // If this button is in a table, then we must set the table element as the container
    // (not the table cell, which is not shared among all the buttons in the group.  Otherwise,
    // this element's parent will do.
    if( BaseComponent.isTableCell( radioElt.parentNode ) )
        radioElt.container = radioElt.parentNode.parentNode.parentNode;
    else
        radioElt.container = radioElt.parentNode;

    if( e != null )
        RadioButton.bindToElt( radioElt ).handleClick( e );
    else
        radioElt.container[propertyName] = radioElt.id;
}

// -------------------------------------------------------------------------
// --------------------------- Intrinsic & Extended Events Binding
// -------------------------------------------------------------------------

RadioButton.bindHTMLEvents = function( elt )
{
    elt.onclick = new Function( "e", "if( !e ) e = window.event; RadioButton.bindToElt( this ).handleClick( e );" );
    //MAY NOT BE NEEDED, CLICK HANDLER MAY COVER THIS elt.onchange = new Function( "e", "if( !e ) e = window.event; RadioButton.bindToElt( this ).handleValueChange( e );" );
}

RadioButton.addExtEvents = function( extEventsProcessor )
{
    extEventsProcessor.addEvent( "onSelect" );
    extEventsProcessor.addEvent( "onDeselect" );
}

RadioButton.prototype.handleClick = function( browserEvent )
{
    if( this.htmlElement.log )
        PageHelper.log( this, "Radio button onclick handler for button with id=" + this.htmlElement.id + ", checked=" + this.htmlElement.checked , browserEvent, "handleClick" );
    var clickEvent = new BaseEvent( browserEvent );
    if( this.htmlElement.name != "" )
    {
        var propertyName = this.htmlElement.name + "radio_selected";

        // Initialize the container.
        if( !this.htmlElement.container )
        {
            if( BaseComponent.isTableCell( this.htmlElement.parentNode ) )
                this.htmlElement.container = this.htmlElement.parentNode.parentNode.parentNode;
            else
                this.htmlElement.container = this.htmlElement.parentNode;
        }

         if( this.htmlElement.container[propertyName] == this.id  )
         {
            this.htmlElement.checked = false;
            this.htmlElement.container[propertyName] = null;
            this.publishEvent( "onDeselect", clickEvent );
         }
        else
        {
            this.htmlElement.container[propertyName] = this.id;
             this.publishEvent( "onSelect", clickEvent );
        }

        this.registerFieldChange();

        if( this.htmlElement.log )
            PageHelper.log( this, "Container radio selected property set to " + this.htmlElement.container[propertyName] , browserEvent, "handleClick" );
    }
}

RadioButton.prototype.setSelected = function( bool )
{
    if( this.htmlElement.name != "" )
    {
        this.htmlElement.checked = bool;
        var propertyName = this.htmlElement.name + "radio_selected";

        if( this.htmlElement.checked )
             this.htmlElement[propertyName] = "x";
        else
        {
            this.htmlElement[propertyName] = null;
        }
    }
}

/**
 * @returns {Boolean} true if the RadioButton is selected, false otherwise
 */
RadioButton.prototype.isSelected = function()
{
    return this.htmlElement.checked;
}

/**
 * Disables this radio button.  The selected state is still submitted when disabled.
 * 
 * @param {Boolean} bool true to disable, false to enable
 */
RadioButton.prototype.setDisable = function( bool )
{
    this.htmlElement.disabled = bool;
}

/**
 * Disables the group of radio buttons.  The selected state of each button is still submitted when disabled.
 * 
 * @param {Boolean} bool true to disable the group, false to enable
 */
RadioButton.setGroupDisabled = function( bool, name )
{
    var radios = document.getElementsByName( name );
    var radioElt = null;
    for( var i=0; i < radios.length; i++ )
    {
        radioElt = radios.item(i);
        if( radioElt.type && radioElt.type == "radio" )
        {
            // Short circuit if the group is already disabled.
            if( radioElt.disabled && bool )
                return;

            radioElt.disabled = bool;
             var hiddenElt = null;
            if( bool && radioElt.checked )
            {
                hiddenElt = BaseComponent.createHiddenField( name, radioElt.value, "_" + name );
                radioElt.container.appendChild( hiddenElt );
            }
            else if( radioElt.checked )
            {
                hiddenElt = document.getElementById( "_" + name );
                if( hiddenElt  )
                {
                    radioElt.container.removeChild( hiddenElt );
                }
            }
        }
    }
}

/**
 * Returns the disabled state of the group
 * 
 * @return {Boolean} true if the RadioButton group is disabled, false otherwise
 */
RadioButton.isGroupDisabled = function( name )
{
    var radios = document.getElementsByName( name );
    var radioElt = null;
    for( var i=0; i < radios.length; i++ )
    {
        radioElt = radios.item(i);
        if( radioElt.type && radioElt.type == "radio" )
            if( !radioElt.disabled )
                return false;
    }
    return true;
}

/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: /main/11$"

// -------------------------------------------------------------------------
// --------------------------- Component Construction & Initialization
// -------------------------------------------------------------------------
function Select( id, elt )
{
    // Initialize the base component
    if( elt )
        this.htmlElement = elt;
    else
        this.htmlElement = document.getElementById( id );
    this.initializeBaseComponent( this.htmlElement, "Select" );
}
Select.prototype = new BaseComponent();
Select.prototype.constructor = Select;


Select.create = function( id, name, disabled )
{
    if( disabled )
    {
        var spanElt = document.createElement( "span" );
        if( id ) spanElt.id = id;
        if( name )
        {
            spanElt.appendChild( document.createTextNode( "" ) );
            var hidden = BaseComponent.createHiddenField( name, "" );
            hidden.className = "option";
            spanElt.appendChild( hidden );
        }
        return new Select( null, spanElt );
    }
    else
    {
        var selectElt = document.createElement( "select" );
        if( id ) selectElt.id = id;
        if( name ) selectElt.name = name;
        return new Select( null, selectElt );
    }
}

Select.bindToId = function( id )
{
    return new Select( id );
}

Select.bindToElt = function( elt )
{
    return new Select( null, elt );
}

Select.activateSelect = function( selectElt, e )
{
    if( !BaseComponent.isSpan( selectElt ) )
    {
        Select.bindHTMLEvents( selectElt );
        if( e != null )
        {
            // Handle activation initiated by putting focus in the select box.
            Select.bindToElt( selectElt ).handleFocus( e );
        }
    }
}


// -------------------------------------------------------------------------
// --------------------------- Accessors & Mutators
// -------------------------------------------------------------------------

/**
 * @return {String} The selected option value 
 */
Select.prototype.getValue = function()
{
    if( this.isDisabled() )
    {
        var inputElt = BaseComponent.getChildInput( this.htmlElement );
        return inputElt.value;
    }
    return this.htmlElement.value;
}

/**
 * @return {number} The number of options contained within the list
 */
Select.prototype.getNumOptions = function()
{
    if( !this.isDisabled() )
        return this.htmlElement.options.length;
    return 0;
}

/**
 * Enables/disables this select.  The selected value is still submitted when disabled.
 * 
 * @param {Boolean} bool true to disable, false to enable
 */
Select.prototype.setDisable = function( val )
{
    if( val && !this.isDisabled() )
    {
        // Create a disabled select, transfer the current options
        var select = Select.create( this.htmlElement.id, this.htmlElement.name, true );
        var options = this.htmlElement.options;
        var optionsAr = new Array();
        for( var i=0; i < options.length; i++ )
        {
            if( options[i].selected )
                optionsAr.push( new Option( options[i].text, options[i].value, false, true ) );
            else
                optionsAr.push( new Option( options[i].text, options[i].value, false, false ) );
        }
        select.htmlElement.options = optionsAr;
        select.setSelectedValue( this.getValue() );
        this.transferBaseProperties( select );

        // Swap elts and init the container style
        var selectParent = this.htmlElement.parentNode;
        if( BaseComponent.isTableCell( selectParent ) )
            selectParent.className = "table_text";
        else
            select.htmlElement.className = "text";
        selectParent.replaceChild( select.htmlElement, this.htmlElement );
    }
    else if( !val && this.isDisabled() )
    {
        // Create enabled select, transfer options
        var input = BaseComponent.getChildInput( this.htmlElement );
        select = Select.create( this.htmlElement.id, input.name, false );

        if( this.htmlElement.options )
        {
            select.setOptionList( this.htmlElement.options );
        }
        else
        {
            // Get the options from the markup
            var optionSpanNodeList = this.htmlElement.getElementsByTagName( "span" );
            if( optionSpanNodeList )
            {
                var optionSpan = optionSpanNodeList.item(0);
                var optionNodeList = optionSpan.getElementsByTagName( "input" );
                if( optionNodeList )
                {
                    var optionAr = new Array();
                    var option = null;
                    for( var i=0; i < optionNodeList.length; i++ )
                    {
                        option = optionNodeList.item(i);
                        optionAr.push( new Option( option.value, option.name, false, false ) );
                    }
                    select.setOptionList( optionAr );
                }
            }
        }
        select.htmlElement.value = input.value;
        Select.activateSelect( select.htmlElement );
        this.transferBaseProperties( select );

        // Swap elts and init the container style
        var selectParent = this.htmlElement.parentNode;
        if( BaseComponent.isTableCell( selectParent ) )
            selectParent.className = "table_input_fields";
        selectParent.replaceChild( select.htmlElement, this.htmlElement );
    }
}

/**
 * Selects the option where option.value == value.
 * @param {String} value The value of the option that is to be set as selected.
 */
Select.prototype.setSelectedValue = function( value )
{
    if( this.isDisabled() )
    {
        var inputElt = BaseComponent.getChildInput( this.htmlElement );
        inputElt.value = value;

        var displayValue = null;
        if( this.htmlElement.options )
        {
            var options = this.htmlElement.options;
            var found = false;
            for( var i=0; i < options.length && !found; i++ )
            {
                if( value == options[i].value )
                {
                    displayValue = options[i].text;
                    found = true;
                }
            }
            if( !found && options.length > 0 )
                displayValue = options[0].text;
        }
        var displayText = document.createTextNode( displayValue );
        var textNode = BaseComponent.getFirstChildTextNode( this.htmlElement );
        this.htmlElement.replaceChild( displayText, textNode );
    }
    else
        this.htmlElement.value = value;
}

/**
 * @return {HTMLOptionElement} The option at the specified index, or null if the index is invalid, or the select is disabled
 */
Select.prototype.getOption = function( index )
{
    if( !this.isDisabled() )
    {
        if( this.getNumOptions() > index )
            return this.htmlElement.options[ index ];
    }
    return null;
}

Select.prototype.setOptionList = function( optionList )
{
    if( optionList )
    {
        if( this.isDisabled() )
        {
            this.htmlElement.options = optionList;
        }
        else
        {
            this.htmlElement.options.length = 0;  // Remove the current options
            for( var i=0; i < optionList.length; i++ )
                this.addOption( optionList[i] );
        }
    }
}

Select.prototype.addOption = function( option )
{
    if( this.isDisabled() )
    {
    }
    else
    {
        if( document.all )
        {
            if( option.text.length == 0 )
                option.text = "something";
            this.htmlElement.add( option );
        }
        else
            this.htmlElement.add( option, null );
    }
}

Select.prototype.removeOption = function( index )
{
    if( !this.isDisabled() || isNaN( index ) )
        this.htmlElement.remove( index );
}

/**
 * @returns {Boolean} true if the Select is disabled, false otherwise
 */
Select.prototype.isDisabled = function()
{
    return BaseComponent.isSpan( this.htmlElement );
}


// -------------------------------------------------------------------------
// --------------------------- Intrinsic & Extended Events Binding
// -------------------------------------------------------------------------

Select.bindHTMLEvents = function( elt )
{
    if( !BaseComponent.isSpan( elt ) )
    {
        elt.onfocus = new Function( "e", "if( !e ) e=window.event; Select.bindToElt( this ).handleFocus( e );" );
        elt.onblur = new Function( "e", "if( !e ) e=window.event; Select.bindToElt( this ).handleFocusLost( e );" );
        elt.onchange = new Function( "e", "if( !e ) e=window.event; Select.bindToElt( this ).handleSelectionChange( e );" );
    }
}

Select.addExtEvents = function( extEventsProcessor )
{
    extEventsProcessor.addEvent( "onFocus" );
    extEventsProcessor.addEvent( "onFocusLost" );
    extEventsProcessor.addEvent( "onSelectionChange" );
}

Select.prototype.handleFocus = function( browserEvent )
{
    this.publishEvent( "onFocus", new BaseEvent( browserEvent ) );
}

Select.prototype.handleFocusLost = function( browserEvent )
{
    this.publishEvent( "onFocusLost", new BaseEvent( browserEvent ) );
}

Select.prototype.handleSelectionChange = function( browserEvent )
{
    var event = new BaseEvent( browserEvent );
    event.selectedValue = this.getValue();
    if( this.htmlElement.row )
        event.row = this.htmlElement.row;
    this.publishEvent( "onSelectionChange", event );
    
    // Register the field change with the field monitor    
    this.registerFieldChange();    
}

Select.prototype.handleDisable = function( bool )
{
}

/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: Table.js/main/50$"

function Table( id, elt )
{
    var tableElt = null;
    if( elt )
        tableElt = elt;
    else if( id != null )
        tableElt = document.getElementById( id );

    if( tableElt )
    {
        this.htmlElement = tableElt;
        this.createRow = this.htmlElement.createTemplateRow;
    }
    this.objectName = "Table";
}

Table.bindToElt = function( elt )
{
    return new Table( null, elt );
}

Table.bindToId = function( id )
{
    var tableElt = document.getElementById( id );
    if( tableElt == null )
        return null;
    return new Table( null, tableElt );
}

Table.activateTable = function( id )
{
    var tableElt = document.getElementById( id );
    if( !tableElt )
        return null;

    Table.bindHTMLEvents( tableElt );

    var table = Table.bindToElt( tableElt );
    var chkbx = document.getElementById( id + "$SELECT_ALL_CHECKBOX" );
    if( chkbx )
    {
        if( !table.htmlElement.selectAllRows )
        {
            table.htmlElement.selectAllRows = function(e)
            {
                if( !e ) e = window.event;
                var be = new BaseEvent( e );
                var checkbox = be.getSourceElement();
                var tableId = PageHelper.removeComponentIdSuffix( checkbox.id );
                var table = Table.bindToId( tableId );
                table.selectAllRows( checkbox.checked );
            }
            chkbx.onclick = table.htmlElement.selectAllRows;
        }

        // Disable select all if there are no rows.
        if( table.getNumRows() == 0 )
        {
            chkbx.disabled = true;
        }
    }
}


// -------------------------------------------------------------------------
// --------------------------- Intrinsic & Extended Events Binding
// -------------------------------------------------------------------------

Table.bindHTMLEvents = function( elt )
{
    elt.onclick = new Function( "e", "if(!e) e=window.event; var table=Table.bindToId(this.id);table.handleClick(e);" );

    // Support for keyboard based row selection
    elt.onkeydown = new Function( "e", "if( !e ) e= window.event; Table.bindToId(this.id).handleKeyDown( e );" );
}

Table.addExtEvents = function( extEventsProcessor )
{
    extEventsProcessor.addEvent( "onRowClick" );
    extEventsProcessor.addEvent( "onRadioClick" );
}

// -------------------------------------------------------------------------
// --------------------------- Intrinsic Event Handlers
// -------------------------------------------------------------------------

Table.prototype.handleClick = function( e )
{
    var evt = new BaseEvent( e );
    var elt = evt.getSourceElement();

    // Allow text enclosed in a span to trigger a row selection
    if( BaseComponent.isSpan( elt ) )
        elt = elt.parentNode;

    if( BaseComponent.isTableCell( elt ) )
    {
        var row = elt.parentNode;

        // Don't allow selection of the head row.
        if( row.rowIndex > 0 )
        {
            var rowObj = TableRow.bindToElt( row );
            if( !rowObj.isDisabled() )
            {
                if( this.htmlElement.extEventsProcessor != null )
                {
                    evt.tableRow = rowObj;
                    this.htmlElement.extEventsProcessor.publishEvent( "onRowClick", evt );
                }

                if( evt.returnValue )
                {
                    evt.rowSelected = this.selectRow( row );
                    if( this.htmlElement.log )
                    {
                        var rowObj = TableRow.bindToElt( row );
                    }
                }
            }
        }
    }
    else if( BaseComponent.isInputRadio( elt ) )
    {
        if( this.htmlElement.log )
            PageHelper.log( this,"Clicked radio id=" + elt.id + ", checked=" + elt.checked, e, "handleClick" );
        var sriElt = document.getElementById( this.htmlElement.id + "_" + elt.name + "_SELECTED_INDEX" );
        if( sriElt )
        {
            var radioObj = RadioButton.bindToElt( elt );
            if( radioObj.isSelected() )
                sriElt.value = radioObj.getRowIndex();
            else
                sriElt.value = "-1";
            if( this.htmlElement.log )
                PageHelper.log( this,"Updated selected radio row index=" + sriElt.value );
            if( this.htmlElement.extEventsProcessor != null )
            {
                evt.srcObject = radioObj;
                this.htmlElement.extEventsProcessor.publishEvent( "onRadioClick", evt );
            }
        }
    }
}

function getParentRowElt( element ){
	if(element.nodeName=="TR" || element.nodeName=="tr"){
		return element;
	} else {
		return getParentRowElt(element.parentNode);
	}
}

// Changes row selection based on keyup and keydown navigation with the arrow keys. Unfortunately, the
// amount of vertical space scrolled is slightly greater than the height of a row, meaning that
// eventually the selected row will scroll out of view.
Table.prototype.handleKeyDown = function( browserEvent )
{
    //DO NOT REMOVE; COMMENTED OUT SINCE ROW SELECTION DOES NOT SYNCHRONIZE WITH SCROLLING
    var be = new BaseEvent( browserEvent );
    var selRow = this.getSelectedRow();
    var elt = be.getSourceElement();

    var rowSelected = false;
    var keyCode = be.getKeyCode();

    if(!BaseComponent.isSelect(elt) && be.shiftPressed() && keyCode == 32){        
        if(selRow){
             rowSelected = this.selectRowByIndex(selRow.getIndex());
             selRow.htmlElement.focus();
        	 be.cancelEvent();
        }else{
            var prevSelectedRow = this.getPreviouslySelectedRow();
            if(prevSelectedRow){
                rowSelected = this.selectRowByIndex(prevSelectedRow.getIndex());
                prevSelectedRow.htmlElement.focus();
        	    be.cancelEvent();
             }
        }
        return true;
    }
        

    if(!BaseComponent.isSelect(elt) && be.ctrlPressed() && (keyCode == 36 || keyCode == 35) && this.getNumRows()>0) {
    	var elementId = elt.id;
    	var focusElement;
    	var newRowNum = keyCode == 36 ? 0 : this.getNumRows()-1;
    	var newRow = this.getRow(newRowNum);
    	if(elementId.indexOf("[")>0){
    		var element = newRow.getRowItem(elementId.substr(0, elementId.indexOf("[")));
    		if(getFocusableElement(element)){
    			focusElement = element;
    		} else {
    			focusElement = keyCode == 36 ? this.getFirstFocusableItemInRow(newRow) : this.getLastFocusableItemInRow(newRow);
    		}
    	} else {
    		focusElement = keyCode == 36 ? this.getFirstFocusableItemInRow(newRow) : this.getLastFocusableItemInRow(newRow);
    	}
    	if(focusElement){
    		focusElement.focus();
    		be.cancelEvent();
    	}
    	return true;
    }


    if(!BaseComponent.isSelect(elt) && ! BaseComponent.isInputText(elt) && (keyCode == 36 || keyCode == 35) ) {
    	var elementId = elt.id;
    	var focusElement;
    	if(elementId.indexOf("[")>0){
    		var rowElt = TableRow.bindToElt(getParentRowElt(elt));

    		// Home key
    		if(keyCode == 36) {
    			this.getFirstFocusableItemInRow(rowElt).focus();
    		}// End key
    		else {
    			this.getLastFocusableItemInRow(rowElt).focus();
    		}
			return true;
    	}
    }

    if(BaseComponent.isInputRadio(elt) || BaseComponent.isSelect(elt)) {
    	return true;
    }

    if (this.getNumRows() > 0) {
        if (keyCode == 40) { // Down arrow
            var newIndex = selRow ? selRow.getIndex() + 1 : 0;
            if (newIndex < this.getNumRows()) {
                rowSelected = this.selectRowByIndex(newIndex);
            }
            be.cancelEvent();
        } else if (keyCode == 38) { // Up arrow
            var newIndex = selRow ? selRow.getIndex() - 1 : this.getNumRows() - 1;
            if (newIndex > -1) {
                rowSelected = this.selectRowByIndex(newIndex);
            }
            be.cancelEvent();
        }
    }
    if (rowSelected) {
        selRow = this.getSelectedRow();
        selRow.htmlElement.scrollIntoView(false);
        var selRowNum = selRow.getIndex();
        var element;
		if(elt.id.indexOf("[")>0){
    		element = selRow.getRowItem(elt.id.substr(0, elt.id.indexOf("[")));
    		if(!getFocusableElement(element)){
        		element = this.getFirstFocusableItemInRow(selRow);
    		}
    	} else {
    		element = this.getFirstFocusableItemInRow(selRow);
    	}
    	if(element){
    		element.focus();
    	}

    }
}

// -------------------------------------------------------------------------
// --------------------------- Setters/Getters, and Helpers
// -------------------------------------------------------------------------

/**
 * Display/hide the component.
 * @param {Boolean} bool true displays the table, false hides the table
 */
Table.prototype.setDisplay = function( bool )
{
    // Handle the table menu
    var menuElt = document.getElementById( this.getComponentId() + "_TABLE_MENU" );
    if( menuElt )
        BaseComponent.setDisplay( menuElt, bool, "block" );

    var containerElt = document.getElementById( this.getComponentId() + "_CONTAINER" );
    if( containerElt )
        BaseComponent.setDisplay( containerElt, bool, "block" );
    else
        BaseComponent.setDisplay( this.htmlElement, bool, "block" );
}

/**
 * Disables all standard table menu items.
 * @param {Boolean} bool true disables the menu items, false enables
 */
Table.prototype.setMenuDisabled = function( bool )
{
    if( this.hasMenu() )
    {
        this.setInsertNewDisabled( bool );
        this.setInsertBeforeDisabled( bool );
        this.setInsertAfterDisabled( bool );
        this.setRemoveSelectedDisabled( bool );
        this.setRemoveAllDisabled( bool );
    }
}

Table.prototype.setInsertNewDisabled = function( bool )
{
    var linkObj = PageHelper.getLink( this.getComponentId() + "_INSERT_NEW" );
    if( linkObj )
        linkObj.setDisable( bool );
}

Table.prototype.setInsertBeforeDisabled = function( bool )
{
    var linkObj = PageHelper.getLink( this.getComponentId() + "_INSERT_BEFORE" );
    if( linkObj )
        linkObj.setDisable( bool );
}

Table.prototype.setInsertAfterDisabled = function( bool )
{
    var linkObj = PageHelper.getLink( this.getComponentId() + "_INSERT_AFTER" );
    if( linkObj )
        linkObj.setDisable( bool );
}

Table.prototype.setRemoveSelectedDisabled = function( bool )
{
    var linkObj = PageHelper.getLink( this.getComponentId() + "_REMOVE_SELECTED" );
    if( linkObj )
        linkObj.setDisable( bool );
}

Table.prototype.setRemoveAllDisabled = function( bool )
{
    var linkObj = PageHelper.getLink( this.getComponentId() + "_REMOVE_ALL" );
    if( linkObj )
        linkObj.setDisable( bool );
}

/**
 * Get the table id.
 * @return {String} The component id
 */
Table.prototype.getComponentId = function()
{
    return this.htmlElement.id;
}

/**
 * The table row count.
 * @return {number} The table row count.
 */
Table.prototype.getNumRows = function()
{
    var tbody = this.getTableBody();
    var numRows = 0;
    if( tbody != null )
        numRows = tbody.rows.length; // Returns -1 if there are no rows (0 would have been nice).
    if( numRows == -1 )
        numRows = 0;
    return numRows;
}

/**
 * The table column count.
 * @return {number} The table column count.
 */
Table.prototype.getNumCols = function()
{
    var thead = this.getTableHead();
    return thead.rows.item(0).cells.length;
}

Table.prototype.getColumnIds = function()
{
    var thead = this.getTableHead();
    var headCells = thead.rows.item(0).cells;

    var idArray = new Array();
    var tmpId = null;
    var startIndex = this.htmlElement.id.length + 1;
    for( var i=0; i < headCells.length; i++ )
    {
        tmpId = headCells.item(i).id;
        idArray[i] = tmpId.slice( startIndex );
    }
    return idArray;
}

Table.prototype.createRowId = function()
{
    var rowId = this.htmlElement.nextRowId;
    this.htmlElement.nextRowId++;
    return rowId;
}

Table.prototype.initializeRowId = function()
{
    this.htmlElement.nextRowId = this.getNumRows();
}

Table.prototype.getTableHead = function()
{
    return this.htmlElement.tHead;
}

Table.prototype.getTableBody = function()
{
    return this.htmlElement.tBodies.item(0);
}

/**
 * @returns {TableRow} The table row at the specified index, or null if
 * the table contains no rows, or the index is out of range.
 */
Table.prototype.getRow = function( index )
{
    var numRows = this.getNumRows();

    // Check for no rows and out of range
    if( numRows == 0  || (numRows < (index+1) ) )
        return null;

    var tbody = this.getTableBody();
    var rowElt = tbody.rows.item( index );
    var row = TableRow.bindToElt( rowElt );
    return row;
}

/**
 * Row selection means the row that is currently highlighted.
 * @return {TableRow} The currently selected row, or null if no row is selected.
 */
Table.prototype.getSelectedRow = function()
{
    if( this.htmlElement.currentlySelectedRow )
        return TableRow.bindToElt( this.htmlElement.currentlySelectedRow );
    else
        return null;
}

Table.prototype.getPreviouslySelectedRow =function()
{
	if( this.htmlElement.previouslySelectedRow )
	        return TableRow.bindToElt( this.htmlElement.previouslySelectedRow );
	    else
        return null;
}

/**
 * @returns {number} The index of the currently selected row, or -1 if no row is selected.
 */
Table.prototype.getSelectedRowIndex = function()
{
    if( this.htmlElement.currentlySelectedRow )
        return TableRow.bindToElt( this.htmlElement.currentlySelectedRow ).getIndex();
    else
        return -1;
}

/**
 * Determines if this table is a multi-select table.
 * @returns {Boolean} true if the table supports multiple row selection via the multi-select checkbox
 * column, or false if it is single select.
 */
Table.prototype.isMultiSelect = function()
{
    return this.htmlElement.multiSelect;
}

/**
 * Determines if a row is selected in a single select table.
 * @return {Boolean} true if any row is selected, false otherwise.
 */
Table.prototype.isRowSelected = function()
{
    if( this.htmlElement.currentlySelectedRow )
        return true;
    return false;
}

Table.prototype.hasMenu = function()
{
    if( document.getElementById( this.getComponentId() + "_TABLE_MENU" ) )
        return true;
    return false;
}
/*
 * This function can be customized by defining on jsp function getFirstFocusableItemInTableRowCallback.
 * It receive parameters table id and row and should return some table element or nothing.
 *
 * For example:
 * function getFirstFocusableItemInTableRowCallback(tableId, row) {
 * 		if ("TransferTable" == tableId)
 *		{
 *      	return row.getRowItem("RECEIVE_REQ");
 *      }
 * }
 */
Table.prototype.getFirstFocusableItemInRow = function( row )
{
	if ( window.getFirstFocusableItemInTableRowCallback )
	{
		var item = getFirstFocusableItemInTableRowCallback(this.htmlElement.id, row);
		if (item)
		{
			return item;
		}
	}
	return row.getFirstFocusableItem();
}

/*
 * This function can be customized by defining on jsp function getLastFocusableItemInTableRowCallback.
 * It receive parameters table id and row and should return some table element or nothing.
 *
 * For example:
 * function getLastFocusableItemInTableRowCallback(tableId, row) {
 * 		if ("TransferTable" == tableId)
 *		{
 *      	return row.getRowItem("RECEIVE_REQ");
 *      }
 * }
 */
Table.prototype.getLastFocusableItemInRow = function( row )
{
	if ( window.getLastFocusableItemInTableRowCallback )
	{
		var item = getLastFocusableItemInTableRowCallback(this.htmlElement.id, row);
		if (item)
		{
			return item;
		}
	}
	return row.getLastFocusableItem();
}

/**
 * Insert a new row into the table.  If selectedRow is specified, then the new row is
 * inserted before selectedRow.  Otherwise, the new row is appended after the last row.
 * @param {TableRow} row The new table row to be inserted.
 * @param {TableRow} [selectedRow] The currently selected row.
 */
Table.prototype.insertRow = function( row, selectedRow, skipSetFocus )
{
    // Add the row id
    var cell = document.createElement( "td" );
    cell.className = "table_hidden_column";
    var hiddenRowIdElt = BaseComponent.createHiddenField( this.htmlElement.id + "_ROW_ID", row.getId() );
    cell.appendChild( hiddenRowIdElt );
    row.htmlElement.appendChild( cell );
    var insertIndex = -1;

    var tbody = this.getTableBody();
    if( selectedRow )
    {
        tbody.insertBefore( row.htmlElement, selectedRow.htmlElement );
        insertIndex = selectedRow.getIndex() -1;
    }
    else
    {
        tbody.appendChild( row.htmlElement );
        insertIndex = this.getNumRows();
    }
	if(fieldChangeMonitor){
    	fieldChangeMonitor.registerNonKeyFieldChange( this.htmlElement.id  );
   	}

    row.htmlElement.inserted = true;

    var chkbx = document.getElementById( this.htmlElement.id + "$SELECT_ALL_CHECKBOX" );
    if( chkbx )
    {
        // Make sure the select all checkbox (if there is one) is enabled if we have added the first row
        if( this.getNumRows() == 1 )
            chkbx.disabled = false;

        // If select all is checked, check this row
        if( chkbx.checked )
        {
            var elt = row.getRowItem( this.htmlElement.id + "$rowselect" );
            var checkBox = CheckBox.bindToElt( elt );
            checkBox.setChecked( true );
        }
    }

    // If radio button columns are present, adjust selected indexes
    this.adjustSelectedRadioIndex( insertIndex, true );
    if(!skipSetFocus)
    	this.getFirstFocusableItemInRow(row).focus();
}



/**
 * Insert a new row before (above) the currently selected row.  The row will not be inserted if no row is currently selected.
 * @param {TableRow} row The new row to be inserted.
 */
Table.prototype.insertBeforeSelected = function( row )
{
    if( this.validateRowSelected() )
    {
        var selectedRow = this.getSelectedRow();
        this.insertRow( row, selectedRow );
        this.updateSelectedRowIndexValue();
    }
}

/**
 * Insert a new row after (below) the currently selected row.  The row will not be inserted if no row is currently selected.
 * @param {TableRow} row The new row to be inserted.
 */
Table.prototype.insertAfterSelected = function( row )
{
    if( this.validateRowSelected() )
    {
        var index = this.getSelectedRowIndex();
        var nextRow = this.getRow( index + 1 );
        this.insertRow( row, nextRow );
    }
}

/**
 * Delete all rows from the table.
 */
Table.prototype.deleteAllRows = function()
{
    if( this.validateHasRowToRemove() )
    {
        if( PageHelper.confirm( PageHelper.messages.removeAllRowsTitle, PageHelper.messages.removeAllRows ) )
        {
            var selectedRowIndex = this.getSelectedRowIndex();
            for( var i=this.getNumRows()-1; i > -1; i-- )
            {
                if( i == selectedRowIndex )
                    this.deleteSelectedRow();
                else
                    this.deleteRowImpl( i );
            }
        }
    }
}

/**
 * Delete the row having the specified index.
 * @param index The index of the row to be deleted.
 */
Table.prototype.deleteRow = function( index )
{
    // We need to call deleteSelectedRow if the specified index matches the
    // index of the selected row. This insures the we do the proper bookeeping when
    // deleting the selected row.
    if( this.validateHasRowToRemove() )
    {
        if( index == this.getSelectedRowIndex() )
        {
            this.deleteSelectedRow();
            return;
        }
        this.deleteRowImpl( index );
        this.updateSelectedRowIndexValue();
    }
}

// (internal table use only) Deletes the row at the specified index.
Table.prototype.deleteRowImpl = function( index )
{
    var numRows = this.getNumRows();
    if( (numRows > 0) && (numRows > index) )
    {
        var tbody = this.getTableBody();
        tbody.deleteRow( index );
        fieldChangeMonitor.registerNonKeyFieldChange( this.htmlElement.id  );
        if( (numRows - 1) == 0 )
        {
            // If there are no rows left, make sure we uncheck the select all
            // checkbox if it is currently checked.
            var chkbx = document.getElementById( this.htmlElement.id + "$SELECT_ALL_CHECKBOX" );
            if( chkbx )
            {
                chkbx.checked = false;
                chkbx.disabled = true;
            }
        }

        // If radio button columns are present, adjust selected indexes
        this.adjustSelectedRadioIndex( index, false );
        return true;
    }
    return false;
}

// (internal use only) Each column of radio buttons has a hidden input field that stores the row index of the currently selected
// radio.  This index may need to be adjusted if a row is added or removed.  This method will make the necessary adjustment for
// each radio button column present in the table.
Table.prototype.adjustSelectedRadioIndex = function( affectedRowIndex, increment )
{
    //PageHelper.logMsg( "affectedRowIndex=" + affectedRowIndex );
    if(  this.htmlElement.radioIndexList )
    {
        var fieldElt = null;
        var indexField = null;
        for( var i=0; i <  this.htmlElement.radioIndexList.getSize(); i++ )
        {
            fieldElt = this.htmlElement.radioIndexList.get( i );
            if( fieldElt )
            {
                if( !increment )
                {
                    if( fieldElt.value > affectedRowIndex )
                        fieldElt.value = parseInt( fieldElt.value )  - 1;
                    else if( fieldElt.value == affectedRowIndex )
                        fieldElt.value = -1;
                }
                else
                {
                    if( fieldElt.value >= affectedRowIndex )
                        fieldElt.value = parseInt( fieldElt.value ) + 1;
                }
            }
        }
    }
}

/**
 * Delete the currently selected row. This method does nothing if the table is empty, or if no
 * row is currently selected.
 */
Table.prototype.deleteSelectedRow = function()
{
    if( this.validateHasRowToRemove() && this.validateRowSelected() )
    {
        if( this.deleteRowImpl( this.getSelectedRowIndex() ) )
        {
            this.htmlElement.currentlySelectedRow = null;
            this.htmlElement.currentlySelectedRowClassName = null;
            this.updateSelectedRowIndexValue();
        }
    }
}

/**
 * Select the row having the specified index. The row will not be selected if it is disabled.  No row
 * will be selected if the index is out of range.
 * @param {number} index The row index to be selected.
 * @return {Boolean} true if the row was selected, false otherwise.
 */
Table.prototype.selectRowByIndex = function( index )
{
    if( index > -1 )
    {
        var row = this.getRow( index );
        if( row  && !row.isDisabled() )
            return this.selectRow( row.htmlElement );
    }
    return false;
}

/**
 * Select the specified row.
 * @param {TableRow} row The row to be selected (must be a row already contained within the table).
 * @return {Boolean} true if the row was selected, false otherwise.
 */
Table.prototype.selectRow = function( row )
{
    var rowSelected = false;
    // Unselect currently selected row
    if( this.htmlElement.currentlySelectedRow )
    {
        var sRow = this.htmlElement.currentlySelectedRow;
        sRow.className = this.htmlElement.currentlySelectedRowClassName;
        sRow.style.backgroundColor = this.htmlElement.currentlySelectedRowBackgroundColor;

        if( sRow != row )
        {
            this.htmlElement.currentlySelectedRow = row;
            this.htmlElement.currentlySelectedRowClassName = row.className;
            this.htmlElement.currentlySelectedRowBackgroundColor = row.style.backgroundColor;
            row.style.backgroundColor = "";
            row.className = "table_selected_row";
            rowSelected = true;
        }
        else
        {
            this.htmlElement.currentlySelectedRow = null;
            this.htmlElement.currentlySelectedRowClassName = null;
            this.htmlElement.currentlySelectedRowBackgroundColor = "";
        }
        this.htmlElement.previouslySelectedRow = sRow;
    }
    else
    {
        this.htmlElement.currentlySelectedRow = row;
        this.htmlElement.currentlySelectedRowClassName = row.className;
        this.htmlElement.currentlySelectedRowBackgroundColor = row.style.backgroundColor;
        row.style.backgroundColor = "";
        row.className = "table_selected_row";
        rowSelected = true;
    }

    // Set the selected row index value for submission with the form
    this.updateSelectedRowIndexValue();
    return rowSelected;
}

Table.prototype.updateSelectedRowIndexValue = function()
{
    var sriElt = document.getElementById( this.htmlElement.id + "_SELECTED_ROW_INDEX" );
    if( sriElt )
    {
        if( this.htmlElement.currentlySelectedRow )
            sriElt.value = this.htmlElement.currentlySelectedRow.sectionRowIndex;
        else
            sriElt.value = -1;
    }
}

Table.prototype.addRadioIndexField = function( id )
{
    if( !this.htmlElement.radioIndexList )
        this.htmlElement.radioIndexList = new List();

    var elt = document.getElementById( id );
    if( elt )
        this.htmlElement.radioIndexList.add( elt );
}

Table.prototype.selectAllRows = function( val )
{
    var numRows = this.getNumRows();
    if( numRows > 0 )
    {
        var tbody = this.getTableBody();
        var rows = tbody.rows;
        var tableRow = null;
        var hiddenInput = null;
        var checkboxval = null;
        var idIndex = 0;
        for( var i=0; i < numRows; i++ )
        {
            tableRow = rows.item( i );
            if( isNaN( tableRow.rowId ) )
            {
                // Search for the next checkbox. This is needed since one or more rows may have been deleted.
                do
                {
                    hiddenInput = document.getElementById( "_CHECKVAL" + this.htmlElement.id + "$rowselect[" + idIndex + "]" );
                    idIndex++;
                }while( !hiddenInput );
            }
            else
            {
                hiddenInput = document.getElementById( "_CHECKVAL" + this.htmlElement.id + "$rowselect[" + tableRow.rowId + "]" );
            }

            if( hiddenInput )
            {
                checkbox = hiddenInput.previousSibling;
                if( !(checkbox.disabled || checkbox.readOnly) )
                {
                    checkbox.checked = val;
                    if( checkbox.checked)
                        hiddenInput.value = "true";
                    else
                        hiddenInput.value = "false";
                }
            }
            else
                numRows++;
        }
    }
}

// ------------------- Child form processing functions ----------------------------

/**
 * Open the details screen associated with the table row containing the specified link element.
 * @param {String} formId The id of the form that contains the table.
 * @param {String} commandName The name of the command that will execute the navigation to the details screen.
 * @param {HTMLLinkElement} linkElt The table row details link element. 
 */
Table.prototype.modifyDetails = function( formId, commandName, linkElt )
{
    var linkObj = Link.bindToElt( linkElt );
    var rowId = linkObj.getRowId();
    var rowIndex = linkObj.getRowIndex();

    PageHelper.addHiddenFormField( formId, "_TABLE_ID", this.getComponentId() );
    PageHelper.addHiddenFormField( formId, "_ROW_INDEX", (rowIndex + "") );
    PageHelper.addHiddenFormField( formId, "_ROW_ID", rowId );
    PageHelper.addHiddenFormField( formId, "_ACTION", "_MODIFY" );
    PageHelper.doCommand( formId, commandName );
}

/**
 * Call the specified command to perform a server-side insert of a new row.
 * @param {String} formId The id of the form that contains the table. 
 * @param {String} commandName The name of the command that will execute the table row insert.
 */
Table.prototype.serverInsertNew = function( formId, commandName )
{
    this.insertRowImpl( formId, commandName, "_INSERT_NEW" );
}

/**
 * Call the specified command to perform a server-side insert of a new row before (above) the currently
 * selected row.  This method does nothing if no row is selected.
 * @param {String} formId The id of the form that contains the table. 
 * @param {String} commandName The name of the command that will execute the table row insert.
 */
Table.prototype.serverInsertBefore = function( formId, commandName )
{
    if( this.validateRowSelected() )
    {
        var selectedRowIndex = this.getSelectedRowIndex();
        this.insertRowImpl( formId, commandName, "_INSERT_BEFORE", selectedRowIndex  );
    }
}

/**
 * Call the specified command to perform a server-side insert of a new row after (below) the currently
 * selected row.  This method does nothing if no row is selected.
 * @param {String} formId The id of the form that contains the table. 
 * @param {String} commandName The name of the command that will execute the table row insert.
 */
Table.prototype.serverInsertAfter = function( formId, commandName )
{
    if( this.validateRowSelected() )
    {
        var selectedRowIndex = this.getSelectedRowIndex();
        this.insertRowImpl( formId, commandName, "_INSERT_AFTER", selectedRowIndex  );
    }
}

Table.prototype.insertRowImpl = function( formId, commandName, commandAction, index )
{
    PageHelper.addHiddenFormField( formId, "_TABLE_ID", this.getComponentId() );
    PageHelper.addHiddenFormField( formId, "_ACTION", commandAction );
    if( !isNaN(index) )
        PageHelper.addHiddenFormField( "MAIN", "_ROW_INDEX", ("" + index) );
    PageHelper.doCommand( formId, commandName );
}

/**
 * Call the specified command to perform a server-side removal of all selected rows from a multi-select table.
 * In a multi-select table, row selection is indicated by the checked state of checkboxes in the multi-select checkbox
 * column.  This method does nothing if no rows are selected.
 * @param {String} formId The id of the form that contains the table. 
 * @param {String} commandName The name of the command that will execute the row delete.
 */
Table.prototype.serverRemoveSelectedRows = function( formId, commandName )
{
    if( this.validateHasRowToRemove() && this.validateHasCheckedRow() )
    {
        if( PageHelper.confirm( PageHelper.messages.removeSelectedRowsTitle, PageHelper.messages.removeSelectedRows ) )
        {
            PageHelper.addHiddenFormField( formId, "_TABLE_ID", this.getComponentId() );
            PageHelper.addHiddenFormField( formId, "_ACTION", "_REMOVE_SELECTED_ROWS" );
            PageHelper.doCommand( formId, commandName );
        }
    }
}

/**
 * Call the specified command to perform a server-side removal of single selected row from a single-selection table.
 * This method does nothing if no rows are selected.
 * @param {String} formId The id of the form that contains the table. 
 * @param {String} commandName The name of the command that will execute the row delete.
 */
Table.prototype.serverRemoveSelectedRow = function(formId, commandName) {
    if (this.validateHasRowToRemove() && this.validateRowSelected()) {
        if (PageHelper.confirm(PageHelper.messages.removeSelectedRowsTitle, PageHelper.messages.removeSelectedRows)) {
            PageHelper.addHiddenFormField(formId, "_TABLE_ID", this.getComponentId());
            PageHelper.addHiddenFormField(formId, "_ACTION", "_REMOVE_SELECTED_ROWS");
            PageHelper.addHiddenFormField(formId, "_ROW_ID", this.getSelectedRowIndex());
            PageHelper.doCommand(formId, commandName);
        }
    }
}

/**
 * Call the specified command to perform a server-side removal of all rows from the table.
 * @param {String} formId The id of the form that contains the table. 
 * @param {String} commandName The name of the command that will execute the row delete.
 */
Table.prototype.serverRemoveAllRows = function( formId, commandName )
{
    if( this.validateHasRowToRemove() )
    {
        if( PageHelper.confirm( PageHelper.messages.removeAllRowsTitle, PageHelper.messages.removeAllRows ) )
        {
            PageHelper.addHiddenFormField( formId, "_TABLE_ID", this.getComponentId() );
            PageHelper.addHiddenFormField( formId, "_ACTION", "_REMOVE_ALL_ROWS" );
            PageHelper.doCommand( formId, commandName );
        }
    }
}

/**
 * Determines if there are any selected rows in a multi-select table.
 * @return {Boolean} true if this is a multi-select table and any row select checkbox is checked.
 */
Table.prototype.hasCheckedRow = function()
{
    var numRows = this.getNumRows();
    if( numRows > 0 && this.isMultiSelect() )
    {
        var tbody = this.getTableBody();
        var rows = tbody.rows;
        var tableRow = null;
        var hiddenInput = null;
        var checkboxval = null;
        var idIndex = 0;
        for( var i=0; i < numRows; i++ )
        {
            tableRow = rows.item( i );
            if( isNaN( tableRow.rowId ) )
            {
                // Search for the next checkbox. This is needed since one or more rows may have been deleted.
                do
                {
                    hiddenInput = document.getElementById( "_CHECKVAL" + this.htmlElement.id + "$rowselect[" + idIndex + "]" );
                    idIndex++;
                }while( !hiddenInput );
            }
            else
            {
                hiddenInput = document.getElementById( "_CHECKVAL" + this.htmlElement.id + "$rowselect[" + tableRow.rowId + "]" );
            }

            if( hiddenInput )
            {
                checkbox = hiddenInput.previousSibling;
                    if( checkbox.checked)
                        return true;
            }
        }
    }
    return false;
}

Table.prototype.validateRowSelected = function( title, message )
{
    if( !message)
        message = PageHelper.messages.noRowsSelected;
    if( !this.getSelectedRow() )
    {
        PageHelper.alert( title, message );
        return false;
    }
    return true;
}

Table.prototype.validateHasCheckedRow = function( title, message )
{
    if( this.hasCheckedRow() )
        return true;
    else
    {
        if( !message )
            message = PageHelper.messages.noRowsSelected;
        PageHelper.alert( title, message );
    }
    return false;
}

Table.prototype.validateHasRowToRemove = function( title, message )
{
    if( this.getNumRows() > 0 )
        return true;
    if( !message )
        message = PageHelper.messages.noRowsToRemove;
    PageHelper.alert( title, message );
    return false;
}

/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: /main/1$"


function TableCell()
{
    this.htmlElement = document.createElement( "td" );
}

TableCell.create = function()
{
    return new TableCell();
}

TableCell.prototype.setComponentId = function( id )
{
    this.htmlElement.componentId = id;
}

TableCell.prototype.getComponentId = function()
{
    return this.htmlElement.componentId;
}
/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: /main/21$"

/*
    DOM API NOTE: Support for HTML DOM Level 1 varies across browsers.  As a result, several methods use the low level
    DOM intefaces instead of HTML DOM interfaces.  One example is the method "insertCell" defined on HTMLTableRowElement.  When
    called from ie the returned cell reference is always null.  Mozilla returns the cell correctly.  To support both browsers,
    appendChild must be used to insert the cell into the row.
*/

function TableRow( elt, size )
{
    if( !elt )
    {
        this.htmlElement = document.createElement( "tr" );

        // Must define our own row index when creating a row from scratch (as opposed to binding to an existing)
        // since the DOM row index "sectionRowIndex" is not usable until the row has been inserted
        // into the table.  "rowId" will be used by addRowItem to create a unique component id.
        // addRowItem is only called from createTemplateRow, which simply creates a "stand-alone" row for inserting
        // into the table.
        this.htmlElement.rowId = -1;
        if( size )
        {
            var cell = null;
            for( var i=0; i < size; i++ )
            {
                cell = TableCell.create();
                this.htmlElement.appendChild( cell.htmlElement );
            }
        }
        this.htmlElement.inserted = false;
    }
    else
    {
        this.htmlElement = elt;
        this.htmlElement.inserted = true;
    }
}

// Create the table row given a list of column ids.  This list is created (written) by the table row tag based on
// the table's column info.  The ids are used to set the "componentId" property on each cell, which is used to find
// the appropriate cell when adding a row item (see addRowItem).  The point of all this is to allow adding row items based
// an a string identifier instead of by cell index.  This provides the flexibility of adding and retrieving a row item without foreknowledge
// of the cell's location.
TableRow.createFromIds = function( colIds )
{
    var row = new TableRow();
    var size = colIds.getSize();
    var id = null;
    var cell = null;
    for( var i=0; i < size; i++ )
    {
        id = colIds.get( i );
        cell = TableCell.create();
        cell.setComponentId( id );
        row.addCell( cell.htmlElement );
    }
    return row;
}

TableRow.create = function( size )
{
    return new TableRow( null, size );
}

TableRow.bindToElt = function( elt )
{
    return new TableRow( elt );
}

TableRow.prototype.setClassName = function( className )
{
    this.htmlElement.className = className;
}

TableRow.prototype.getIndex = function()
{
    if( this.htmlElement.inserted )
        return this.htmlElement.sectionRowIndex;
    else
        return -1;
}

TableRow.prototype.getId = function()
{
    var retId = null;
    if( isNaN(this.htmlElement.rowId) )
    {
        var rowElt = this.htmlElement;
        var tableCellNodeList = null;
        var cellElt = null;
        var rowIdFound = false;
        for( var i=0; i < rowElt.cells.length && (!rowIdFound); i++ )
        {
            tableCellNodeList = rowElt.cells[i].getElementsByTagName( "INPUT" );
            if( tableCellNodeList )
            {

                for( var j=0; j < tableCellNodeList.length && (!rowIdFound); j++ )
                {
                    cellElt = tableCellNodeList[j];
                    if( (cellElt.type == "hidden") && (cellElt.className == "rowid") )
                    {
                        retId = cellElt.value;
                        this.htmlElement.rowId = retId;
                        rowIdFound = true;
                    }
                }
            }
        }
        if( !retId )
            return this.htmlElement.sectionRowIndex;
        else
            return retId;
    }
    else
        return this.htmlElement.rowId;
}

// Note: elt is assumed to be a table cell element
TableRow.prototype.addCell = function( elt )
{
    this.htmlElement.appendChild( elt );
}

TableRow.prototype.addRowItem = function( rowItem )
{
    // Append the row item to the first table cell that has no children
    var nodeList = this.htmlElement.getElementsByTagName( "td" );
    var cell = null;
    var done = false;
    var componentId = null;
    var idIndex = -1;
    for( var i=0; i < nodeList.length && !done; i++ )
    {
        cell = nodeList.item( i );

        if( cell.componentId ) // Only applicable to dynamically inserted rows
        {
            // First remove the prefix from cell.componentId so we can compare against row item names
            componentId = cell.componentId;

            if( componentId == rowItem.getComponentId() )
            {
                if( !cell.hasChildNodes() )
                {
                    rowItem.htmlElement.row = this;
                    if( rowItem.htmlElement.parentClassName )
                        cell.className = rowItem.htmlElement.parentClassName;
                    rowItem.addToTableCell( cell, this.htmlElement.rowId );
                }
                done = true;
            }
        }
    }
}


/**
 * @returns {Boolean} true if the TableRow is disabled, false otherwise.
 */
TableRow.prototype.isDisabled = function()
{
    return ( this.htmlElement.className == "table_disabled_row" );
}

/**
 * Enables/disables this table row.  All nested UI components are also disabled.
 * 
 * @param {Boolean} bool true to disable, false to enable.
 */
TableRow.prototype.setDisable = function( bool )
{
    if( !(bool == this.isDisabled() ) ) // Short circuit when possible
    {
        if( bool )
        {
            if( !this.htmlElement.prevClassName )
            {
                this.htmlElement.prevClassName = this.htmlElement.className;
                this.htmlElement.prevBackgroundColor = this.htmlElement.style.backgroundColor;
                this.htmlElement.style.backgroundColor = "";
            }
            this.htmlElement.className = "table_disabled_row";
        }
        else
        {
            if( !this.htmlElement.prevClassName )
                this.htmlElement.prevClassName = TableRow.chooseClassName( this.getIndex() );

            this.htmlElement.className = this.htmlElement.prevClassName;
            this.htmlElement.style.backgroundColor = this.htmlElement.prevBackgroundColor;
            this.htmlElement.prevClassName = null;
            this.htmlElement.prevBackgroundColor = null;
        }

        var nodeList = this.htmlElement.getElementsByTagName( "td" );
        var cell = null;
        var childNodes = null;
        var rowItem = null;
        var node = null;

        for( var i=0; i < nodeList.length; i++ )
        {
            cell = nodeList.item( i );
            if( cell.hasChildNodes() )
            {
                childNodes = cell.childNodes;
                for( var j=0; j < childNodes.length; j++ )
                {
                    node = childNodes.item( j );
                    if( node.nodeType == 1 )
                    {
                        if( BaseComponent.isInput( node ) )
                        {
                            if( node.type == "text" )
                                rowItem = TextField.bindToElt( node );
                            else if( node.type == "checkbox" )
                                rowItem = CheckBox.bindToElt( node );
                            else if( node.type == "radio" )
                                rowItem = RadioButton.bindToElt( node );
                        }
                        else if( BaseComponent.isSelect( node ) )
                            rowItem = Select.bindToElt( node );

                        if( rowItem && rowItem.setDisable )
                            rowItem.setDisable( bool );
                        rowItem = null;
                    }
                }
            }
        }
    }
}

/**
 * Set the background color of the table row.
 * 
 * @param {String} color A CSS legal color identifier.
 */
TableRow.prototype.setBackgroundColor = function( color )
{
    this.htmlElement.style.backgroundColor = color;
}

/**
 * Get the nested UI component having the specified id.
 * 
 * @param {String} id The component id attribute value.
 */
TableRow.prototype.getRowItem = function( id )
{
    var nodeList = this.htmlElement.getElementsByTagName( "td" );
    var oItem = null;
    var cell = null;
    var componentId = null;
    var childNodes = null;
    var spanNodes = null;
    var node = null;
    var tmpId = null;

    for( var i=0; i < nodeList.length; i++ )
    {
        cell = nodeList.item( i );
        if( cell.hasChildNodes() )
        {
            childNodes = cell.childNodes;
            for ( var j=0; j < childNodes.length; j++ )
            {
                oItem = childNodes.item( j );
                if ( oItem.id ) {
                    tmpId = BaseComponent.removeComponentIdIndex( oItem.id );
                    if ( id == tmpId ) {
                        return oItem;
                    }
                } else if ( BaseComponent.isSpan(oItem) && oItem.hasChildNodes() ) {
                    spanNodes = oItem.childNodes;
                    for( var k=0; k < spanNodes.length; k++ ) {
                        node = spanNodes.item( k );
                        if ( node.id ) {
                            tmpId = BaseComponent.removeComponentIdIndex( node.id );
                            if ( id == tmpId ) {
                                return node;
                            }
                        }
                    }
                }
            }
        }
    }
    return null;
}

function getFocusableElement( element )
{
    if( element.id && !element.disabled && element.style.display != "none")
    {
        if (BaseComponent.isSpan(element))
        {
            if (element.firstChild)
            {
                return getFocusableElement(element.firstChild);
            }
            return null;
        }

        if ( element.type == "radio" )
        {
            if (!element.checked) return null;
        }

        if ( element.type == "hidden" )
        {
            return null;
        }

            if( element.type == "text" && element.readOnly)
        {
            return null;
        }

        return element;
    }
    return null;
}

TableRow.prototype.getLastFocusableItem = function( )
{
    var nodeList = this.htmlElement.getElementsByTagName( "td" );
    var cell = null;
    var childNodes = null;
    var node = null;

    for( var i=nodeList.length - 1; i >= 0; i-- )
    {
        cell = nodeList.item( i );
        if( cell.hasChildNodes() )
        {
            childNodes = cell.childNodes;
            for( var j=0; j < childNodes.length; j++ )
            {
                node = childNodes.item( j );
                node = getFocusableElement(node);
                if( node )
                {
                    return node;
                }
            }
        }
    }
    return null;
}

TableRow.prototype.getFirstFocusableItem = function( )
{
    var nodeList = this.htmlElement.getElementsByTagName( "td" );
    var cell = null;
    var childNodes = null;
    var node = null;

    for( var i=0; i < nodeList.length; i++ )
    {
        cell = nodeList.item( i );
        if( cell.hasChildNodes() )
        {
            childNodes = cell.childNodes;
            for( var j=0; j < childNodes.length; j++ )
            {
                node = childNodes.item( j );
                node = getFocusableElement(node);
                if( node )
                {
                    return node;
                }
            }
        }
    }
    return null;
}

/**
 * Get the row select check box if this row is in a multi-select table.
 * 
 * @return {CheckBox} The row select check box, or null if this row is in a single-select table.
 */
TableRow.prototype.getRowSelectCheckBox = function()
{
    var field = null;
    var id = this.htmlElement.parentNode.parentNode.id + "$rowselect";
    var rowItem = this.getRowItem( id );
    if( rowItem )
    {
        if( BaseComponent.isInputCheckBox( rowItem ) )
            field = CheckBox.bindToElt( rowItem );
    }
    return field;
}

/**
 * Get the CheckBox having the given id.
 * 
 * @return {CheckBox} The check box, or null if no check box is found for the given id.
 */
TableRow.prototype.getCheckBox = function( id )
{
    var field = null;
    var rowItem = this.getRowItem( id );
    if( rowItem )
    {
        if( BaseComponent.isInputCheckBox( rowItem ) )
            field = CheckBox.bindToElt( rowItem );
    }
    return field;
}

/**
 * Get the TextField having the given id.
 * 
 * @return {TextField} The text input field, or null if no text input field is found for the given id.
 */
TableRow.prototype.getTextField = function( id )
{
    var field = null;
    var rowItem = this.getRowItem( id );
    if( rowItem )
    {
        if( BaseComponent.isInputText( rowItem ) )
            field = TextField.bindToElt( rowItem );
    }
    return field;
}

/**
 * Get the Text having the given id.
 * 
 * @return {Text} The text component, or null if no text component is found for the given id.
 */
TableRow.prototype.getText = function( id )
{
    var field = null;
    var rowItem = this.getRowItem( id );
    if( rowItem )
        field = Text.bindToElt( rowItem );

    return field;
}

/**
 * Get the Select having the given id.
 * 
 * @return {Select} The select list component, or null if no select list is found for the given id.
 */
TableRow.prototype.getSelect = function( id )
{
    var field = null;
    var rowItem = this.getRowItem( id );
    if( rowItem )
    {
        if( BaseComponent.isSelect( rowItem ) || BaseComponent.isSpan( rowItem ) )
            field = Select.bindToElt( rowItem );
    }
    return field;
}

/**
 * Get the Link having the given id.
 * 
 * @return {Link} The link component, or null if no link is found for the given id.
 */
TableRow.prototype.getLink = function( id )
{
    var field = null;
    var rowItem = this.getRowItem( id );
    if( rowItem )
    {
        if( BaseComponent.isLink( rowItem ) )
            field = Link.bindToElt( rowItem );
    }
    return field;
}

TableRow.chooseClassName = function( index )
{
    if( (index % 2) == 0 )
        return "table_even_row";
    else
        return "table_odd_row";
}
/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: Text.js/main/9$"

// -------------------------------------------------------------------------
// --------------------------- Component Construction & Initialization
// -------------------------------------------------------------------------

function Text( id, elt )
{
    // Initialize the base compon ent
    var element = null;
    if( !elt )
        element = document.getElementById( id );
    else
        element = elt;
    this.initializeBaseComponent( element, "Text" );
}
Text.prototype = new BaseComponent();
Text.prototype.constructor = Text;

Text.create = function( id, text, name, value )
{
    var span = document.createElement( "span" );
    if( id ) span.id = id;
    if( !text ) text = "";
    span.appendChild( document.createTextNode( text ) );
    if( name )
        span.appendChild( BaseComponent.createHiddenField( name, value ) );
    return new Text( null, span );
}

Text.bindToId = function( id )
{
    return new Text( id );
}


Text.bindToElt = function( elt )
{
    return new Text( null, elt );
}

// -------------------------------------------------------------------------
// --------------------------- Accessors & Mutators
// -------------------------------------------------------------------------

/**
 * Set the text value to be displayed.  This value will also be used as the
 * submit value if this Text submits a value.
 * @param {String} text The text to display and optionally submit.
 */
Text.prototype.setValue = function( text )
{
    var name = BaseComponent.removeComponentIdIndex(this.getId());

    if ((this.htmlElement.textContent) && (typeof (this.htmlElement.textContent) != "undefined")) {
        this.htmlElement.textContent = text;
    } else {
        this.htmlElement.innerText = text;
    }
    this.setHiddenValue(text, name);
}

/**
 * Get the displayed text value.
 * @return {String} The display text.
 */
Text.prototype.getValue = function()
{
    return (this.htmlElement.textContent || this.htmlElement.innerText);
}

/**
 * Set the hidden value associated with the text component.
 * @param {String} value The hidden value that will be submitted.
 * @param {String} [name] A new hidden input field will be created with this name.
 */
Text.prototype.setHiddenValue = function( value, name )
{
    var hiddenNode = BaseComponent.getHiddenInputNode( this.htmlElement ) || BaseComponent.getHiddenInputNode( this.htmlElement.parentElement );
    if( hiddenNode )
        hiddenNode.value = value;
    else if( name )
    {
        // Create the hidden field dynamically to handle the case where
        // this field is used with an ItemMap but the ItemMap was not
        // present in the model.  This is the case on an application clear (i.e.
        // we don't require an empty ItemMap to be added, just like we don't require
        // an empty string to be added for a blank text field).
        var hidden = BaseComponent.createHiddenField( name, value );
        this.htmlElement.appendChild( hidden );
    }
}

/**
 * Get the hidden input value for this text.
 * @return {String} The hidden input field value.
 */
Text.prototype.getHiddenValue = function()
{
    var hiddenNode = BaseComponent.getHiddenInputNode( this.htmlElement ) || BaseComponent.getHiddenInputNode( this.htmlElement.parentElement );
    if( hiddenNode )
        return hiddenNode.value;
    return null;
}

/**
 * Set the left margin
 * @param {number} Number of ems to offset the text to the right.
 */
Text.prototype.setLeftMargin = function( margin )
{
    this.htmlElement.style.marginLeft = margin + "em";
    this.htmlElement.style.width = "100%";
}
/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: /main/4$"


// -------------------------------------------------------------------------
// --------------------------- Component Construction & Initialization
// -------------------------------------------------------------------------
function TextArea( id, elt )
{
    // Initialize the base compon ent
    var element = null;
    if( !elt )
        element = document.getElementById( id );
    else
        element = elt;

    this.initializeBaseComponent( element, "TextArea" );

}
TextArea.prototype = new BaseComponent();
TextArea.prototype.constructor = TextArea;

TextArea.create = function( id, name, value )
{
    var elt = document.createElement( "textarea" );
    if( id ) elt.id = id;
    if( name ) elt.name = name;
    if( value ) elt.value = value;
    else elt.value = "";
    return new TextArea( null, elt );
}

TextArea.bindToId = function( id )
{
    var retObj = new TextArea( id );
    return retObj;
}

TextArea.bindToElt = function( elt )
{
    return new TextArea( null, elt );
}

TextArea.activateTextArea = function( textAreaElt, e)
{
        TextArea.bindHTMLEvents( textAreaElt );
        if( e != null )
        {
            // Handle activation initiated by putting focus in the select box.
            TextArea.bindToElt( textAreaElt ).handleFocus( e );
        }
}

TextArea.prototype.addToTableCell = function( tableCellElt, rowId )
{
    this.htmlElement.id = this.getIndexedId( rowId );
    tableCellElt.appendChild( this.htmlElement );
}

// -------------------------------------------------------------------------
// --------------------------- Intrinsic & Extended Events Binding
// -------------------------------------------------------------------------

TextArea.bindHTMLEvents = function( elt )
{
    elt.onfocus = new Function( "e", "if( !e ) e = window.event; TextArea.bindToElt( this ).handleFocus( e );" );
    elt.onblur = new Function( "e", "if( !e ) e = window.event; TextArea.bindToElt( this ).handleFocusLost( e );" );
    elt.onkeydown = new Function( "e", "if( !e ) e= window.event; TextArea.bindToElt( this ).handleKeyDown( e );" );
    elt.onchange = new Function( "e", "if( !e ) e= window.event; TextArea.bindToElt( this ).handleValueChange( e );" );
    elt.onkeypress = new Function( "e", "if( !e ) e= window.event; TextArea.bindToElt( this ).handleKeyPress( e );" );
}

TextArea.addExtEvents = function( extEventsProcessor )
{
    extEventsProcessor.addEvent( "onFocus" );
    extEventsProcessor.addEvent( "onFocusLost" );
    extEventsProcessor.addEvent( "onKeyDown" );
    extEventsProcessor.addEvent( "onValueChange" );
    extEventsProcessor.addEvent( "onTabOut" );
    extEventsProcessor.addEvent( "onKeyPress" );
}


// -------------------------------------------------------------------------
// --------------------------- Accessors & Mutators
// -------------------------------------------------------------------------

/**
 * Set the number of rows to be displayed.
 * @param {number} rows The number of rows displayed.
 */
TextArea.prototype.setRows = function( rows )
{
    this.htmlElement.rows = rows;
}

/**
 * Set the number of columns to be displayed.
 * @param {number} cols The number of columns displayed.
 */
TextArea.prototype.setCols = function( cols )
{
    this.htmlElement.cols = cols;
}

/**
 * Set the maximum number of characters that the text area can contain.
 * @param {string} maxLength The maximum number of characters.
 */
TextArea.prototype.setMaxLength = function( maxLength )
{
	this.htmlElement.maxLength = maxLength;
}

/**
 * Enables/disables this text area.  The field value is still submitted when disabled.
 * 
 * @param {Boolean} bool true to disable, false to enable.
 */
TextArea.prototype.setDisable = function( bool )
{
    if ( bool )
    {
        this.htmlElement.readOnly = true;
        this.htmlElement.tabIndex = -1;
        this.htmlElement.style.backgroundColor = "#B7B7B7";
    }
    else
    {
        this.htmlElement.readOnly = false;
        this.htmlElement.tabIndex = 0;
        this.htmlElement.style.backgroundColor = "#FFFFFF";
    }
}

/**
 * Set the name of this text area.
 * @param name The text area name.
 */
TextArea.prototype.setName = function( name )
{
    this.htmlElement.name = name;
}

/**
 * Set the input value.
 * @param {String} text The text input value.
 */
TextArea.prototype.setValue = function( text )
{
    this.htmlElement.value = text;
    if( this.isForceUpperCase() )
    {
        this.htmlElement.value = this.htmlElement.value.toUpperCase();
    }
}

/**
 * Get the text area value.
 * @return {String} The text area value.
 */
TextArea.prototype.getValue = function()
{
    if( this.isForceUpperCase() )
        return this.htmlElement.value.toUpperCase();
    else
        return this.htmlElement.value;
}

/**
 * Apply/remove uppercase for all text in the text area.  The transform
 * is applied to the submitted value also.
 * @param {Boolean} val true uppercases, false removes uppercasing.
 */
TextArea.prototype.setUppercase = function( val )
{
    if( val )
    {
        this.htmlElement.style.textTransform = "uppercase";
        this.htmlElement.value = this.htmlElement.value.toUpperCase();
    }
    else
        this.htmlElement.style.textTransform = "none";
}

// Will cause a focus event to fire on the element.
/**
 * Set focus to this text area.
 */
TextArea.prototype.setFocus = function()
{
    this.htmlElement.focus();
}

/**
 * @return {Boolean} true if the text area is disabled, false otherwise.
 */
TextArea.prototype.isDisabled = function()
{
    return this.htmlElement.readOnly;
}

/**
 * @return {Boolean} true if uppercasing is applied, false otherwise.
 */
TextArea.prototype.isForceUpperCase = function()
{
    return ( this.htmlElement.style.textTransform == "uppercase");
}

// -------------------------------------------------------------------------
// --------------------------- Intrinsic Event Handlers
// -------------------------------------------------------------------------

TextArea.prototype.handleFocus = function( browserEvent )
{
    // If this field is disabled, always return false
    var evt = new BaseEvent( browserEvent );
    if ( this.isDisabled() )
        evt.cancelEvent();
    else
        this.publishEvent( "onFocus", evt );
}

// The blur event is NOT cancelable.
TextArea.prototype.handleFocusLost = function( browserEvent )
{
    this.publishEvent( "onFocusLost", new BaseEvent( browserEvent ) );
}

// Fires when the user presses a keyboard key.  The event contains information about the key (not the character) pressed.
TextArea.prototype.handleKeyDown = function( browserEvent )
{
    var keybdEvent = new BaseEvent( browserEvent );
    if( keybdEvent.getKeyCode() == 9 )
    {
        this.publishEvent( "onTabOut", keybdEvent );
    }
    else
    {
        this.publishEvent( "onKeyDown", keybdEvent );
    }
}

// Fires after the user presses and releases a keyboard character.  The event sequenct is keydown, keyup, keypress.  This
// event contains information about the character of the key pressed, not the key code.
// // NEEDED TO CANCEL CHARACTER INPUT IN MOZILLA/NETSCAPE
TextArea.prototype.handleKeyPress = function( browserEvent )
{
    var keybdEvent = new BaseEvent( browserEvent );
    keybdEvent.value = this.htmlElement.value;
    keybdEvent.character = String.fromCharCode( keybdEvent.getKeyCode() );
    this.publishEvent( "onKeyPress", keybdEvent );
}


TextArea.prototype.handleValueChange = function( browserEvent )
{
    if( this.htmlElement.log )
        PageHelper.log( this, "Field value=" + this.htmlElement.value, browserEvent, "handleValueChange" );

    if ( this.isForceUpperCase() )
    {
        this.htmlElement.value = this.htmlElement.value.toUpperCase();
        if( this.htmlElement.log )
            PageHelper.log( this, "Forced field value to upper case, field value=" + this.htmlElement.value, browserEvent, "handleValueChange" );
    }

    var evt = new BaseEvent( browserEvent );
    evt.value = this.htmlElement.value;
    if( this.htmlElement.row )
        evt.row = this.htmlElement.row;
    this.publishEvent( "onValueChange", evt );

    // Record field value change with the field monitor
    this.registerFieldChange();
}/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: # $"


// -------------------------------------------------------------------------
// --------------------------- Component Construction & Initialization
// -------------------------------------------------------------------------
function TextField( id, elt )
{
    // Initialize the base compon ent
    var element = null;
    if( !elt )
        element = document.getElementById( id );
    else
        element = elt;

    this.initializeBaseComponent( element, "TextField" );

    // IF THIS IS LEFT IN, IT IS FOR CONVENIENCE ONLY. THIS PROPERTY IS REFERENCED IN JSPS.
    //this.value = element.value;
}
TextField.prototype = new BaseComponent();
TextField.prototype.constructor = TextField;

TextField.browseToolTip = ""; 

TextField.create = function( id, name, value, isPassword )
{
    var elt = document.createElement( "input" );
    if( isPassword ) elt.type = "password"
    else elt.type = "text";
    
    if( id ) elt.id = id;
    if( name ) elt.name = name;
    if( value ) elt.value = value;
    else elt.value = "";
    return new TextField( null, elt );
}

TextField.bindToId = function( id )
{
    var retObj = new TextField( id );    
    if( retObj.htmlElement.browseFunc )
        retObj.openBrowseWindow = retObj.handleBrowseFunc;
    return retObj;
}

TextField.bindToElt = function( elt )
{
    var retObj = new TextField( null, elt );
    if( retObj.htmlElement.browseFunc )
        retObj.openBrowseWindow = retObj.handleBrowseFunc;
    return retObj;
}

TextField.bindFromBrowseIconClick = function( e )
{
    var iconElt = PageHelper.getEventSourceElement( e );
    if( iconElt && iconElt.textFieldId )
        return TextField.bindToId( iconElt.textFieldId );
    return null;        
}

TextField.activateTextField = function( textFieldElt, e, iconElt )
{
    var id = textFieldElt.id;
    if( iconElt != null )
    {
        // Handle activation initiated by a click on the browse icon
        iconElt.onclick = new Function( "TextField.bindToId( \"" + id + "\" ).openBrowseWindow();" );
        TextField.bindHTMLEvents( textFieldElt );
        var textFieldComp = TextField.bindToElt( textFieldElt );
        iconElt.textFieldId = textFieldElt.id;
        if( e != null )
        {            
            textFieldComp.openBrowseWindow(e);
        }
    }
    else if( e != null )
    {
        // Handle activation initiated by putting focus in the text field.
        TextField.bindHTMLEvents( textFieldElt );
        iconElt = document.getElementById( textFieldElt.id + "_BROWSE_ICON" );

        // If the browse icon is present, initialize its click event handler
        if( iconElt != null )
        {
            iconElt.onclick = new Function( "TextField.bindToId( \"" + id + "\" ).openBrowseWindow();" );
            textFieldElt.browseElt = iconElt;
            iconElt.textFieldId = textFieldElt.id;
        }
        TextField.bindToElt( textFieldElt ).handleFocus( e );
    }
}

TextField.prototype.addToTableCell = function( tableCellElt, rowId )
{
    this.htmlElement.id = this.getIndexedId( rowId );
    tableCellElt.appendChild( this.htmlElement );
    if( this.htmlElement.browseable )
    {
        var icon = TextField.createBrowseIcon( this, rowId );
        icon.textFieldId = this.htmlElement.id;
        tableCellElt.appendChild( icon );
    }
    if( this.htmlElement.revisionFieldId )
    {
        this.htmlElement.revisionFieldId = this.getIndexedId( rowId, this.htmlElement.revisionFieldId );
    }
}

// -------------------------------------------------------------------------
// --------------------------- Intrinsic & Extended Events Binding
// -------------------------------------------------------------------------

TextField.bindHTMLEvents = function( elt )
{
    elt.onfocus = new Function( "e", "if( !e ) e = window.event; TextField.bindToElt( this ).handleFocus( e );" );
    elt.onblur = new Function( "e", "if( !e ) e = window.event; TextField.bindToElt( this ).handleFocusLost( e );" );
    elt.onkeydown = new Function( "e", "if( !e ) e= window.event; TextField.bindToElt( this ).handleKeyDown( e );" );
    elt.onchange = new Function( "e", "if( !e ) e= window.event; TextField.bindToElt( this ).handleValueChange( e );" );
    // NEEDED TO CANCEL CHARACTER INPUT IN MOZILLA/NETSCAPE
    elt.onkeypress = new Function( "e", "if( !e ) e= window.event; TextField.bindToElt( this ).handleKeyPress( e );" );
}

TextField.addExtEvents = function( extEventsProcessor )
{
    extEventsProcessor.addEvent( "onFocus" );
    extEventsProcessor.addEvent( "onFocusLost" );
    extEventsProcessor.addEvent( "onKeyDown" );
    extEventsProcessor.addEvent( "onValueChange" );
    extEventsProcessor.addEvent( "onTabOut" );
    // NEEDED TO CANCEL CHARACTER INPUT IN MOZILLA/NETSCAPE
    extEventsProcessor.addEvent( "onKeyPress" );

}


// -------------------------------------------------------------------------
// --------------------------- Accessors & Mutators
// -------------------------------------------------------------------------

/**
 * Get the id attribute value for the associated revision field.
 * @return {String} The revision field id, or null if this field has no revision field.
 */
TextField.prototype.getRevisionFieldId = function()
{
    return this.htmlElement.revisionFieldId;
}

/**
 * Set the text input field size.
 * @param {number} size The displayed field size.
 */
TextField.prototype.setSize = function( size )
{
    this.htmlElement.size = size;
}

/**
 * Set the text input maximum number of characters that may be entered by the user.
 * @param {number} maxlength The maximum number of characters that may be entered into the field.
 */
TextField.prototype.setMaxlength = function( maxlength )
{
    this.htmlElement.maxLength = maxlength;
}

/**
 * Enables/disables this text input field.  The field value is still submitted when disabled.
 * 
 * @param {Boolean} bool true to disable, false to enable.
 */
TextField.prototype.setDisable = function( bool )
{
    if ( bool )
    {
        this.htmlElement.readOnly = true;
        this.htmlElement.tabIndex = -1;
        this.htmlElement.style.backgroundColor = "#B7B7B7";
        TextField.removeBrowseIcon( this );

        if( this.htmlElement.revisionFieldId != null )
        {
            var revField = document.getElementById( this.htmlElement.revisionFieldId );
            if( revField != null )
            {
                revField.readOnly = true;
                revField.tabIndex = -1;
                revField.style.backgroundColor = "#B7B7B7";
            }
        }
    }
    else
    {
        this.htmlElement.readOnly = false;
        this.htmlElement.tabIndex = 0;
        this.htmlElement.style.backgroundColor = "#FFFFFF";
        TextField.addBrowseIcon( this );
        if( this.htmlElement.revisionFieldId != null )
        {
            var revField = document.getElementById( this.htmlElement.revisionFieldId );
            if( revField != null )
            {
                revField.readOnly = false;
                revField.tabIndex = 0;
                revField.style.backgroundColor = "#FFFFFF";
            }
        }
    }
}

/**
 * Shows/hides the input field and all associated components, including the field label, browse icon
 * and revision field.
 * @param {Boolean} bool true displays this field, false hides the field 
 */
TextField.prototype.setDisplay = function( bool )
{
    BaseComponent.setDisplay( this.htmlElement, bool, "inline" );    
        
    if( this.htmlElement.revisionFieldId )
    {        
        var revElt = document.getElementById( this.htmlElement.revisionFieldId );         
        if( revElt )                    
            BaseComponent.setDisplay( revElt, bool, "inline" );        
    }
    var iconElt = document.getElementById( this.id + "_BROWSE_ICON" );
    if( iconElt )    
        BaseComponent.setDisplay( iconElt, bool, "inline" );        
}

/**
 * Set the input name attribute.
 * @param {String} name The text input name.
 */
TextField.prototype.setName = function( name )
{
    this.htmlElement.name = name;
}

/**
 * Set the input value.
 * @param {String} text The text input value.
 */
TextField.prototype.setValue = function( text )
{
    this.htmlElement.value = text;
    if( this.isForceUpperCase() )
    {
        this.htmlElement.value = this.htmlElement.value.toUpperCase();
    }
}

/**
 * Get the input value.  If the field is set to force upper case, then the value returned will be
 * upper case.
 * @return {String} the field value.
 */
TextField.prototype.getValue = function()
{
    if( this.isForceUpperCase() )
        return this.htmlElement.value.toUpperCase();
    else
        return this.htmlElement.value;
}

/**
 * Ignore value changes. This effectively disables change monitoring of the field's value. Input fields are automatically
 * monitored by the framework for value changes.  This is necessary for the framework to determine if the user should
 * be prompted to confirm actions commonly used in maintenance applications. For example, if the user retrieves a record, changes
 * some input field value, and then attempts to clear the screen, they will be prompted to confirm the clear soas to prevent
 * accidental loss of changes.
 * @param bool true ignores changes, false enables field value monitoring
 */
TextField.prototype.setIgnoreChange = function( bool )
{
    this.htmlElement.ignoreChange = bool;
}

/**
 * Force the input value to be displayed and submitted as upper case.  All text input fields force uppercase by default.
 * @param {Boolean} val true forces uppercase, false allows multi-case input.
 */
TextField.prototype.setUppercase = function( val )
{
    if( val )
    {
        this.htmlElement.style.textTransform = "uppercase";
        this.htmlElement.value = this.htmlElement.value.toUpperCase();
    }
    else
        this.htmlElement.style.textTransform = "none";
}

/**
 * Set focus to this field. This will cause a focus event to fire on the element.
 */
TextField.prototype.setFocus = function()
{
    this.htmlElement.focus();
}

TextField.prototype.setBrowseable = function( value )
{
    this.htmlElement.browseable = value;
}

TextField.prototype.setNonSqlBrowse = function( value )
{
    this.htmlElement.nonSqlBrowse = value;
}

TextField.prototype.setBrowseFunc = function( func )
{
    this.htmlElement.browseFunc = func;
}

TextField.prototype.setBrowseIconURL = function( url )
{
    this.htmlElement.browseIconURL = url;
}

TextField.prototype.getBrowseIconURL = function()
{
    if( this.htmlElement.browseIconURL )
        return this.htmlElement.browseIconURL;
    else
        return TextField.browseIconURL;
}

TextField.prototype.setBrowseQueryName = function( queryName )
{
    this.htmlElement.browseQueryName = queryName;
}

TextField.prototype.setBrowseQuerySQL = function( sql )
{
    this.htmlElement.browseQuerySQL = sql;
}

TextField.prototype.setCustomBrowseFunc = function( func )
{
    this.htmlElement.customBrowseFunc = func;
}

TextField.prototype.setOtherCustomBrowseFunc = function( func )
{
    this.htmlElement.otherCustomBrowseFunc = func;
}

TextField.prototype.setRevisionFieldId = function( fieldId )
{
    this.htmlElement.revisionFieldId = fieldId;
}

TextField.prototype.setBrowseId = function( browseId )
{
    this.htmlElement.browseId = browseId;
}

TextField.prototype.setBrowseCommand = function( command )
{
    this.htmlElement.browseCommand = command;
}

TextField.prototype.setBrowseClassName = function( className )
{
    this.htmlElement.browseClassName = className;
}

TextField.prototype.setBrowseServiceName = function( serviceName )
{
    this.htmlElement.browseServiceName = serviceName;
}

TextField.prototype.setBrowseSelectionModel = function( selectionModel )
{
    this.htmlElement.browseSelectionModel = selectionModel;
}

TextField.prototype.setBrowseCustom = function( custom )
{
    this.htmlElement.browseCustom = custom;
}

/**
 * @return {Boolean} true if the text field is disabled, false otherwise.
 */
TextField.prototype.isDisabled = function()
{
    return this.htmlElement.readOnly;
}

/**
 * @return {Boolean} true if the text field is uppercase, false otherwise.
 */
TextField.prototype.isForceUpperCase = function()
{
    return ( this.htmlElement.style.textTransform == "uppercase");
}

TextField.prototype.hasCustomBrowseFunc = function()
{
    return ( this.htmlElement.customBrowseFunc != null );
}

TextField.prototype.hasOtherCustomBrowseFunc = function()
{
    return ( this.htmlElement.otherCustomBrowseFunc != null );
}


// -------------------------------------------------------------------------
// --------------------------- Helper Operations
// -------------------------------------------------------------------------

TextField.browseIconURL = contextPath + "/com/sap/me/system/common/client/images/icon_browse.gif";

TextField.createBrowseIcon = function( textField, index )
{        
    var browseIcon = document.createElement( "IMG" );
    if( isNaN(index) )
        browseIcon.id = textField.id + "_BROWSE_ICON";
    else
        browseIcon.id = textField.id + "[" + index + "]" + "_BROWSE_ICON";
    browseIcon.browseField = textField;
    browseIcon.title = TextField.browseToolTip;
    browseIcon.src = textField.getBrowseIconURL();
    browseIcon.className = "browse_icon";            
    
    if( !textField.htmlElement.browseFunc )
    {
        var browseFunc = function( e )
        {
            this.browseField.openBrowseWindow();
        }
        browseIcon.onclick = browseFunc;
    }
    else
    {        
        browseIcon.onclick = new Function( "TextField.bindToId( \"" + textField.htmlElement.id + "\" ).handleBrowseFunc();" );
    }        
    return browseIcon;
}

TextField.addBrowseIcon = function( textField )
{    
    var browseIcon = document.getElementById( textField.id + "_BROWSE_ICON" );
    if( browseIcon )    
        browseIcon.style.display = "inline";    
}

TextField.removeBrowseIcon = function( textField )
{
    var browseIcon = document.getElementById( textField.id + "_BROWSE_ICON" );
    if( browseIcon )
        browseIcon.style.display = "none";
}

TextField.prototype.openBrowseWindow = function()
{
    var siteFieldValue = PageHelper.site; // Look for global site value first (i.e., plugins)
    if( !siteFieldValue )
    {
        var elt = document.getElementById( "SITE" );
        if( elt )
        {
            if( elt.value )
                siteFieldValue = elt.value;
            else
                siteFieldValue = elt.innerHTML;
        }
    }

    // Process the new standard browse if it is being used
    if( this.htmlElement.browseId != null || this.htmlElement.browseServiceName != null)
    {
        var command = null;
        var browseClassName = null;
        var browseServiceName = null;
        var selectionModel = null;
        var custom = false;
        if( this.htmlElement.browseCommand )
            command = this.htmlElement.browseCommand;
        if( this.htmlElement.browseClassName )
            browseClassName = this.htmlElement.browseClassName;
        if( this.htmlElement.browseServiceName != null) 
            browseServiceName = this.htmlElement.browseServiceName;
        if( this.htmlElement.browseSelectionModel )
            selectionModel = this.htmlElement.browseSelectionModel;
        if( this.htmlElement.browseCustom )
            custom = this.htmlElement.browseCustom;

        if( this.isLoggingEnabled() )
            PageHelper.log( this, "Browse properties: " + "command=" + command + ", selectionModel=" + selectionModel + ", custom=" + custom, null, "openBrowseWindow" );

        PageHelper.doBrowse( document.forms[0].id, this.getId(), this.htmlElement.revisionFieldId, this.htmlElement.browseId, command, selectionModel, custom, this.getRowIndex(), browseClassName, browseServiceName );
    }
    else
    {
        if( this.isLoggingEnabled() )
            PageHelper.log( this, "Legacy browse; custom browse=" + this.hasCustomBrowseFunc() + ", PageHelper.site=" + PageHelper.site, null, "openBrowseWindow" );

        // Get the custom SQL string if there is one defined
        var sqlString = this.browseQuerySQL;

        if(!this.htmlElement.nonSqlBrowse)
        {
            if ( this.hasOtherCustomBrowseFunc() )
            {
                this.htmlElement.otherCustomBrowseFunc( this.getRowIndex() );
            }
            else
            {
                // Perform the browse
                if ( this.hasCustomBrowseFunc() )
                {
                    sqlString = this.htmlElement.customBrowseFunc( this.getRowIndex() );

                    var queryName = this.htmlElement.browseQueryName;
                    if( queryName == null ) //&*23 DEFAULT THE BROWSE QUERY KEY TO THIS ELEMENT'S FIELD NAME
                        queryName = this.htmlElement.name;

                    if( this.isLoggingEnabled() )
                        PageHelper.log( this, "Browse params (custom): " + "site=" + siteFieldValue + ", field value=" + this.getValue() + ", field name=" + this.htmlElement.name + ", field id=" + this.htmlElement.id + ", rev id=" + this.htmlElement.revisionFieldId + ", sql=" + sqlString, null, "openBrowseWindow" );
                    if ( sqlString )
                        customBrowse( queryName, this.htmlElement.name, "Main", sqlString, this.getValue(), siteFieldValue, this.htmlElement.revisionFieldId, true, "UseNewBrowse", this.htmlElement.id, this.htmlElement.revisionFieldId );
                }
                else
                {
                    var queryName = this.htmlElement.browseQueryName;
                    if( queryName == null ) //&*23 DEFAULT THE BROWSE QUERY KEY TO THIS ELEMENT'S FIELD NAME
                        queryName = this.htmlElement.name;

                    if( this.isLoggingEnabled() )
                        PageHelper.log( this, "Browse params (standard): " + "site=" + siteFieldValue + ", field value=" + this.getValue() + ", field name=" + this.htmlElement.name + ", field id=" + this.htmlElement.id + ", rev id=" + this.htmlElement.revisionFieldId + ", query name=" + queryName, null, "openBrowseWindow" );
                    browse( queryName, this.htmlElement.name, "Main", sqlString, this.getValue(), siteFieldValue, this.htmlElement.revisionFieldId, "UseNewBrowse", this.htmlElement.id, this.htmlElement.revisionFieldId );
                }
            }
        }
        else
        {
            var serviceAPIDefs = null;
            if ( this.hasCustomBrowseFunc() )
            {
                serviceAPIDefs = this.htmlElement.customBrowseFunc( this.getRowIndex() );
                var queryName = this.htmlElement.browseQueryName;
                if( queryName == null ) //&*23 DEFAULT THE BROWSE QUERY KEY TO THIS ELEMENT'S FIELD NAME
                    queryName = this.htmlElement.name;
                if( this.isLoggingEnabled() )
                    PageHelper.log( this, "Browse params (nonSql): " + "site=" + siteFieldValue + ", field value=" + this.getValue() + ", field name=" + this.htmlElement.name + ", field id=" + this.htmlElement.id + ", rev id=" + this.htmlElement.revisionFieldId + ", query name=" + queryName, null, "openBrowseWindow" );

                nonSqlBrowseFunc(queryName, this.htmlElement.name, "Main", serviceAPIDefs, this.getValue(), siteFieldValue,this.htmlElement.revisionFieldId) ;
            }
        }
    }
}


// -------------------------------------------------------------------------
// --------------------------- Intrinsic Event Handlers
// -------------------------------------------------------------------------

// Called when the browse icon is clicked or when the browse hotkey is pressed AND
// there is a browseFunc set for the field.
TextField.prototype.handleBrowseFunc = function( browserEvent )
{        
    var evt = new BaseEvent( browserEvent );
    var row = this.getRow();
    if( row )
        evt.row = row;        
    evt.fieldId = this.getComponentId(true);
    evt.revisionId = this.getRevisionFieldId();
    this.htmlElement.browseFunc(evt);
}

TextField.prototype.handleFocus = function( browserEvent )
{    
    // If this field is disabled, always return false
    var evt = new BaseEvent( browserEvent );
    if ( this.isDisabled() )
        evt.cancelEvent();
    else
    {
        this.htmlElement.valueOnFocus = this.htmlElement.value;
        if(!this.inTable()) {
        	this.htmlElement.classList.add("inputInFocus");
        }
        this.publishEvent( "onFocus", evt );
    }
}

// The blur event is NOT cancelable.
TextField.prototype.handleFocusLost = function( browserEvent )
{   
	if(!this.isDisabled())
	{
		this.htmlElement.classList.remove("inputInFocus");
	}
	this.publishEvent( "onFocusLost", new BaseEvent( browserEvent ) );
}

// Fires when the user presses a keyboard key.  The event contains information about the key (not the character) pressed.
TextField.prototype.handleKeyDown = function( browserEvent )
{
	// if field disabled, event ignored
    if ( !this.isDisabled() )
    {        
	    var keybdEvent = new BaseEvent( browserEvent );
	
	    keybdEvent.value = this.htmlElement.value;
	    keybdEvent.character = String.fromCharCode( keybdEvent.getKeyCode() );
	
	    // If this field is browseable, check for F9.  If it is pressed,
	    // perform a browse    
	    if ( keybdEvent.getKeyCode() == 120 )
	    {
	        if( this.isLoggingEnabled() )
	            PageHelper.log( this, "F9 key pressed, field browseable=" + this.htmlElement.browseable, browserEvent, "handleKeyDown" );
	
	        // If F9 was pressed, first uppercasing the field value if necessary
	        if ( this.isForceUpperCase() )
	        {
	            this.htmlElement.value = this.htmlElement.value.toUpperCase();
	            if( this.isLoggingEnabled() )
	                PageHelper.log( this, "Forcing upper case, new value=" + this.htmlElement.value, browserEvent, "handleKeyDown" );                        
	        }
            
	        if ( this.htmlElement.browseable )
	        {
	           	this.openBrowseWindow(browserEvent);
	        }
	        else
	            this.publishEvent( "onKeyDown", keybdEvent );
	    }
	    else if ( keybdEvent.getKeyCode() == 13 )
	    {
	    	
	        if( this.isLoggingEnabled() )
	            PageHelper.log( this, "Enter key pressed, field value=" + this.htmlElement.value, browserEvent, "handleKeyDown" );
	
	        // If text field is browseable, perform a browse on Enter either
	        if ( this.htmlElement.browseable )
	        {
	           	this.openBrowseWindow(browserEvent);
	           	// Cancel further event handling to prevent any other "Enter" key actions
	           	keybdEvent.cancelBubble();
	           	keybdEvent.cancelEvent();
	        }
	        else
	            this.publishEvent( "onKeyDown", keybdEvent );
	
	            // ???  WILL THE VALUE SUBMIT AS UPPERCASE IF THIS IS NOT DONE HERE
	        // If the user presses [Enter], the form might be submitted.  Therefore, we
	        // need to uppercase the value if we're forcing uppercase
	       // if ( this.isForceUpperCase() )
	            //this.htmlElement.value = this.htmlElement.value.toUpperCase();
	    }
	    else if ( keybdEvent.getKeyCode() == 9 )
	    {
	        if( this.isLoggingEnabled() )
	            PageHelper.log( this, "Tab key pressed, field value=" + this.htmlElement.value, browserEvent, "handleKeyDown" );
	
	        // If [Tab] was pressed, publish an onTabOut message, first uppercasing the
	        // field value if necessary
	        if ( this.isForceUpperCase() )
	        {
	            keybdEvent.value = this.htmlElement.value.toUpperCase();
	            this.htmlElement.value = keybdEvent.value;
	            if( this.isLoggingEnabled() )
	                PageHelper.log( this, "Forcing upper case, new value=" + this.htmlElement.value, browserEvent, "handleKeyDown" );                        
	        }
	        if( this.isLoggingEnabled() )
	            PageHelper.log( this, "valueOnFocus=" + this.htmlElement.valueOnFocus + ", current value=" + this.htmlElement.value, browserEvent, "handleKeyDown" );
	        if( this.htmlElement.valueOnFocus != this.htmlElement.value )        
	            this.handleValueChange( browserEvent );
	        
	        this.publishEvent( "onTabOut", keybdEvent );
	    }
	    else
	        this.publishEvent( "onKeyDown", keybdEvent );
    }
}

// Fires after the user presses and releases a keyboard character.  The event sequenct is keydown, keyup, keypress.  This
// event contains information about the character of the key pressed, not the key code.
// // NEEDED TO CANCEL CHARACTER INPUT IN MOZILLA/NETSCAPE
TextField.prototype.handleKeyPress = function( browserEvent )
{
    var keybdEvent = new BaseEvent( browserEvent );
    keybdEvent.value = this.htmlElement.value;
    keybdEvent.character = String.fromCharCode( keybdEvent.getKeyCode() );
    this.publishEvent( "onKeyPress", keybdEvent );
}


TextField.prototype.handleValueChange = function( browserEvent )
{
    if( this.isLoggingEnabled() )
        PageHelper.log( this, "Field value=" + this.htmlElement.value, browserEvent, "handleValueChange" );

    if ( this.isForceUpperCase() )
    {
        this.htmlElement.value = this.htmlElement.value.toUpperCase();
        if( this.isLoggingEnabled() )
            PageHelper.log( this, "Forced field value to upper case, field value=" + this.htmlElement.value, browserEvent, "handleValueChange" );
    }

    var evt = new BaseEvent( browserEvent );
    evt.value = this.htmlElement.value;   
    var row = this.getRow();
    if(row) {
        evt.row = row;
    }
    this.publishEvent( "onValueChange", evt );

    // Register the field change with the field monitor    
    this.registerFieldChange();
}
/* (c) Copyright 2008 SAP AG. All rights reserved. */
// "$Revision: /main/3$"

/*
 * WindowManager
 * -------------
 * This object manages popup windows, and can maintain references to windows
 * that are open.  This allows bidirectional communication between an opened
 * window and the document that opened it, and it allows clients to detect when
 * windows are opened and closed.
 *
 */

function WindowManager()
{
    this.windowMap = new Object();
    var eep = new ExtEventsProcessor();
    this.extEventsProcessor = eep;
    this.addExtEvents( eep );
}
WindowManager.prototype.constructor = WindowManager;
/*
 * createWindow( windowName, width, height, position, resizeable, scrollable,
 *               addressbar, statusbar, toolbar, titlebar )
 * ---------------------------------------------------------------------------
 * Creates a new window.  The window created by this method is NOT modal.  If
 * you need a modal window (aka "dialog"), call createModalWindow() instead.
 *
 * This method will fire a "windowCreated" event when the requested window has
 * been loaded.
 *
 */
WindowManager.prototype.createWindow = function( windowName, width, height, position, resizeable, scrollable, addressbar, statusbar, toolbar, titlebar )
{
    var url = contextPath + "/com/genrad/app/common/client/ManagedWindow.html";
    var windowOptions = this.constructWindowOptions( width, height, position, resizeable, scrollable, addressbar, statusbar, toolbar, titlebar );

    // Create the window and add it to the window map
    this.windowMap[windowName] = window.open( url, windowName, windowOptions );
    return this.windowMap[windowName];
}

/*
 * createModalWindow( windowName, width, height, position, resizeable, scrollable,
 *               addressbar, statusbar, toolbar, titlebar )
 * -------------------------------------------------------------------------------
 * Creates a new modal window (aka "dialog window").
 *
 * This method will fire a "windowCreated" event when the requested window has
 * been loaded.
 *
 */
WindowManager.prototype.createModalWindow = function( windowName, width, height, position, resizeable, scrollable, addressbar, statusbar, toolbar, titlebar )
{
    var url = contextPath + "/com/sap/me/system/common/client/ManagedModalWindow.jsp";
    var windowOptions = this.constructWindowOptions( width, height, position, resizeable, scrollable, addressbar, statusbar, toolbar, titlebar );

    // Create the window and add it to the window map
    this.windowMap[windowName] = window.open( url, windowName, windowOptions );
}

/*
 * loadURL( windowName, url )
 * --------------------------
 * Loads the given URL into the specified window.
 *
 */
WindowManager.prototype.loadURL = function( windowName, url )
{
    var win = this.windowMap[windowName];
    var iframe = win.document.createElement( "IFRAME" );
    iframe.width = "99%";
    iframe.height = "99%";
    iframe.src = url;
    win.setContentElement( iframe );
}

/*
 * getWindow( windowName )
 * -----------------------
 * Returns a reference to the named window.
 *
 */
WindowManager.prototype.getWindow = function( windowName )
{
    return this.windowMap[windowName];
}

/*
 * closeAllWindows()
 * -----------------
 * Closes all windows this window manager knows about.  This is normally only
 * done when the SCE Activity Manager is closed.
 *
 */
WindowManager.prototype.closeAllWindows = function()
{
}

/*
 * closeWindow( windowName )
 * -------------------------
 * Closes the named window.
 *
 */
WindowManager.prototype.closeWindow = function( windowName )
{
    var win = this.windowMap[windowName];
    win.close();
}

/*
 * moveWindow( windowName, position )
 * ----------------------------------
 * Moves the named window to the specified position.
 *
 */
WindowManager.prototype.moveWindow = function( windowName, position )
{
    var win = this.windowMap[windowName];
    win.moveTo( position.x, position.y );
}

/*
 * resizeWindow( windowName, width, height )
 * -----------------------------------------
 * Resizes the named window to the specified width and height.
 *
 */
WindowManager.prototype.resizeWindow = function( windowName, width, height )
{
    var win = this.windowMap.get( windowName );
    win.resizeTo( width, height );
}

WindowManager.prototype.windowLoaded = function( windowName )
{
    var wmEvent = new BaseEvent();
    wmEvent.windowName = windowName;
    this.extEventsProcessor.publishEvent( "windowCreated", wmEvent );
}

WindowManager.prototype.windowClosed = function( windowName )
{
    var wmEvent = new BaseEvent();
    wmEvent.windowName = windowName;
    this.extEventsProcessor.publishEvent( "windowClosed", wmEvent );
    this.windowMap[windowName] = null;
}

WindowManager.prototype.windowOpened = function( windowName )
{
    return ( this.windowMap[windowName] != null );
}

WindowManager.prototype.constructWindowOptions = function( width, height, position, resizeable, scrollable, addressbar, statusbar, toolbar, titlebar )
{
    var windowOptions = "";

    if ( width != null )
    {
        windowOptions += "width=" + width;
    }
    if ( height != null )
    {
        windowOptions += ",height=" + height;
    }
    if ( position != null )
    {
        windowOptions += ",left=" + position.x;
        windowOptions += ",top=" + position.y;
    }
    if ( resizeable != null )
    {
        windowOptions += ",resizable=" + ( resizeable ) ? "yes" : "no";
    }
    if ( scrollable != null )
    {
        windowOptions += ",scrollbars=" + ( scrollable ) ? "yes" : "no";
    }
    if ( addressbar != null )
    {
        windowOptions += ".location=" + ( addressbar ) ? "yes" : "no";
    }
    if ( statusbar != null )
    {
        windowOptions += ",status=" + ( statusbar ) ? "yes" : "no";
    }
    if ( toolbar != null )
    {
        windowOptions += ",toolbar=" + ( toolbar ) ? "yes" : "no";
    }
    if ( titlebar != null )
    {
        windowOptions += ",titlebar=" + ( titlebar ) ? "yes" : "no";
    }

    return windowOptions;
}

WindowManager.prototype.addExtEvents = function( extEventsProcessor )
{
    extEventsProcessor.addEvent( "windowCreated" );
    extEventsProcessor.addEvent( "windowClosed" );
}/* (c) Copyright 2008 SAP AG. All rights reserved. */


function XBrowserHelper()
{
}

XBrowserHelper.getQueryString = function(oWindow, sKey) {
    if (!oWindow) {
        return null;
    }
    var url = oWindow.location.href;
    var sKeysValues = url.split(/[\?&#]+/);
    for (i = 0; i < sKeysValues.length; i++) {
        var sKeyValue = sKeysValues[i].split("=");
        if (sKeyValue[0] == sKey) {
            return sKeyValue[1];
        }
    }
    return null;
}

XBrowserHelper.getBrowserInformation = function()
{
    var ua = navigator.userAgent;
    var oAgentData = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*([\d\.]+)/i) || [];
    var sBrowserName =  undefined;
    var temp = undefined;

    // check for Microsoft Edge browser
    if (!oAgentData || oAgentData.length == 0) {
        if (ua.toLowerCase().indexOf("windows nt 10.0") > 0) {
            sBrowserName = "EDGE";
        }

    } else if (/trident/i.test(oAgentData[1])) {
        temp =  /\brv[ :]+(\d+(\.\d+)?)/g.exec(ua) || [];
        sBrowserName = "MSIE";

    } else {
        oAgentData= oAgentData[2] ? [oAgentData[1], oAgentData[2]]:[navigator.appName, navigator.appVersion, '-?'];
        temp = ua.match(/version\/([\.\d]+)/i);
        if (!temp) {
            temp = [];
            temp[0] = "";
            temp[1] = oAgentData[1];
        }
        sBrowserName = oAgentData[0];

    }

    var sVersion = navigator.appVersion;
    if (temp) {
        sVersion = temp[1];
    }
    var aDigits = sVersion.split(".");

    var oBrowserInfo = {
        name: sBrowserName,
        version: -1.0
    }

    if (aDigits.length > 1) {
        oBrowserInfo.version = parseFloat(aDigits[0] + "." + aDigits[1]);
    } else {
        oBrowserInfo.version = parseFloat(aDigits[0] + ".0");
    }

    return oBrowserInfo;
}
XBrowserHelper.getCurrentStyle = function(el, cssProperty){
    if (!el || !cssProperty) {
        return "";
    }
    if (window.getComputedStyle){
        return window.getComputedStyle(el,null).getPropertyValue(cssProperty);
    } else if (el.currentStyle) {
        return el.currentStyle[cssProperty];
    }
    return el.style[cssProperty];
}

XBrowserHelper.getDefaultStyle = function(el, cssProperty){
    if (!el || !cssProperty) {
        return "";
    }
    if (window.getComputedStyle){
        return window.getComputedStyle(el,null).getPropertyValue(cssProperty);
    } else if (el.runtimeStyle) {
        return el.runtimeStyle[cssProperty];
    }
    return el.style[cssProperty];
}

XBrowserHelper.setRuntimeStyle = function(el, cssProperty, cssValue){
    if (!el || !cssProperty) {
        return;
    }
    if (el.runtimeStyle){
        el.runtimeStyle[cssProperty] = cssValue;
        return;
    }
    el.style[cssProperty] = cssValue;
}

XBrowserHelper.addEventListener = function(oElement, sEvent, fCallback){
    // W3C model and IE9+
    if (oElement.addEventListener) {
        oElement.addEventListener(sEvent, fCallback, false);
        return true;

    // IE8 and less
    } else if (oElement.attachEvent) {
        return oElement.attachEvent('on' + sEvent, fCallback);

    // all else
    } else {
        sEvent = 'on'+sEvent;
        if(typeof oElement[sEvent] === 'function'){
            // Object already has a function on traditional
            // if object already has function, wrap it with our own function inside another function
            fCallback = (function(f1,f2){
                return function(){
                    f1.apply(this,arguments);
                    f2.apply(this,arguments);
                }
            })(oElement[sEvent], fCallback);
        }
        oElement[sEvent] = fCallback;
        return true;
    }
    return false;
}

XBrowserHelper.handleEventReturn = function(oEvent, bSubmit) {

    // W3C model and IE9+
    if (oEvent) {
        if (window.addEventListener) {
            if (!bSubmit) {
                if (oEvent.preventDefault) {
                    oEvent.preventDefault();
                }
            }
        }
        // IE8 and less
        else if (window.attachEvent) {
            oEvent.returnValue=bSubmit;
        }
    }
    return bSubmit;
}

XBrowserHelper.getXMLHttpRequest = function()
{
    var req = false;
    if( window.XMLHttpRequest )
    {
        try
        {
            req = new XMLHttpRequest();
        }
        catch( e )
        {
            req = false;
        }
    // branch for IE/Windows ActiveX version
    }
    else if( window.ActiveXObject )
    {
        try
        {
            req = new ActiveXObject("Msxml2.XMLHTTP");
        }
        catch( e )
        {
            try
            {
                req = new ActiveXObject("Microsoft.XMLHTTP");
            }
            catch( e )
            {
                req = false;
            }
        }
    }
    return req;
}

XBrowserHelper.getElementByIdOrName = function(oDocument, fieldId)
{
    var retVal = oDocument.getElementById(fieldId);
    if (!retVal) {
        var tempElt = oDocument.getElementsByName(fieldId);
        if (tempElt && tempElt.length == 1) {
            retVal = tempElt[0];
        }
    }
    return retVal;
}

XBrowserHelper.getAllRowElementsById = function(sStartId, iStartRow)
{
    var elements = [];
    var count = iStartRow;
    var bFound = false;
    do {
        var oElement = document.getElementById(sStartId + count);
        if (oElement) {
            bFound = true;
            elements[elements.length] = oElement;
            count++;
        } else {
            bFound = false;
        }
    } while (bFound);

    return elements;
}

XBrowserHelper.setInnerTextValue = function(oElement, sValue) {
    if (!oElement) {
        return;
    }
    if ((oElement.textContent) && (typeof (oElement.textContent) != "undefined")) {
        oElement.textContent = sValue;
    } else {
        oElement.innerText = sValue;
    }
}

XBrowserHelper.getInnerTextValue = function(oElement)
{
    if (!oElement) {
        return undefined;
    }
    return (oElement.innerText || oElement.textContent);
}

XBrowserHelper.getKeyCode = function(oEvent)
{
    var keyCode = ('which' in oEvent) ? oEvent.which : oEvent.keyCode;
    return keyCode;
}

XBrowserHelper.writeToConsole = function(sMessage)
{
    if (console) {
        console.log(sMessage);
    } else {
        alert(sMessage);
    }
}

XBrowserHelper.click = function(oElement) {
    if (oElement) {
        if (oElement.click) {
            oElement.click();
        } else if (oElement.dispatchEvent) {
            var oClickEvent = document.createEvent("MouseEvents");
            oClickEvent.initEvent("click", true, true);
            oElement.dispatchEvent(oClickEvent);
        } else if (oTab.fireEvent) {
            oElement.fireEvent('onclick');
        }
    }
}

/* (c) Copyright 2008 SAP AG. All rights reserved. */

/* "$Revision: 1$" */

/*
    Exception.js

    This object represents an exception object thrown from JavaScript functions and
    methods.  This is the base exception object; it is expected that new exception objects
    will be derived from this one.

    This object only contains a configurable error message - something all exception objects
    should offer.  The exception automatically gets a stack trace.  Use the getStackTrace()
    method to access this functionality.

    Example Usage:

       try
       {
          .
          .
          .
          if ( key == null ) {
             throw new Exception( "No 'key' parameter was specified" );
          }
       }
       catch ( exception )
       {
          alert( exception.getMessage() );
          break;
       }
*/

/*
$Log: Exception.js $
Revision 1.2  2001/09/07 22:09:34Z  rasmussene
Fixed a bug in the constructor that prevented the setting of the error message.
Revision 1.1  2001/09/06 04:34:36Z  rasmussene
Initial revision
*/

//
// Exception Constructor
// ---------------------
// Constructs a new Exception object and initializes the exception message and stack trace.
//
// Implementation:
//   1. If message was passed in, initialize the message member with the value
//   2. Build the caller stack trace
//
function Exception( message )
{
    if ( ( message != null ) && ( typeof( message ) == "string" ) ) {
        this.message = message;
    } else {
        this.message = "";
    }

    // This inner method gets the name of a function, given the function's handle.  If the
    // function has no name, "anonymous" is substituted.  This can happen, for instance,
    // when a function gets called by an event handler like 'onLoad'.
    function getFunctionName( func )
    {
        var s = func.toString().match( /function (\w*)/)[1];
        if ( ( s == null ) || ( s.length == 0 ) ) {
            s = "anonymous";
        }
        return s;
    }

    this.stackTrace = "[Method Stack]\n------------------------------------------------\n";
    for ( var a = arguments.caller; a != null; a = a.caller ) {
        this.stackTrace += getFunctionName( a.callee ) + "\n";
    }
}

//
// getMessage
// ----------
// Gets the error message for this exception object.
//
function Exception_getMessage()
{
    return this.message;
}
Exception.prototype.getMessage = Exception_getMessage;

//
// getStackTrace
// -------------
// Gets a stack trace for this exception.
//
function Exception_getStackTrace()
{
    return this.stackTrace;
}
Exception.prototype.getStackTrace = Exception_getStackTrace;

/* (c) Copyright 2008 SAP AG. All rights reserved. */

/* "$Revision: 1$" */

/*
    InvalidStateException.js

    This exception object represents an object that is in an invalid state.  If an object
    is supposed to be in some defined state, but it's not, then this exception should be
    thrown.

*/

/*
$Log: InvalidStateException.js $
Revision 1.1  2001/09/06 04:34:37Z  rasmussene
Initial revision
*/

//
// InvalidStateException Constructor
// ---------------------------------
// Constructs a new InvalidStateException object and initializes the error message.
//
// Implementation:
//   1. If message was passed in, initialize the message member with it
//   2. Initialize base members with subclass Exception object
//
function InvalidStateException( message )
{
    if ( ( message != null ) && ( typeof( message ) == "string" ) ) {
        this.baseException = new Exception( message );
    }
    this.message = this.baseException.getMessage();
    this.stackTrace = this.baseException.getStackTrace();
}
InvalidStateException.prototype = new Exception();

/* (c) Copyright 2008 SAP AG. All rights reserved. */

/* "$Revision: 1$" */

/*
    MalformedURLException.js

    This exception object represents an invalid or malformed URL.  This exception should
    be thrown whenever a URL cannot be properly parsed.
*/

/*
$Log: MalformedURLException.js $
Revision 1.1  2001/09/07 22:10:53Z  rasmussene
Initial revision
*/

//
// MalformedURLException Constructor
// ---------------------------------
// Constructs a new MalformedURLException object and initializes the error message.
//
// Implementation:
//   1. If invalidURL was passed in, initialize the message member with it
//   2. Initialize base members with subclass Exception object
//
function MalformedURLException( invalidURL )
{
    if ( ( invalidURL != null ) && ( typeof( invalidURL ) == "string" ) ) {
        this.baseException = new Exception( invalidURL );
    }
    this.message = this.baseException.getMessage();
    this.stackTrace = this.baseException.getStackTrace();
}
MalformedURLException.prototype = new Exception();

/* (c) Copyright 2008 SAP AG. All rights reserved. */

/* "$Revision: 1$" */

/*
    MissingParameterException.js

    This exception object represents a missing parameter error condition.  If a function
    or method expects a parameter to be passed in, this exception should be thrown if the
    parameter does not exist.

*/

/*
$Log: MissingParameterException.js $
Revision 1.1  2001/09/06 04:34:40Z  rasmussene
Initial revision
*/

//
// MissingParameterException Constructor
// -------------------------------------
// Constructs a new MissingParameterException object and initializes missing parameter
// error message.
//
// Implementation:
//   1. If paramName was passed in, initialize the message member with a meaningful string
//   2. Initialize base members with subclass Exception object
//
function MissingParameterException( paramName )
{
    if ( ( paramName != null ) && ( typeof( paramName ) == "string" ) ) {
        this.baseException = new Exception( "Missing required parameter '" + paramName + "'" );
    }
    this.message = this.baseException.getMessage();
    this.stackTrace = this.baseException.getStackTrace();
}
MissingParameterException.prototype = new Exception();

/* (c) Copyright 2008 SAP AG. All rights reserved. */

/* "$Revision: 1$" */

/*
    PostRequest.js

    This object programmatically builds POST requests.  Using DHTML, a form is created and
    added to the current document.  For each key/value pair added to the object, a hidden
    form field is created.  Before the form can be submitted, a target must be selected.
    The target defines which frame or window will receive the request.  Finally, the form
    is submitted and the request is issued to the server using the POST method.

    Example Usage:

       var req = new PostRequest();
       req.addParameter( "SITE", "MYSITE" );
       req.addParameter( "SFC", "1121" );
       req.addParameter( "OPERATION", "OP1" );
       req.setURL( "/com/genrad/app/core/sys/client/SomePage.jsp" );
       req.submit();
*/

/*
$Log: PostRequest.js $
Revision 1.7  2001/09/22 19:19:45Z  rasmussene
Fixed another problem with empty parameters in the GET string
Revision 1.6  2001/09/22 16:51:56Z  rasmussene
Fixed a problem with the last parameter never making it into the request
Revision 1.5  2001/09/21 16:14:34Z  rasmussene
Fixed a problem with empty parameter parsing
Revision 1.4  2001/09/11 15:37:14Z  posead
modified to allow parameter with no value to be passed in URL.
Revision 1.3  2001/09/10 21:22:12Z  rasmussene
Fixed a problem with the GET parameter parsing
Revision 1.2  2001/09/07 22:07:29Z  rasmussene
Added the ability to initialize the PostRequest object with a GET request string
Revision 1.1  2001/09/06 04:34:35Z  rasmussene
Initial revision
*/

//
// PostRequest Constructor
// -----------------------
// Constructs a new PostRequest object and initializes member variables.  The
// object can optionally be initialized from a GET request string, passed in
// to the constructor.
//
// Implementation:
//   1. Check to see if a previous PostRequest object has left behind a form.
//     a. If so, remove it
//   2. Create a "hashtable" using two arrays to store request parameters
//   3. Initialize the URL to an invalid value.
//     a. We don't want the user to be able to submit a request without a URL
//   4. If a URL string was passed in, initialize the object from the URL string
//     a. A separate method, parseGetString, will be used to perform the actual
//        initialization
//
function PostRequest( url )
{
    var oPreviousForm = document.getElementById( "PostRequestObject_FormID" );
    if ( oPreviousForm != null ) {
        document.body.removeChild( oPreviousForm );
    }
    this.requestKeys = new Array();
    this.requestValues = new Array();
    this.numRequestParams = 0;
    this.requestURL = null;

    if ( ( url != null ) && ( typeof( url ) == "string" ) ) {
        this.parseGetString( url );
    }
}

//
// parseGetString
// --------------
// Parses a GET string and initializes this object with the contents of the
// string.  This is useful when translating GET code to the POST method.
//
// Parameters:
//   url - The GET URL string to parse
//
// Throws:
//   MissingParameterException if 'url' is missing
//   MalformedURLException if the URL cannot be parsed
//
// Implementation:
//   1. Verify that the url parameter was passed in and that it is a string
//   2. Check to see if the URL has any parameters associated with it
//     a. If so, extract the URI portion and store it as the request target
//     b. If not, use the 'url' parameter directly as the request target
//   3. If there are parameters, add each one to this request
//     a. While there are more parameters:
//       i.   Retrieve the parameter name and decodeURI it
//       ii.  Retrieve the parameter value and decodeURI it
//       iii. Add the parameter name and value to this request using addParam
//
function PostRequest_parseGetString( url )
{
    if ( url == null ) {
        throw new MissingParameterException( "url" );
    } else if ( typeof( url ) != "string" ) {
        throw new MalformedURLException( "The specified URL is not a valid string" );
    }

    // Get the URI portion of the URL
    var endOfURI = url.indexOf( "?" );
    if ( endOfURI == -1 ) {
        this.setURL( url );
    } else {
        // Get the URI from the URL string
        var uri = url.substring( 0, endOfURI );
        this.setURL( uri );

        // Create a string index that acts as a "cursor" in the string
        var index = endOfURI + 1;

        // Get the index of the end of the next token
        var nextTokenIndex = url.indexOf( "=", index );
        while ( nextTokenIndex != -1 ) {
            // Get the parameter name
            var paramName = decodeURI( url.substring( index, nextTokenIndex ) );
            index = nextTokenIndex + 1;

            // Get the parameter value.  If there is no value associated with the parameter, store
            // an empty string
            nextTokenIndex = url.indexOf( "&", index );
            if ( nextTokenIndex == -1 ) {
                if ( index < url.length ) {
                    paramValue = decodeURI( url.substring( index ) );
                } else {
                    paramValue = "";
                }
            } else if ( index == nextTokenIndex ) {
                paramValue = "";
            } else {
                var paramValue = decodeURI( url.substring( index, nextTokenIndex ) );
            }

            // Add the parameter to this request
            this.addParam( paramName, paramValue );

            // Look for the next token index
            if ( nextTokenIndex != -1 ) {
                index = nextTokenIndex + 1;
                nextTokenIndex = url.indexOf( "=", index );
            }
        }
    }
}
PostRequest.prototype.parseGetString = PostRequest_parseGetString;

//
// addParam
// --------
// Adds a request parameter to this request
//
// Parameters:
//   key - the request parameter
//   value - the value of the parameter
//
// Throws:
//   MissingParameterException if 'key' or 'value' is missing
//
// Implementation:
//   1. Verify that both the key and the value were passed in
//   2. Format the value so that it will work with the dynamic form
//   3. Add the key/value pair to the request parameter "hashtable"
//
function PostRequest_addParam( key, value )
{
    if ( key == null ) {
        throw new MissingParameterException( "key" );
    }
    else if ( value == null ) {
        throw new MissingParameterException( "value" );
    }

    value = value.replace( /\"/g, "&quot;" );

    this.requestKeys[ this.numRequestParams ] = key;
    this.requestValues[ this.numRequestParams ] = value;
    this.numRequestParams++;
}
PostRequest.prototype.addParam = PostRequest_addParam;

//
// setURL
// ------
// Sets the URL that this request will be sent to
//
// Parameters:
//   url - The URL this request will be sent to
//
// Throws:
//   MissingParameterException if 'url' is missing
//
// Implementaiton:
//   1. Verify that the URL was passed in
//   2. Set the URL
//
function PostRequest_setURL( url )
{
    if ( url == null ) {
        throw new MissingParameterException( "url" );
    }

    this.requestURL = url;
}
PostRequest.prototype.setURL = PostRequest_setURL;

//
// PostRequest_private_submitRequest
// ---------------------------------
// This is a private method.  You should not call it.  It is not part of the PostRequest object's
// public interface.
//
function PostRequest_private_submitRequest( url, target, keys, values )
{
    var numKeys = keys.length;

    // Build a FORM tag that we will use to submit the data
    var postRequestForm = document.createElement("form");
    postRequestForm.setAttribute("name","PostRequestObject_Form");
    postRequestForm.setAttribute("id","PostRequestObject_FormID");
    postRequestForm.setAttribute("method","POST");
    postRequestForm.setAttribute("action",url);
    postRequestForm.setAttribute("target",target);


    // Build each request parameter using a hidden form field
    for ( var index = 0; index < numKeys; index++ ) {
    	var key = keys[ index ].replace( /\"/g, "&quot;" );
    	var value =  values[ index ].replace( /\"/g, "&quot;" );
        postRequestForm.innerHTML += "<INPUT TYPE='HIDDEN' NAME=\"" + encodeJS(key) + "\" VALUE=\"" + value + "\"/>";
    }

    // Add the form to the document
    document.body.appendChild( postRequestForm );

    // Submit the request
    postRequestForm.submit();

    // Remove the form from the document (cleaning up after yourself is a good practice)
    document.body.removeChild(postRequestForm);

    postRequestForm = null;

}

//
// submit
// ------
// Submits this request to the current window or frame.
//
// Throws:
//   InvalidStateException if the URL has not been set yet
//
// Implementation:
//   1. Verify that the URL has been set
//   2. Set the target to "_self"
//   3. Call the internal submitRequest method to actually submit the request
//
function PostRequest_submit()
{
    if ( this.requestURL == null ) {
        throw new InvalidStateException( "The URL has not been set for the request" );
    }

    PostRequest_private_submitRequest( this.requestURL, "_self", this.requestKeys, this.requestValues );
}
PostRequest.prototype.submit = PostRequest_submit;

//
// submitToWindowOrFrame
// ---------------------
// Submits this request to the specified window or frame.
//
// Parameters:
//   targetName - The name of the window or frame to submit the request to
//
// Throws:
//   MissingParameterException if the targetName parameter was not passed in
//   InvalidStateException if the URL has not been set yet
//
// Implementation:
//   1. Verify that the window or frame name was passed in
//   2. Verify that the URL has been set
//   3. Set the target to the window or frame name passed in
//   4. Call the internal submitRequest method to actually submit the request
//
function PostRequest_submitToWindowOrFrame( targetName )
{
    if ( ( targetName == null ) || ( typeof( targetName ) != "string" ) ) {
        throw new MissingParameterException( "targetName" );
    }
    if ( this.requestURL == null ) {
        throw new InvalidStateException( "The URL has not been set for the request" );
    }

    PostRequest_private_submitRequest( this.requestURL, targetName, this.requestKeys, this.requestValues );
}
PostRequest.prototype.submitToWindowOrFrame = PostRequest_submitToWindowOrFrame;

/* (c) Copyright 2008 SAP AG. All rights reserved. */

/* "$Revision: 136$" */

// $Header: com/sap/me/system/client/browse.js $
// $Name: $

// Some variables used by the browse
var sessionSite='';
// use for call browse from Cognos and Style report.
var browseURI = '';
// use for call browse from Cognos and Style report.
var reportServerURI = '';
var useRegSFCBrowse = false;
// Initialize the variable used by the custom browse to control
// whether revision should be returned.
var revisionAllowed = false;
var customItemFlag = false;

function Wrapit(retString)
{    // escape single quote(s).
    var ind = -2;
    do
    {
        ind = retString.indexOf( "'", ind + 2 );
        if( ind != -1 )
            retString = retString.substring( 0, ind ) + "'" + retString.substring( ind );
    } while( ind != -1 );

    return  retString ;
}

    // A function to allow revision to be passed back to the calling window when using a custom browse.  This function
    // sets the variable revisionAllowed which is used by the browse function based on value passed in revAllowed.
    function customBrowse(browsefield,returnfield, OrgForm,sql,currentValue,currentSite, revisionreturnfield, revAllowed, newBrowse, returnFieldId, revisionFieldId )
    {
        revisionAllowed = revAllowed;
        browse(browsefield,returnfield, OrgForm,sql,currentValue,currentSite, revisionreturnfield, newBrowse, returnFieldId, revisionFieldId );
    }

    // A function to display a browse dialog using the given SQL
    // If you have a standard field that does not have the SQL query defined,
    // then add it to the case statement below.
    // Inputs: browsefield = The name of the field you are browsing on.
    //                       This is used for std browses and must match
    //                       the value below exactly.
    //         returnfield = The name of the field to return the value to.
    //         OrgForm     = The form the return field is on.
    //         sql         = The SQL statement.  If null, then the std browse is used.
    //         currentValue= The current value for the browse field. Used for restricting the browse.
    //                       (if null, then no restriction).
    //         currentSite = The current site used for restricting the browse.
    //                       (if null, then no restriction).
    //         revisionreturnfield = The name of the field to return the revision to.
    //                       NOTE: the query for this field must have RevisionAllowed set to true;
    //         newBrowse       = Flag telling the browse code whether or not this browse is being done for the
    //                           new SCE framework
    //         returnFieldId   = The ID of the field being browsed on
    //         revisionFieldId = The ID of an associated revision field
    //         multipleSelect = Flag telling the browse code whether not this browse should capture and return
    //                          multiple selections.  The default false.
    //         customItemFlag = A unique identifier indicating that this is a browse using the custom item browse which
    //                          is used by Browse.jsp to control what columns are returned to the calling window
    //         returnField3   = The name of the field to return the 3rd value to
    //         returnField3ID = The ID of the field to return the 3rd value to
    //         returnField4   = The name of the field to return the 4th value to
    //         returnField4ID = The ID of the field to return the 4th value to
    //         returnField5   = The name of the field to return the 5th value to
    //         returnField5ID = The ID of the field to return the 5th value to
    //         returnField6   = The name of the field to return the 6th value to
    //         returnField6ID = The ID of the field to return the 6th value to
    function browse(browsefield,returnfield, OrgForm,sql,currentValue,currentSite, revisionreturnfield, newBrowse, returnFieldId, revisionFieldId, multipleSelect,
                              customItemFlag,
                              returnField3, returnField3ID,
                              returnField4, returnField4ID,
                              returnField5, returnField5ID,
                              returnField6, returnField6ID )
    {
        var WinInitHeight = 600;
        var WinInitWidth = 600;
        var RevisionAllowed = false;
        if (sql==null)
        {
            // See if the Query is for SFC or RMA_SFC.  If so, use the standard SFC browse
            if ((browsefield=="SFC" || browsefield=="RMA_SFC") && reportServerURI == '' && !useRegSFCBrowse)
            {
                standardSFCBrowse(browsefield,returnfield, OrgForm,currentValue,currentSite, newBrowse, returnFieldId, multipleSelect )
                return;
            }
            if (currentValue!=null)
                currentValue=Wrapit(trim(currentValue));
            if (currentSite!=null)
                currentSite=Wrapit(trim(currentSite));
            if (currentSite==null)
            {
              // If no site passed in, then use the one from the session (if any)
              if (sessionSite!=null)
              {
                 currentSite=Wrapit(sessionSite);
              }
            }
            // Fallback to any site
            if (currentSite==null)
            {
                currentSite="%";
            }

            // if you are going to allow revision to be populated from your browse, then REVISION must be
            // the second field in the query.
            switch (browsefield)
            {
                case "COMPONENT"       :
                    WinInitWidth = 850;
                    RevisionAllowed = true;
                    break;
                case "ITEM"       :
                case "ASSEMBLY"   :
                    WinInitWidth = 850;
                    RevisionAllowed = true;
                    break;
                case "ITEM2"    :
                    WinInitWidth = 850;
                    RevisionAllowed = true;
                    break;
                case "ITEM_CHG_PROD"   :
                    WinInitWidth = 850;
                    RevisionAllowed = true;
                    break;
                case "ITEM_TRACKABLE"   :
                    WinInitWidth = 850;
                    RevisionAllowed = true;
                    break;
                 case "PLANNED_ITEM"       :
                    WinInitWidth = 850;
                    RevisionAllowed = true;
                    break;
                case "OPERATION"  :
                    WinInitWidth = 850;
                    RevisionAllowed = true;
                    break;
                case "OPERATION_CURRENT_REVISIONS"  :
                    WinInitWidth = 850;
                    RevisionAllowed = true;
                    break;
                case "REASON_CODE"  :
                    WinInitWidth = 850;
                    RevisionAllowed = true;
                    break;
                case "REF_DES"  :
                    WinInitWidth = 850;
                    RevisionAllowed = true;
                    break;
                case "RESOURCE"  :
                case "RESRCE"  :
                    WinInitWidth = 850;
                    break;
                case "ROUTER"  :
                    WinInitWidth = 850;
                    RevisionAllowed = true;
                    break;
                case "ROUTER_PRODUCTION"  :
                    WinInitWidth = 850;
                    RevisionAllowed = true;
                    break;
                case "PLANNED_ROUTER"  :
                    WinInitWidth = 850;
                    RevisionAllowed = true;
                    break;
                case "SHOP_ORDER"        :
                    WinInitWidth = 850;
                    break;
                case "WORK_INSTRUCTION"       :
                    WinInitWidth = 850;
                    RevisionAllowed = true;
                    break;
                case "RMA_NUMBER"       :
                    RevisionAllowed = true;
                    break;
                case "RMA_SHOP_ORDER"        :
                    WinInitWidth = 850;
                    break;
                case "INVENTORY_ID"       :
                    WinInitWidth = 850;
                    break;
                case "INVENTORY_ID_AVAIL"       :
                    WinInitWidth = 850;
                    break;
            }
        } else {
          RevisionAllowed = revisionAllowed;
        }

        var sx = screen.availWidth - 10;
        var sy = screen.availHeight - 40;
        if(sx > WinInitWidth)
            {sx = WinInitWidth;}
        if(sy > WinInitHeight)
            {sy = WinInitHeight;}

        // Compute the values needed to center the browse window on the screen
        var browseWindowX = ( window.screen.availWidth - sx ) / 2;
        var browseWindowY = ( window.screen.availHeight - sy ) / 2;

        // Create a new window that will hold the browse results
        var browseWindow = window.open( "about:blank", "BrowseWindow", 'height=' + sy + ',width=' + sx + ',left=' + browseWindowX + ',top=' + browseWindowY + ',scrollbars=Yes,status=yes,toolbar=no,menubar=no,location=no,resizable=yes,dependent=yes');

        // Submit the browse request
        if (browseWindow) {
            try {
                var request = new PostRequest();
                request.addParam( "browsefield", browsefield );
                request.addParam( "currentSite", currentSite );
                request.addParam( "currentValue", currentValue );
                request.addParam( "returnfield", returnfield );
                request.addParam( "OrgForm", OrgForm );
                request.addParam( "browseorderby", "_NONE_" );

                addXsrfToken(request);

                if (multipleSelect!=null) {
                  request.addParam( "multipleSelect", multipleSelect);
                }

                if (RevisionAllowed && revisionreturnfield != null)    // now, if we're allowed to have a revision and we actually do have one
                {
                    request.addParam( "revisionfield", revisionreturnfield);
                }
                    if (customItemFlag !=null )
                    {
                        request.addParam( "customItemFlag", customItemFlag);
                    }
                    if (returnField3 != null)        // *and* we actually do have one
                    {
                        request.addParam( "returnField3", returnField3);
                    }
                    if (returnField4 != null)        // *and* we actually do have one
                    {
                        request.addParam( "returnField4", returnField4);
                    }
                    if (returnField5 != null)        // *and* we actually do have one
                    {
                        request.addParam( "returnField5", returnField5);
                    }
                    if (returnField6 != null)        // *and* we actually do have one
                    {
                        request.addParam( "returnField6", returnField6);
                    }
                if ( newBrowse != null && newBrowse == "UseNewBrowse" )
                {
                    request.addParam( "newBrowse", "true" );
                    request.addParam( "returnFieldId", returnFieldId );
                    if ( revisionFieldId != null )
                    {
                        request.addParam( "revisionFieldId", revisionFieldId );
                    }
                    if ( returnField3ID != null )
                    {
                        request.addParam( "returnField3ID", returnField3ID );
                    }
                    if ( returnField4ID != null )
                    {
                        request.addParam( "returnField4ID", returnField4ID );
                    }
                    if ( returnField5ID != null )
                    {
                        request.addParam( "returnField5ID", returnField5ID );
                    }
                    if ( returnField6ID != null )
                    {
                        request.addParam( "returnField6ID", returnField6ID );
                    }
                }
                if (reportServerURI != '')
                {
                    request.addParam( "REPORT_SERVER_URI", reportServerURI );
                }
                if (browseURI == '')
                    request.setURL( contextPath + "/com/sap/me/system/common/client/Browse.jsp" );
                else
                    request.setURL( browseURI + contextPath + "/com/sap/me/system/common/client/Browse.jsp" );
                request.submitToWindowOrFrame( "BrowseWindow" );
            } catch ( e ) {
                // Comment out the alert after this works - we need a more robust client-side
                // tracing mechanism!!!
                alert( "Exception: " + e.name + "; Message: " + e.message);
            }
        } else {
            if (PageHelper.messages.disablePopupBlocker) {
                var sMsg = PageHelper.messages.disablePopupBlocker;
                alert(sMsg);
            }
        }
    }
    // A function to display the standard SFC browse dialog for the given fields.
    // If you have a standard field that does not have the SQL query defined,
    // then add it to the case statement below.
    // Inputs: browsefield = The name of the field you are browsing on.
    //                       Assumed to be SFC, unless the browsefield is RMA_SFC.
    //         returnfield = The name of the field to return the value to.
    //         OrgForm     = The form the return field is on.
    //         currentValue= The current value for the browse field. Used for restricting the browse.
    //                       (if null, then no restriction).
    //         currentSite = The current site used for restricting the browse.
    //                       (if null, then no restriction).
    //         newBrowse       = Flag telling the browse code whether or not this browse is being done for the
    //                           new SCE framework
    //         returnFieldId   = The ID of the field being browsed on
    function standardSFCBrowse(browsefield,returnfield, OrgForm,currentValue,currentSite, newBrowse, returnFieldId, multipleSelect )
    {
        if (currentValue!=null)
            currentValue=Wrapit(trim(currentValue));
        if (currentSite!=null)
            currentSite=Wrapit(trim(currentSite));
        if (currentSite==null)
        {
          // If no site passed in, then use the one from the session (if any)
          if (sessionSite!=null)
          {
             currentSite=Wrapit(sessionSite);
          }
        }
        // Fallback to any site
        if (currentSite==null)
        {
            currentSite="%";
        }

        var w = window.screen.availWidth-40;
        var h = window.screen.availHeight-100;

        // Create a new window that will hold the browse results
        var browseWindow = window.open( "about:blank", "SFCBrowseWindow", 'height=' + h + ',width=' + w + ',left=10,top=10,scrollbars=Yes,status=yes,toolbar=no,menubar=no,location=no,resizable=yes,dependent=yes');

        // Submit the browse request
        if (browseWindow) {
            try {
                var request = new PostRequest();
                request.addParam( "SITE", currentSite );
                request.addParam( "SFC_FILTER", currentValue );
                if (multipleSelect!=null && multipleSelect=='true')
                {
                    request.addParam( "SINGLE_SELECT", "false" );
                }
                else
                {
                    request.addParam( "SINGLE_SELECT", "true" );
                }
                if (browsefield=="RMA_SFC")
                {
                    // RMA only wants Done SFCs.
                    // Hardcode the Done status code since the user can change to non-std
                    // status codes if needed in the GUI.
                    request.addParam( "STATUS_FILTER", "405" );
                }
                request.addParam( "browsefield", browsefield );
                request.addParam( "returnfield", returnfield );
                request.addParam( "OrgForm", OrgForm );
                if ( newBrowse != null && newBrowse == "UseNewBrowse" )
                {
                    request.addParam( "newBrowse", "true" );
                    request.addParam( "returnFieldId", returnFieldId );
                }
                request.setURL(contextPath + "/application/setup/SFCBrowseActivity" );
                request.submitToWindowOrFrame( "SFCBrowseWindow" );
            } catch ( e ) {
                // Comment out the alert after this works - we need a more robust client-side
                // tracing mechanism!!!
                alert( "Exception: " + e.name + "; Message: " + e.message);
            }
        } else {
            if (PageHelper.messages.disablePopupBlocker) {
                var sMsg = PageHelper.messages.disablePopupBlocker;
                alert(sMsg);
            }
        }
    }

    function standardInventoryBrowse(browsefield,returnfield, OrgForm,currentValue,currentSite, newBrowse, returnFieldId, multipleSelect )
        {
            if (currentValue!=null)
                currentValue=Wrapit(trim(currentValue));
            if (currentSite!=null)
                currentSite=Wrapit(trim(currentSite));
            if (currentSite==null)
            {
              // If no site passed in, then use the one from the session (if any)
              if (sessionSite!=null)
              {
                 currentSite=Wrapit(sessionSite);
              }
            }
            // Fallback to any site
            if (currentSite==null)
            {
                currentSite="%";
            }

            var w = window.screen.availWidth-40;
            var h = window.screen.availHeight-100;

            // Create a new window that will hold the browse results
            var browseWindow = window.open( "about:blank", "InventoryBrowseWindow", 'height=' + h + ',width=' + w + ',left=10,top=10,scrollbars=Yes,status=yes,toolbar=no,menubar=no,location=no,resizable=yes,dependent=yes');

            // Submit the browse request
            if (browseWindow) {
                try {
                    var request = new PostRequest();
                    request.addParam( "SITE", currentSite );
                    request.addParam( "INVENTORY_ID_FILTER", currentValue );
                    request.addParam( "SINGLE_SELECT", "true" );

                    request.addParam( "browsefield", browsefield );
                    request.addParam( "returnfield", returnfield );
                    request.addParam( "OrgForm", OrgForm );
                    if ( newBrowse != null && newBrowse == "UseNewBrowse" )
                    {
                        request.addParam( "newBrowse", "true" );
                        request.addParam( "returnFieldId", returnFieldId );
                    }
                    request.setURL(contextPath + "/application/setup/InventoryBrowseActivity" );
                    request.submitToWindowOrFrame( "InventoryBrowseWindow" );
                } catch ( e ) {
                    alert( "Exception: " + e.name + "; Message: " + e.message);
                }
            } else {
                if (PageHelper.messages.disablePopupBlocker) {
                    var sMsg = PageHelper.messages.disablePopupBlocker;
                    alert(sMsg);
                }
            }
        }

    // A function to display a browse dialog using the given SQL
    // If you have a standard field that does not have the SQL query defined,
    // then add it to the case statement below.
    // Inputs: browsefield = The name of the field you are browsing on.
    //                       This is used for std browses and must match
    //                       the value below exactly.
    //         returnfield = The name of the field to return the value to.
    //         OrgForm     = The form the return field is on.
    //         serviceAPIDefs         = The SQL API attributes
    //         currentValue= The current value for the browse field. Used for restricting the browse.
    //                       (if null, then no restriction).
    //         currentSite = The current site used for restricting the browse.
    //                       (if null, then no restriction).
    function nonSqlBrowseFunc(browsefield, returnfield, OrgForm, serviceAPIDefs, currentValue, currentSite, revisionFieldId)
    {
        var WinInitHeight = 600;
        var WinInitWidth = 600;
        var RevisionAllowed = false;

        if (currentValue!=null)
                currentValue=Wrapit(trim(currentValue));
        if (currentSite!=null)
                currentSite=Wrapit(trim(currentSite));
        if (currentSite==null)
        {
              // If no site passed in, then use the one from the session (if any)
           if (sessionSite!=null)
           {
                 currentSite=Wrapit(sessionSite);
           }
        }
        // Fallback to any site
        if (currentSite==null)
        {
           currentSite="%";
        }

        // Fallback to any site
        if (currentValue==null)
        {
           currentValue="";
        }

        var sx = screen.availWidth - 10;
        var sy = screen.availHeight - 40;
        if(sx > WinInitWidth)
           {sx = WinInitWidth;}
        if(sy > WinInitHeight)
           {sy = WinInitHeight;}

       // Compute the values needed to center the browse window on the screen
       var browseWindowX = ( window.screen.availWidth - sx ) / 2;
       var browseWindowY = ( window.screen.availHeight - sy ) / 2;
       var browseWindow = window.open( "about:blank", "BrowseWindow", 'height=' + sy + ',width=' + sx + ',left=' + browseWindowX + ',top=' + browseWindowY + ',scrollbars=Yes,status=yes,toolbar=no,menubar=no,location=no,resizable=yes,dependent=yes');
       if (browseWindow) {
           try
           {
                var request = new PostRequest();
                request.addParam( "browsefield", browsefield );
                request.addParam( "returnfield", returnfield );
                request.addParam( "OrgForm", OrgForm );
                request.addParam( "newBrowse", "true" );

                addXsrfToken(request);

                if (null != revisionFieldId) request.addParam( "revisionfield", revisionFieldId);
                if (null != currentValue) request.addParam( "currentValue", currentValue);
                else request.addParam( "currentValue", "");

                request.addParam( "site", currentSite);
                if ((null != serviceAPIDefs) && (serviceAPIDefs.length > 0))
                {
                   request.addParam( "browseDefsSize", ""+serviceAPIDefs.length);
                   for(var i = 0; i < serviceAPIDefs.length; i++)
                   {
                       var attrValue = serviceAPIDefs[i];
                       if (null != attrValue)  request.addParam( "browseDefsAttr"+i, attrValue );
                       else request.addParam( "browseDefsAttr"+i, "" );
                   }
                }
                else
                {
                  request.addParam( "browseDefsSize", "0");
                }

                if (browseURI == '')
                    request.setURL( contextPath + "/com/sap/me/system/common/client/BrowseService.jsp" );
                else
                    request.setURL( browseURI + contextPath + "/com/sap/me/system/common/client/BrowseService.jsp" );
                request.submitToWindowOrFrame( "BrowseWindow" );
            }
            catch ( e )
            {
                alert( "Exception: " + e.name + "; Message: " + e.message);
            }
        } else {
            if (PageHelper.messages.disablePopupBlocker) {
                var sMsg = PageHelper.messages.disablePopupBlocker;
                alert(sMsg);
            }
        }
    }

    // Function to trim leading.trailing spaces.
    function trim(a){
        return a.replace(/^\s+/,'').replace(/\s+$/,'')
    }
    // Key press handler for browses
    function keyPressB(e, fieldName) {
        var event = e || window.event;
        if (event) {
            var keyCode = event.which || event.keyCode;
            if (keyCode == 120 || keyCode==13) {
            	var methodPrefix = "browse";
            	window[methodPrefix + fieldName]();
                event.cancelBubble = true;
                event.returnValue = false;
                if (event.preventDefault) {
                    event.preventDefault();
                }
                return false;
            }
        }
    }

    // function allows to escape ' and & characters in javascript creation of SQL string
    function escapeToSQL (attr) {
      var pattern = "'";
      var re = new RegExp(pattern, 'g');
      return attr.replace (re, "''");
    }

    // browses should be opened from a screen with an existing FORM_ID or APP_ID token
    function addXsrfToken(request) {
        var tokenField = PageHelper.getElementByIdOrName("FORM_ID");
        if (tokenField == null) {
            tokenField = PageHelper.getElementByIdOrName("APP_ID");
        }
        if ((tokenField != null) && tokenField.value) {
            request.addParam("FORM_ID", tokenField.value);
        }
    }
/* (c) Copyright 2008 SAP AG. All rights reserved.*/


/*
 * BaseObject
 * ----------
 * This is the base object for all JavaScript components used in SCE GUIs.
 * It adds support for publishing messages to listeners that can dynamically
 * attach to or detach from the object.  Listeners listen for messages coming
 * from the object, which usually correspond to JavaScript events, but can
 * be any arbitrary string type.
 *
 */

/*
 * EventMap
 * --------
 * This object maps an event to a function on this object.  This maps browser events to event handlers internal to the component.
 * These internal handlers then call the final listener function defined with 'addEventListener'.
 *
 */

 //&*55
 /*
function EventMap( eventName, functionName )
{
    this.eventName = eventName;
    this.functionName = functionName;
}*/

function BaseObject()
{
}
BaseObject.prototype = new Traceable();
BaseObject.prototype.constructor = BaseObject;

/*
 * initializeBaseObject()
 * ----------------------
 * Initializes this object's event and listener queues.
 *
 */
BaseObject.prototype.initializeBaseObject = function()
{
   this.eventListeners = new Object();
   this.preEventListeners = new Object();
}


//&*55
BaseObject.prototype.bindNodeEvent = function( node, eventName, methodName )
{
    node[ eventName ] = new Function( "e", "if ( !e ) e = window.event; var jsObj = PageHelper.getJsObject( this.id );  if( jsObj ) jsObj." + methodName + "( e );" ); // PERFORMANCE FIX
}

/*
 * addEvent( eventName )
 * ---------------------
 * Subclasses of BaseObject should call addEvent() for each each event type
 * the object supports.  eventName should be a string that uniquely defines the
 * event, and is the event name other objects will use to attach as listeners.
 *
 */
BaseObject.prototype.addEvent = function( eventName )
{
    this.preEventListeners[ eventName ] = new Array();
    this.eventListeners[ eventName ] = new Array();
}

/*
 * publishEvent( eventName, eventObject )
 * --------------------------------------
 * Subclasses of BaseObject should call publishEvent() whenever a supported
 * event occurs on the object.  This could be a JavaScript event, such as
 * 'onmouseover', or a user-defined event, such as 'SFC_Changed'.  This method
 * will notify all listeners of the event.
 *
 * The parameter 'eventObject' specifies an event object to be propagated to
 * the listener.  This object should contain any object-specific information
 * that needs to be propagated to the listener.
 *
 * The event object can be any user-defined type, but it is recommended in most
 * cases that it be a subclass of BaseEvent.  The framework will only add
 * information about the client's state (mouse position, keys pressed, etc.)
 * to subclasses of the BaseEvent object.
 *
 */
BaseObject.prototype.publishEvent = function( eventName, eventObject )
{
    // First, notify all pre-event listeners, in case one of them needs to
    // cancel the event
    var listeners = this.preEventListeners[ eventName ];
    if ( listeners != null )
    {
        for ( var listener in listeners )
        {
            var listenerObject = listeners[ listener ];
            if ( !listenerObject.notify( eventObject ) )
            {
                // tf: Comment this out to see if it affects performance.
                //&*2TraceWindow.trace( "Listener cancelled event " + eventName + " from " + this.id, TraceWindow.INFO, "Events," + this.id );
                eventObject.cancelEvent();
                return false;
            }
        }
    }

    // Now, publish the actual event
    listeners = this.eventListeners[ eventName ];

    if ( listeners != null )
    {
        for ( var listener in listeners )
        {
            var listenerObject = listeners[ listener ];
            listenerObject.notify( eventObject );
            //&*2TraceWindow.trace( "Published event " + eventName + " from " + this.id, TraceWindow.DEBUG, "Events," + this.id );
        }
    }

    return true;
}

/*
 * addPreEventListener( eventName, objectOrFunction, methodName )
 * --------------------------------------------------------------
 * Adds a listener to this object.  'eventName' specifies the name of the event
 * the caller wants to listen for.  'objectOrFunction' can specify either a
 * subclass of BaseObject, or a JavaScript function.  If 'objectOrFunction'
 * is a subclass of BaseObject, then 'methodName' specifies the name of the
 * method to call on the object.  If ommitted, 'methodName' defaults to 'notify'.
 *
 * A listener should register as a "pre-event" listener if it wants to be able
 * to cancel events.  The pre-event listener function should only return true
 * if the event can proceed or false if it should be cancelled.  Any code that
 * depends on an event taking place should only be executed when the event
 * actually fires, not when the pre-event fires.
 *
 */
BaseObject.prototype.addPreEventListener = function( eventName, objectOrFunction, methodName )
{
    var listeners = this.preEventListeners[ eventName ];
    var listener = null;

    if ( objectOrFunction instanceof BaseObject )
    {
        if ( methodName == null )
        {
            listener = new Listener( objectOrFunction, "notify" );
        }
        else
        {
            listener = new Listener( objectOrFunction, methodName );
        }
        listeners[ objectOrFunction.id ] = listener;
        //&*2TraceWindow.trace( "Added a pre-event listener to " + this.id + " for event " + eventName + ": " + objectOrFunction.id, TraceWindow.DEBUG, "Events," + this.id );
    }
    else
    {
        listener = new Listener( objectOrFunction );
        listeners[ PageHelper.getFunctionName( objectOrFunction ) ] = listener;
        //&*2TraceWindow.trace( "Added a pre-event listener to " + this.id + " for event " + eventName + ": " + PageHelper.getFunctionName( objectOrFunction ), TraceWindow.DEBUG, "Events," + this.id );
    }
}

/*
 * addEventListener( eventName, objectOrFunction, methodName )
 * -----------------------------------------------------------
 * Adds a listener to this object.  'eventName' specifies the name of the event
 * the caller wants to listen for.  'objectOrFunction' can specify either a
 * subclass of BaseObject, or a JavaScript function.  If 'objectOrFunction'
 * is a subclass of BaseObject, then 'methodName' specifies the name of the
 * method to call on the object.  If ommitted, 'methodName' defaults to 'notify'.
 *
 */
BaseObject.prototype.addEventListener = function( eventName, objectOrFunction, methodName )
{
    var listeners = this.eventListeners[ eventName ];
    var listener = null;

    if ( objectOrFunction instanceof BaseObject )
    {
        if ( methodName == null )
        {
            listener = new Listener( objectOrFunction, "notify" );
        }
        else
        {
            listener = new Listener( objectOrFunction, methodName );
        }
        listeners[ objectOrFunction.id ] = listener;
        //&*2TraceWindow.trace( "Added an event listener to " + this.id + " for event " + eventName + ": " + objectOrFunction.id, TraceWindow.DEBUG, "Events," + this.id );
    }
    else
    {
        listener = new Listener( objectOrFunction );
        listeners[ PageHelper.getFunctionName( objectOrFunction ) ] = listener;
        //&*2TraceWindow.trace( "Added an event listener to " + this.id + " for event " + eventName + ": " + PageHelper.getFunctionName( objectOrFunction ), TraceWindow.DEBUG, "Events," + this.id );
    }
}

/*

*//* (c) Copyright 2008 SAP AG. All rights reserved.*/


/*
 * Traceable
 * ---------
 * This object allows any JavaScript object to trace to the tracewindow.
 *
 */

function Traceable()
{
}

Traceable.prototype.setTracingCategories = function( categories )
{
    if ( categories != null )
    {
        this.categories = categories;
    }
    else
    {
        this.categories = TraceWindow.ALL;
    }
}

Traceable.prototype.debug = function( message )
{
    if ( TraceWindow.tracingEnabled )
    {
        TraceWindow.trace( message, TraceWindow.DEBUG, this.categories );
    }
}

Traceable.prototype.info = function( message )
{
    if ( TraceWindow.tracingEnabled )
    {
        TraceWindow.trace( message, TraceWindow.INFO, this.categories );
    }
}

Traceable.prototype.warning = function( message )
{
    if ( TraceWindow.tracingEnabled )
    {
        TraceWindow.trace( message, TraceWindow.WARNING, this.categories );
    }
}

Traceable.prototype.error = function( message )
{
    if ( TraceWindow.tracingEnabled )
    {
        TraceWindow.trace( message, TraceWindow.ERROR, this.categories );
    }
}

Traceable.prototype.toString = function()
{
    return "(This object does not override toString())";
}
	/*
	 * Encoding according to the Secure Programming Guide
	 * <SAPWIKI>/wiki/display/NWCUIAMSIM/XSS+Secure+Programming+Guide
	 */

	/**
	 * Create hex and pad to length
	 * @private
	 */
	function hex(iChar, iLength) {
		var sHex = iChar.toString(16);
		if (iLength) {
			while (iLength > sHex.length) {
				sHex = "0" + sHex;
			}
		}
		return sHex;
	}

	/**
	 * RegExp and escape function for HTML escaping
	 */
	var rHtml = /[\x00-\x2b\x2f\x3a-\x40\x5b-\x5e\x60\x7b-\xff\u2028\u2029]/g,
		rHtmlReplace = /[\x00-\x08\x0b\x0c\x0e-\x1f\x7f-\x9f]/,
		mHtmlLookup = {
			"<": "&lt;",
			">": "&gt;",
			"&": "&amp;",
			"\"": "&quot;"
		};

	var fHtml = function(sChar) {
		var sEncoded = mHtmlLookup[sChar];
		if (!sEncoded) {
			if (rHtmlReplace.test(sChar)) {
				sEncoded = "&#xfffd;";
			} else {
				sEncoded = "&#x" + hex(sChar.charCodeAt(0)) + ";";
			}
			mHtmlLookup[sChar] = sEncoded;
		}
		return sEncoded;
	};

	/**
	 * Encode the string for inclusion into HTML content/attribute
	 *
	 * @param {string} sString The string to be escaped
	 * @return The escaped string
	 * @type {string}
	 * @public
	 * @SecValidate {0|return|XSS} validates the given string for HTML contexts
	 */
	encodeHTML = function(sString) {
		return sString.replace(rHtml, fHtml);
	};

	/**
	 * Encode the string for inclusion into XML content/attribute
	 *
	 * @param {string} sString The string to be escaped
	 * @return The escaped string
	 * @type {string}
	 * @public
	 * @SecValidate {0|return|XSS} validates the given string for XML contexts
	 */
	encodeXML = function(sString) {
		return sString.replace(rHtml, fHtml);
	};

	/**
	 * Encode the string for inclusion into HTML content/attribute.
	 * Old name "escapeHTML" kept for backward compatibility
	 *
	 * @param {string} sString The string to be escaped
	 * @return The escaped string
	 * @type {string}
	 * @public
	 * @deprecated Has been renamed, use {@link encodeHTML} instead.
	 */
	escapeHTML = function(sString) {
		return sString.replace(rHtml, fHtml);
	};

	/**
	 * RegExp and escape function for JS escaping
	 */
	var rJS = /[\x00-\x2b\x2d\x2f\x3a-\x40\x5b-\x5e\x60\x7b-\xff\u2028\u2029]/g,
		mJSLookup = {};

	var fJS = function(sChar) {
		var sEncoded = mJSLookup[sChar];
		if (!sEncoded) {
			var iChar = sChar.charCodeAt(0);
			if (iChar < 256) {
				sEncoded = "\\x" + hex(iChar, 2);
			} else {
				sEncoded = "\\u" + hex(iChar, 4);
			}
			mJSLookup[sChar] = sEncoded;
		}
		return sEncoded;
	};

	/**
	 * Encode the string for inclusion into a JS string literal
	 *
	 * @param {string} sString The string to be escaped
	 * @return The escaped string
	 * @type {string}
	 * @public
	 * @SecValidate {0|return|XSS} validates the given string for a JavaScript contexts
	 */
	encodeJS = function(sString) {
		return sString.replace(rJS, fJS);
	};

	/**
	 * Encode the string for inclusion into a JS string literal.
	 * Old name "escapeJS" kept for backward compatibility
	 *
	 * @param {string} sString The string to be escaped
	 * @return The escaped string
	 * @type {string}
	 * @public
	 * @deprecated Since 1.3.0. Has been renamed, use {@link encodeJS} instead.
	 */
	escapeJS = function(sString) {
		return sString.replace(rJS, fJS);
	};

	/**
	 * RegExp and escape function for URL escaping
	 */
	var rURL = /[\x00-\x2c\x2f\x3a-\x40\x5b-\x5e\x60\x7b-\uffff]/g,
		mURLLookup = {};

	var fURL = function(sChar) {
		var sEncoded = mURLLookup[sChar];
		if (!sEncoded) {
			var iChar = sChar.charCodeAt(0);
			if (iChar < 128) {
				sEncoded = "%" + hex(iChar, 2);
			} else if (iChar < 2048) {
				sEncoded = "%" + hex((iChar >> 6) | 192, 2) +
						   "%" + hex((iChar & 63) | 128, 2);
			} else {
				sEncoded = "%" + hex((iChar >> 12) | 224, 2) +
						   "%" + hex(((iChar >> 6) & 63) | 128, 2) +
						   "%" + hex((iChar & 63) | 128, 2);
			}
			mURLLookup[sChar] = sEncoded;
		}
		return sEncoded;
	};

	/**
	 * Encode the string for inclusion into a URL parameter
	 *
	 * @param {string} sString The string to be escaped
	 * @return The escaped string
	 * @type {string}
	 * @public
	 * @SecValidate {0|return|XSS} validates the given string for a URL context
	 */
	encodeURL = function(sString) {
		return sString.replace(rURL, fURL);
	};

	/**
	 * Encode a map of parameters into a combined URL parameter string
	 *
	 * @param {object} mParams The map of parameters to encode
	 * @return The URL encoded parameters
	 * @type {string}
	 * @public
	 * @SecValidate {0|return|XSS} validates the given string for a CSS context
	 */
	encodeURLParameters = function(mParams) {
		if (!mParams) {
			return "";
		}
		var aUrlParams = [];
		jQuery.each(mParams, function (sName, oValue) {
			if (jQuery.type(oValue) === "string") {
				oValue = encodeURL(oValue);
			}
			aUrlParams.push(encodeURL(sName) + "=" + oValue);
		});
		return aUrlParams.join("&");
	};

	/**
	 * RegExp and escape function for CSS escaping
	 */
	var rCSS = /[\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xff\u2028\u2029][0-9A-Fa-f]?/g;

	var fCSS = function(sChar) {
		var iChar = sChar.charCodeAt(0);
		if (sChar.length == 1) {
			return "\\" + hex(iChar);
		} else {
			return "\\" + hex(iChar) + " " + sChar.substr(1);
		}
	};

	/**
	 * Encode the string for inclusion into CSS string literals or identifiers
	 *
	 * @param {string} sString The string to be escaped
	 * @return The escaped string
	 * @type {string}
	 * @public
	 * @SecValidate {0|return|XSS} validates the given string for a CSS context
	 */
	encodeCSS = function(sString) {
		return sString.replace(rCSS, fCSS);
	};

	/**
	 * WhitelistEntry object
	 * @param {string} protocol The protocol of the URL
	 * @param {string} host The host of the URL
	 * @param {string} port The port of the URL
	 * @param {string} path the path of the URL
	 * @public
	 */
	function WhitelistEntry(protocol, host, port, path){
		if (protocol) {
			this.protocol = protocol.toUpperCase();
		}
		if (host) {
			this.host = host.toUpperCase();
		}
		this.port = port;
		this.path = path;
	}

	var aWhitelist = [];

	/**
	 * Clears the whitelist for URL validation
	 *
	 * @public
	 */
	clearUrlWhitelist = function() {

		aWhitelist.splice(0,aWhitelist.length);

	};

	/**
	 * Adds a whitelist entry for URL validation.
	 *
	 * @param {string} protocol The protocol of the URL
	 * @param {string} host The host of the URL
	 * @param {string} port The port of the URL
	 * @param {string} path the path of the URL
	 * @public
	 */
	addUrlWhitelist = function(protocol, host, port, path) {
		var oEntry = new WhitelistEntry(protocol, host, port, path);
		var iIndex = aWhitelist.length;
		aWhitelist[iIndex] = oEntry;
	};

	/**
	 * Removes a whitelist entry for URL validation.
	 *
	 * @param {int} iIndex index of entry
	 * @public
	 */
	removeUrlWhitelist = function(iIndex) {
		aWhitelist.splice(iIndex,1);
	};

	/**
	 * Gets the whitelist for URL validation.
	 *
	 * @return {object[]} A copy of the whitelist
	 * @public
	 */
	getUrlWhitelist = function() {
		return aWhitelist.slice();
	};

	/**
	 * Validates a URL. Check if it's not a script or other security issue.
	 *
	 * Split URL into components and check for allowed characters according to RFC 3986:
	 *
	 * <pre>
	 * authority     = [ userinfo "@" ] host [ ":" port ]
	 * userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
	 * host          = IP-literal / IPv4address / reg-name
	 *
	 * IP-literal    = "[" ( IPv6address / IPvFuture  ) "]"
	 * IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
	 * IPv6address   =                            6( h16 ":" ) ls32
	 *               /                       "::" 5( h16 ":" ) ls32
	 *               / [               h16 ] "::" 4( h16 ":" ) ls32
	 *               / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
	 *               / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
	 *               / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
	 *               / [ *4( h16 ":" ) h16 ] "::"              ls32
	 *               / [ *5( h16 ":" ) h16 ] "::"              h16
	 *               / [ *6( h16 ":" ) h16 ] "::"
	 * ls32          = ( h16 ":" h16 ) / IPv4address
	 *               ; least-significant 32 bits of address
	 * h16           = 1*4HEXDIG
 	 *               ; 16 bits of address represented in hexadecimal
 	 *
	 * IPv4address   = dec-octet "." dec-octet "." dec-octet "." dec-octet
	 * dec-octet     = DIGIT                 ; 0-9
	 *               / %x31-39 DIGIT         ; 10-99
	 *               / "1" 2DIGIT            ; 100-199
	 *               / "2" %x30-34 DIGIT     ; 200-249
	 *               / "25" %x30-35          ; 250-255
	 *
	 * reg-name      = *( unreserved / pct-encoded / sub-delims )
	 *
	 * pct-encoded   = "%" HEXDIG HEXDIG
	 * reserved      = gen-delims / sub-delims
	 * gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
	 * sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
	 *               / "*" / "+" / "," / ";" / "="
	 * unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
	 * pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
	 *
	 * path          = path-abempty    ; begins with "/" or is empty
	 *               / path-absolute   ; begins with "/" but not "//"
	 *               / path-noscheme   ; begins with a non-colon segment
	 *               / path-rootless   ; begins with a segment
	 *               / path-empty      ; zero characters
	 *
	 * path-abempty  = *( "/" segment )
	 * path-absolute = "/" [ segment-nz *( "/" segment ) ]
	 * path-noscheme = segment-nz-nc *( "/" segment )
	 * path-rootless = segment-nz *( "/" segment )
	 * path-empty    = 0<pchar>
	 * segment       = *pchar
	 * segment-nz    = 1*pchar
	 * segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / "@" )
	 *               ; non-zero-length segment without any colon ":"
	 *
	 * query         = *( pchar / "/" / "?" )
	 *
	 * fragment      = *( pchar / "/" / "?" )
	 * </pre>
	 *
	 * For the hostname component, we are checking for valid DNS hostnames according to RFC 952 / RFC 1123:
	 *
	 * <pre>
	 * hname         = name *("." name)
	 * name          = let-or-digit ( *( let-or-digit-or-hyphen ) let-or-digit )
	 * </pre>
	 *
	 *
	 * When the URI uses the protocol 'mailto:', the address part is additionally checked
	 * against the most commonly used parts of RFC 6068:
	 *
	 * <pre>
	 * mailtoURI     = "mailto:" [ to ] [ hfields ]
	 * to            = addr-spec *("," addr-spec )
	 * hfields       = "?" hfield *( "&" hfield )
	 * hfield        = hfname "=" hfvalue
	 * hfname        = *qchar
	 * hfvalue       = *qchar
	 * addr-spec     = local-part "@" domain
	 * local-part    = dot-atom-text              // not accepted: quoted-string
	 * domain        = dot-atom-text              // not accepted: "[" *dtext-no-obs "]"
	 * dtext-no-obs  = %d33-90 / ; Printable US-ASCII
	 *                 %d94-126  ; characters not including
	 *                           ; "[", "]", or "\"
	 * qchar         = unreserved / pct-encoded / some-delims
	 * some-delims   = "!" / "$" / "'" / "(" / ")" / "*"
	 *               / "+" / "," / ";" / ":" / "@"
	 *
	 * Note:
	 * A number of characters that can appear in &lt;addr-spec> MUST be
	 * percent-encoded.  These are the characters that cannot appear in
	 * a URI according to [STD66] as well as "%" (because it is used for
	 * percent-encoding) and all the characters in gen-delims except "@"
	 * and ":" (i.e., "/", "?", "#", "[", and "]").  Of the characters
	 * in sub-delims, at least the following also have to be percent-
	 * encoded: "&", ";", and "=".  Care has to be taken both when
	 * encoding as well as when decoding to make sure these operations
	 * are applied only once.
	 *
	 * </pre>
	 *
	 * When a whitelist has been configured using {@link #.addUrlWhitelist addUrlWhitelist},
	 * any URL that passes the syntactic checks above, additionally will be tested against
	 * the content of the whitelist.
	 *
	 * @param {string} sUrl
	 * @return true if valid, false if not valid
	 * @public
	 */
	validateUrl = function(sUrl) {

		var result = /^(?:([^:\/?#]+):)?((?:\/\/((?:\[[^\]]+\]|[^\/?#:]+))(?::([0-9]+))?)?([^?#]*))(?:\?([^#]*))?(?:#(.*))?$/.exec(sUrl);
		if (!result) {
			return false;
		}

		var sProtocol = result[1],
			sBody = result[2],
			sHost = result[3],
			sPort = result[4],
			sPath = result[5],
			sQuery = result[6],
			sHash = result[7];

		var rCheckPath = /^([a-z0-9-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*$/i;
		var rCheckQuery = /^([a-z0-9-._~!$&'()*+,;=:@\/?]|%[0-9a-f]{2})*$/i;
		var rCheckFragment = rCheckQuery;
		var rCheckMail = /^([a-z0-9!$'*+:^_`{|}~-]|%[0-9a-f]{2})+(?:\.([a-z0-9!$'*+:^_`{|}~-]|%[0-9a-f]{2})+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i;
		var rCheckIPv4 = /^([0-9]{1,3}\.){3}[0-9]{1,3}$/;
		var rCheckValidIPv4 = /^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/;
		var rCheckIPv6 = /^\[[^\]]+\]$/;
		var rCheckValidIPv6 = /^\[(((([0-9a-f]{1,4}:){6}|(::([0-9a-f]{1,4}:){5})|(([0-9a-f]{1,4})?::([0-9a-f]{1,4}:){4})|((([0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::([0-9a-f]{1,4}:){3})|((([0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::([0-9a-f]{1,4}:){2})|((([0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:)|((([0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::))(([0-9a-f]{1,4}:[0-9a-f]{1,4})|(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])))|((([0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4})|((([0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::))\]$/i;
		var rCheckHostName = /^([a-z0-9]([a-z0-9\-]*[a-z0-9])?\.)*[a-z0-9]([a-z0-9\-]*[a-z0-9])?$/i;

		// protocol
		if (sProtocol) {
			sProtocol = sProtocol.toUpperCase();
			if (aWhitelist.length <= 0) {
				// no whitelist -> check for default protocols
				if (!/^(https?|ftp)/i.test(sProtocol)) {
					return false;
				}
			}
		}

		// Host -> validity check for IP address or hostname
		if (sHost) {
			if (rCheckIPv4.test(sHost)) {
				if (!rCheckValidIPv4.test(sHost)) {
					//invalid ipv4 address
					return false;
				}
			} else if (rCheckIPv6.test(sHost)) {
				if (!rCheckValidIPv6.test(sHost)) {
					//invalid ipv6 address
					return false;
				}
			} else if (!rCheckHostName.test(sHost)) {
				// invalid host name
				return false;
			}
			sHost = sHost.toUpperCase();
		}

		// Path -> split for "/" and check if forbidden characters exist
		if (sPath) {
			if (sProtocol === "MAILTO") {
				var aAddresses = sBody.split(",");
				for ( var i = 0; i < aAddresses.length; i++) {
					if (!rCheckMail.test(aAddresses[i])) {
						// forbidden character found
						return false;
					}
				}
			} else {
				var aComponents = sPath.split("/");
				for ( var i = 0; i < aComponents.length; i++) {
					if (!rCheckPath.test(aComponents[i])) {
						// forbidden character found
						return false;
					}
				}
			}
		}

		// query
		if (sQuery) {
			if (!rCheckQuery.test(sQuery)) {
				// forbidden character found
				return false;
			}
		}

		// hash
		if (sHash) {
			if (!rCheckFragment.test(sHash)) {
				// forbidden character found
				return false;
			}
		}

		//filter whitelist
		if (aWhitelist.length > 0) {
			var bFound = false;
			for (var i = 0; i < aWhitelist.length; i++) {
				assert(aWhitelist[i] instanceof WhitelistEntry, "whitelist entry type wrong");
				if (!sProtocol || !aWhitelist[i].protocol || sProtocol == aWhitelist[i].protocol) {
					// protocol OK
					var bOk = false;
					if (sHost && aWhitelist[i].host && /^\*/.test(aWhitelist[i].host)) {
						// check for wildcard search at begin
						var sHostEscaped = aWhitelist[i].host.slice(1).replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
						var rFilter = RegExp(sHostEscaped + "$");
						if (rFilter.test(sHost)) {
							bOk = true;
						}
					} else if (!sHost || !aWhitelist[i].host || sHost == aWhitelist[i].host) {
						bOk = true;
					}
					if (bOk) {
						// host OK
						if ((!sHost && !sPort) || !aWhitelist[i].port || sPort == aWhitelist[i].port) {
							// port OK
							if (aWhitelist[i].path && /\*$/.test(aWhitelist[i].path)) {
								// check for wildcard search at end
								var sPathEscaped = aWhitelist[i].path.slice(0, -1).replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
								var rFilter = RegExp("^" + sPathEscaped);
								if (rFilter.test(sPath)) {
									bFound = true;
								}
							} else if (!aWhitelist[i].path || sPath == aWhitelist[i].path) {
								// path OK
								bFound = true;
							}
						}
					}
				}
				if (bFound) {
					break;
				}
			}
			if (!bFound) {
				return false;
			}
		}

		return true;
	};

	/**
	 * Strips unsafe tags and attributes from HTML.
	 *
	 * @param {string} sHTML the HTML to be sanitized.
	 * @param {object} [mOptions={}] options for the sanitizer
	 * @return {string} sanitized HTML
	 * @private
	 */
	_sanitizeHTML = function(sHTML, mOptions) {
		return fnSanitizer(sHTML, mOptions || {
			uriRewriter: function(sUrl) {
				// by default we use the URL whitelist to check the URL's
				if (validateUrl(sUrl)) {
					return sUrl;
				}
			}
		});
	};

	/**
	 * Registers an application defined sanitizer to be used instead of the built-in one.
	 *
	 * The given sanitizer function must have the same signature as
	 * {@link _sanitizeHTML}:
	 *
	 * <pre>
	 *   function sanitizer(sHtml, mOptions);
	 * </pre>
	 *
	 * The parameter <code>mOptions</code> will always be provided, but might be empty.
	 * The set of understood options is defined by the sanitizer. If no specific
	 * options are given, the sanitizer should run with the most secure settings.
	 * Sanitizers should ignore unknown settings. Known, but misconfigured settings should be
	 * reported as error.
	 *
	 * @param {function} fnSanitizer
	 * @private
	 */
	_setHTMLSanitizer = function (fnSanitizer) {
		assert(typeof fnSanitizer === "function", "Sanitizer must be a function");
		fnSanitizer = fnSanitizer || defaultSanitizer;
	};

	function defaultSanitizer(sHTML, mOptions) {
		if ( !window.html || !window.html.sanitize ) {
			require("sap.ui.thirdparty.caja-html-sanitizer");
			assert(window.html && window.html.sanitize, "Sanitizer should have been loaded");
		}

		var oTagPolicy = mOptions.tagPolicy || window.html.makeTagPolicy(mOptions.uriRewriter, mOptions.tokenPolicy);
		return window.html.sanitizeWithPolicy(sHTML, oTagPolicy);
	}

